!function(e){function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var t={};return n.m=e,n.c=t,n.p="",n(0)}([function(e,n,t){e.exports=t(1)},function(e,n,t){"use strict";var r=t(2);t(3),window.Polymer={dom:"shadow",lazyRegister:!0,useNativeCSSProperties:!0},t(6),t(7),window.addEventListener("WebComponentsReady",function(){var e=t(11),n=document.getElementById("root");e.Main.embed(n)}),r.initialize("UA-64071383-4"),r.pageview("/")},function(e,n,t){var r,o;!function(t){"use strict";function a(e){console.warn("[analytics]",e)}function i(){for(var e=[],n=arguments.length,t=0;t<n;t++)e.push(arguments[t]);for(;"undefined"==typeof e[e.length-1];)e.pop();this._namespace&&(e[0]=this._namespace+"."+e[0],this._namespace=null),window&&"function"==typeof window.ga&&window.ga.apply(void 0,e)}var s=function(){return this};s.prototype={initialize:function(e,n){var t="https://www.google-analytics.com/";"object"==typeof e&&(n=e),n=n||{},n.debug?(t+="analytics_debug.js",delete n.debug):t+="analytics.js",function(e,n,t,r,o,a,i){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,a=n.createElement(t),i=n.getElementsByTagName(t)[0],a.async=1,a.src=r,i.parentNode.insertBefore(a,i)}(window,document,"script",t,"ga"),e&&(n="{}"===JSON.stringify(n)?void 0:n,this.create(e,n))},create:function(e,n){return e?void i.call(this,"create",e,"auto",n):void a("tracking id is required to initialize.")},name:function(e){var n=new s;return n._namespace=e,n},set:function(e,n){return e&&e.length?(i.call(this,"set",e,n),this):void a("set: `key` is required.")},pageview:function(e,n){return i.call(this,"send","pageview",e,n),this},screenview:function(e,n){return e?(n=n||{},n.screenName=e,i.call(this,"send","screenview",n),this):void a("screenview: `screenName` is required.")},event:function(e,n,t){return e&&n?(t&&"undefined"!=typeof t.eventValue&&"number"!=typeof t.eventValue&&(a("event: expected `options.eventValue` to be a Number."),t.eventValue=void 0),t&&t.nonInteraction&&"boolean"!=typeof t.nonInteraction&&(a("event: expected `options.nonInteraction` to be a boolean."),t.nonInteraction=!1),i.call(this,"send","event",e,n,t),this):void a("event: both `category` and `action` are required.")},timing:function(e,n,t,r){return e&&n&&"undefined"!=typeof t?"number"!=typeof t?a("event: expected `timingValue` to be a Number."):i.call(this,"send","timing",e,n,t,r):a("timing: `timingCategory`, `timingVar`, and `timingValue` are required."),this},exception:function(e,n){return i.call(this,"send","exception",{exDescription:e,exFatal:!!n}),this},custom:function(e,n){return/(dimension|metric)[0-9]+/i.test(e)?(i.call(this,"set",e,n),this):void a("custom: key must match dimension[0-9]+ or metric[0-9]+")}};var c=new s;r=[],o=function(){return c}.apply(n,r),!(void 0!==o&&(e.exports=o))}(this)},function(e,n,t){t(4)(t(5))},function(e,n){e.exports=function(e){"undefined"!=typeof execScript?execScript(e):eval.call(null,e)}},function(e,n){e.exports='/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n// @version 0.7.23\n(function() {\n  window.WebComponents = window.WebComponents || {\n    flags: {}\n  };\n  var file = "webcomponents.js";\n  var script = document.querySelector(\'script[src*="\' + file + \'"]\');\n  var flags = {};\n  if (!flags.noOpts) {\n    location.search.slice(1).split("&").forEach(function(option) {\n      var parts = option.split("=");\n      var match;\n      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {\n        flags[match[1]] = parts[1] || true;\n      }\n    });\n    if (script) {\n      for (var i = 0, a; a = script.attributes[i]; i++) {\n        if (a.name !== "src") {\n          flags[a.name] = a.value || true;\n        }\n      }\n    }\n    if (flags.log && flags.log.split) {\n      var parts = flags.log.split(",");\n      flags.log = {};\n      parts.forEach(function(f) {\n        flags.log[f] = true;\n      });\n    } else {\n      flags.log = {};\n    }\n  }\n  flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;\n  if (flags.shadow === "native") {\n    flags.shadow = false;\n  } else {\n    flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;\n  }\n  if (flags.register) {\n    window.CustomElements = window.CustomElements || {\n      flags: {}\n    };\n    window.CustomElements.flags.register = flags.register;\n  }\n  WebComponents.flags = flags;\n})();\n\nif (WebComponents.flags.shadow) {\n  if (typeof WeakMap === "undefined") {\n    (function() {\n      var defineProperty = Object.defineProperty;\n      var counter = Date.now() % 1e9;\n      var WeakMap = function() {\n        this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");\n      };\n      WeakMap.prototype = {\n        set: function(key, value) {\n          var entry = key[this.name];\n          if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {\n            value: [ key, value ],\n            writable: true\n          });\n          return this;\n        },\n        get: function(key) {\n          var entry;\n          return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\n        },\n        "delete": function(key) {\n          var entry = key[this.name];\n          if (!entry || entry[0] !== key) return false;\n          entry[0] = entry[1] = undefined;\n          return true;\n        },\n        has: function(key) {\n          var entry = key[this.name];\n          if (!entry) return false;\n          return entry[0] === key;\n        }\n      };\n      window.WeakMap = WeakMap;\n    })();\n  }\n  window.ShadowDOMPolyfill = {};\n  (function(scope) {\n    "use strict";\n    var constructorTable = new WeakMap();\n    var nativePrototypeTable = new WeakMap();\n    var wrappers = Object.create(null);\n    function detectEval() {\n      if (typeof chrome !== "undefined" && chrome.app && chrome.app.runtime) {\n        return false;\n      }\n      if (navigator.getDeviceStorage) {\n        return false;\n      }\n      try {\n        var f = new Function("return true;");\n        return f();\n      } catch (ex) {\n        return false;\n      }\n    }\n    var hasEval = detectEval();\n    function assert(b) {\n      if (!b) throw new Error("Assertion failed");\n    }\n    var defineProperty = Object.defineProperty;\n    var getOwnPropertyNames = Object.getOwnPropertyNames;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    function mixin(to, from) {\n      var names = getOwnPropertyNames(from);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n      }\n      return to;\n    }\n    function mixinStatics(to, from) {\n      var names = getOwnPropertyNames(from);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        switch (name) {\n         case "arguments":\n         case "caller":\n         case "length":\n         case "name":\n         case "prototype":\n         case "toString":\n          continue;\n        }\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n      }\n      return to;\n    }\n    function oneOf(object, propertyNames) {\n      for (var i = 0; i < propertyNames.length; i++) {\n        if (propertyNames[i] in object) return propertyNames[i];\n      }\n    }\n    var nonEnumerableDataDescriptor = {\n      value: undefined,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    };\n    function defineNonEnumerableDataProperty(object, name, value) {\n      nonEnumerableDataDescriptor.value = value;\n      defineProperty(object, name, nonEnumerableDataDescriptor);\n    }\n    getOwnPropertyNames(window);\n    function getWrapperConstructor(node, opt_instance) {\n      var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);\n      if (isFirefox) {\n        try {\n          getOwnPropertyNames(nativePrototype);\n        } catch (error) {\n          nativePrototype = nativePrototype.__proto__;\n        }\n      }\n      var wrapperConstructor = constructorTable.get(nativePrototype);\n      if (wrapperConstructor) return wrapperConstructor;\n      var parentWrapperConstructor = getWrapperConstructor(nativePrototype);\n      var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);\n      registerInternal(nativePrototype, GeneratedWrapper, opt_instance);\n      return GeneratedWrapper;\n    }\n    function addForwardingProperties(nativePrototype, wrapperPrototype) {\n      installProperty(nativePrototype, wrapperPrototype, true);\n    }\n    function registerInstanceProperties(wrapperPrototype, instanceObject) {\n      installProperty(instanceObject, wrapperPrototype, false);\n    }\n    var isFirefox = /Firefox/.test(navigator.userAgent);\n    var dummyDescriptor = {\n      get: function() {},\n      set: function(v) {},\n      configurable: true,\n      enumerable: true\n    };\n    function isEventHandlerName(name) {\n      return /^on[a-z]+$/.test(name);\n    }\n    function isIdentifierName(name) {\n      return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);\n    }\n    function getGetter(name) {\n      return hasEval && isIdentifierName(name) ? new Function("return this.__impl4cf1e782hg__." + name) : function() {\n        return this.__impl4cf1e782hg__[name];\n      };\n    }\n    function getSetter(name) {\n      return hasEval && isIdentifierName(name) ? new Function("v", "this.__impl4cf1e782hg__." + name + " = v") : function(v) {\n        this.__impl4cf1e782hg__[name] = v;\n      };\n    }\n    function getMethod(name) {\n      return hasEval && isIdentifierName(name) ? new Function("return this.__impl4cf1e782hg__." + name + ".apply(this.__impl4cf1e782hg__, arguments)") : function() {\n        return this.__impl4cf1e782hg__[name].apply(this.__impl4cf1e782hg__, arguments);\n      };\n    }\n    function getDescriptor(source, name) {\n      try {\n        if (source === window && name === "showModalDialog") {\n          return dummyDescriptor;\n        }\n        return Object.getOwnPropertyDescriptor(source, name);\n      } catch (ex) {\n        return dummyDescriptor;\n      }\n    }\n    var isBrokenSafari = function() {\n      var descr = Object.getOwnPropertyDescriptor(Node.prototype, "nodeType");\n      return descr && !descr.get && !descr.set;\n    }();\n    function installProperty(source, target, allowMethod, opt_blacklist) {\n      var names = getOwnPropertyNames(source);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        if (name === "polymerBlackList_") continue;\n        if (name in target) continue;\n        if (source.polymerBlackList_ && source.polymerBlackList_[name]) continue;\n        if (isFirefox) {\n          source.__lookupGetter__(name);\n        }\n        var descriptor = getDescriptor(source, name);\n        var getter, setter;\n        if (typeof descriptor.value === "function") {\n          if (allowMethod) {\n            target[name] = getMethod(name);\n          }\n          continue;\n        }\n        var isEvent = isEventHandlerName(name);\n        if (isEvent) getter = scope.getEventHandlerGetter(name); else getter = getGetter(name);\n        if (descriptor.writable || descriptor.set || isBrokenSafari) {\n          if (isEvent) setter = scope.getEventHandlerSetter(name); else setter = getSetter(name);\n        }\n        var configurable = isBrokenSafari || descriptor.configurable;\n        defineProperty(target, name, {\n          get: getter,\n          set: setter,\n          configurable: configurable,\n          enumerable: descriptor.enumerable\n        });\n      }\n    }\n    function register(nativeConstructor, wrapperConstructor, opt_instance) {\n      if (nativeConstructor == null) {\n        return;\n      }\n      var nativePrototype = nativeConstructor.prototype;\n      registerInternal(nativePrototype, wrapperConstructor, opt_instance);\n      mixinStatics(wrapperConstructor, nativeConstructor);\n    }\n    function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {\n      var wrapperPrototype = wrapperConstructor.prototype;\n      assert(constructorTable.get(nativePrototype) === undefined);\n      constructorTable.set(nativePrototype, wrapperConstructor);\n      nativePrototypeTable.set(wrapperPrototype, nativePrototype);\n      addForwardingProperties(nativePrototype, wrapperPrototype);\n      if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);\n      defineNonEnumerableDataProperty(wrapperPrototype, "constructor", wrapperConstructor);\n      wrapperConstructor.prototype = wrapperPrototype;\n    }\n    function isWrapperFor(wrapperConstructor, nativeConstructor) {\n      return constructorTable.get(nativeConstructor.prototype) === wrapperConstructor;\n    }\n    function registerObject(object) {\n      var nativePrototype = Object.getPrototypeOf(object);\n      var superWrapperConstructor = getWrapperConstructor(nativePrototype);\n      var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);\n      registerInternal(nativePrototype, GeneratedWrapper, object);\n      return GeneratedWrapper;\n    }\n    function createWrapperConstructor(superWrapperConstructor) {\n      function GeneratedWrapper(node) {\n        superWrapperConstructor.call(this, node);\n      }\n      var p = Object.create(superWrapperConstructor.prototype);\n      p.constructor = GeneratedWrapper;\n      GeneratedWrapper.prototype = p;\n      return GeneratedWrapper;\n    }\n    function isWrapper(object) {\n      return object && object.__impl4cf1e782hg__;\n    }\n    function isNative(object) {\n      return !isWrapper(object);\n    }\n    function wrap(impl) {\n      if (impl === null) return null;\n      assert(isNative(impl));\n      var wrapper = impl.__wrapper8e3dd93a60__;\n      if (wrapper != null) {\n        return wrapper;\n      }\n      return impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl, impl))(impl);\n    }\n    function unwrap(wrapper) {\n      if (wrapper === null) return null;\n      assert(isWrapper(wrapper));\n      return wrapper.__impl4cf1e782hg__;\n    }\n    function unsafeUnwrap(wrapper) {\n      return wrapper.__impl4cf1e782hg__;\n    }\n    function setWrapper(impl, wrapper) {\n      wrapper.__impl4cf1e782hg__ = impl;\n      impl.__wrapper8e3dd93a60__ = wrapper;\n    }\n    function unwrapIfNeeded(object) {\n      return object && isWrapper(object) ? unwrap(object) : object;\n    }\n    function wrapIfNeeded(object) {\n      return object && !isWrapper(object) ? wrap(object) : object;\n    }\n    function rewrap(node, wrapper) {\n      if (wrapper === null) return;\n      assert(isNative(node));\n      assert(wrapper === undefined || isWrapper(wrapper));\n      node.__wrapper8e3dd93a60__ = wrapper;\n    }\n    var getterDescriptor = {\n      get: undefined,\n      configurable: true,\n      enumerable: true\n    };\n    function defineGetter(constructor, name, getter) {\n      getterDescriptor.get = getter;\n      defineProperty(constructor.prototype, name, getterDescriptor);\n    }\n    function defineWrapGetter(constructor, name) {\n      defineGetter(constructor, name, function() {\n        return wrap(this.__impl4cf1e782hg__[name]);\n      });\n    }\n    function forwardMethodsToWrapper(constructors, names) {\n      constructors.forEach(function(constructor) {\n        names.forEach(function(name) {\n          constructor.prototype[name] = function() {\n            var w = wrapIfNeeded(this);\n            return w[name].apply(w, arguments);\n          };\n        });\n      });\n    }\n    scope.addForwardingProperties = addForwardingProperties;\n    scope.assert = assert;\n    scope.constructorTable = constructorTable;\n    scope.defineGetter = defineGetter;\n    scope.defineWrapGetter = defineWrapGetter;\n    scope.forwardMethodsToWrapper = forwardMethodsToWrapper;\n    scope.isIdentifierName = isIdentifierName;\n    scope.isWrapper = isWrapper;\n    scope.isWrapperFor = isWrapperFor;\n    scope.mixin = mixin;\n    scope.nativePrototypeTable = nativePrototypeTable;\n    scope.oneOf = oneOf;\n    scope.registerObject = registerObject;\n    scope.registerWrapper = register;\n    scope.rewrap = rewrap;\n    scope.setWrapper = setWrapper;\n    scope.unsafeUnwrap = unsafeUnwrap;\n    scope.unwrap = unwrap;\n    scope.unwrapIfNeeded = unwrapIfNeeded;\n    scope.wrap = wrap;\n    scope.wrapIfNeeded = wrapIfNeeded;\n    scope.wrappers = wrappers;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    function newSplice(index, removed, addedCount) {\n      return {\n        index: index,\n        removed: removed,\n        addedCount: addedCount\n      };\n    }\n    var EDIT_LEAVE = 0;\n    var EDIT_UPDATE = 1;\n    var EDIT_ADD = 2;\n    var EDIT_DELETE = 3;\n    function ArraySplice() {}\n    ArraySplice.prototype = {\n      calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n        var rowCount = oldEnd - oldStart + 1;\n        var columnCount = currentEnd - currentStart + 1;\n        var distances = new Array(rowCount);\n        for (var i = 0; i < rowCount; i++) {\n          distances[i] = new Array(columnCount);\n          distances[i][0] = i;\n        }\n        for (var j = 0; j < columnCount; j++) distances[0][j] = j;\n        for (var i = 1; i < rowCount; i++) {\n          for (var j = 1; j < columnCount; j++) {\n            if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1]; else {\n              var north = distances[i - 1][j] + 1;\n              var west = distances[i][j - 1] + 1;\n              distances[i][j] = north < west ? north : west;\n            }\n          }\n        }\n        return distances;\n      },\n      spliceOperationsFromEditDistances: function(distances) {\n        var i = distances.length - 1;\n        var j = distances[0].length - 1;\n        var current = distances[i][j];\n        var edits = [];\n        while (i > 0 || j > 0) {\n          if (i == 0) {\n            edits.push(EDIT_ADD);\n            j--;\n            continue;\n          }\n          if (j == 0) {\n            edits.push(EDIT_DELETE);\n            i--;\n            continue;\n          }\n          var northWest = distances[i - 1][j - 1];\n          var west = distances[i - 1][j];\n          var north = distances[i][j - 1];\n          var min;\n          if (west < north) min = west < northWest ? west : northWest; else min = north < northWest ? north : northWest;\n          if (min == northWest) {\n            if (northWest == current) {\n              edits.push(EDIT_LEAVE);\n            } else {\n              edits.push(EDIT_UPDATE);\n              current = northWest;\n            }\n            i--;\n            j--;\n          } else if (min == west) {\n            edits.push(EDIT_DELETE);\n            i--;\n            current = west;\n          } else {\n            edits.push(EDIT_ADD);\n            j--;\n            current = north;\n          }\n        }\n        edits.reverse();\n        return edits;\n      },\n      calcSplices: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n        var prefixCount = 0;\n        var suffixCount = 0;\n        var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n        if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);\n        if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n        currentStart += prefixCount;\n        oldStart += prefixCount;\n        currentEnd -= suffixCount;\n        oldEnd -= suffixCount;\n        if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n        if (currentStart == currentEnd) {\n          var splice = newSplice(currentStart, [], 0);\n          while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);\n          return [ splice ];\n        } else if (oldStart == oldEnd) return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n        var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n        var splice = undefined;\n        var splices = [];\n        var index = currentStart;\n        var oldIndex = oldStart;\n        for (var i = 0; i < ops.length; i++) {\n          switch (ops[i]) {\n           case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n            index++;\n            oldIndex++;\n            break;\n\n           case EDIT_UPDATE:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.addedCount++;\n            index++;\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n\n           case EDIT_ADD:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.addedCount++;\n            index++;\n            break;\n\n           case EDIT_DELETE:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          }\n        }\n        if (splice) {\n          splices.push(splice);\n        }\n        return splices;\n      },\n      sharedPrefix: function(current, old, searchLength) {\n        for (var i = 0; i < searchLength; i++) if (!this.equals(current[i], old[i])) return i;\n        return searchLength;\n      },\n      sharedSuffix: function(current, old, searchLength) {\n        var index1 = current.length;\n        var index2 = old.length;\n        var count = 0;\n        while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;\n        return count;\n      },\n      calculateSplices: function(current, previous) {\n        return this.calcSplices(current, 0, current.length, previous, 0, previous.length);\n      },\n      equals: function(currentValue, previousValue) {\n        return currentValue === previousValue;\n      }\n    };\n    scope.ArraySplice = ArraySplice;\n  })(window.ShadowDOMPolyfill);\n  (function(context) {\n    "use strict";\n    var OriginalMutationObserver = window.MutationObserver;\n    var callbacks = [];\n    var pending = false;\n    var timerFunc;\n    function handle() {\n      pending = false;\n      var copies = callbacks.slice(0);\n      callbacks = [];\n      for (var i = 0; i < copies.length; i++) {\n        (0, copies[i])();\n      }\n    }\n    if (OriginalMutationObserver) {\n      var counter = 1;\n      var observer = new OriginalMutationObserver(handle);\n      var textNode = document.createTextNode(counter);\n      observer.observe(textNode, {\n        characterData: true\n      });\n      timerFunc = function() {\n        counter = (counter + 1) % 2;\n        textNode.data = counter;\n      };\n    } else {\n      timerFunc = window.setTimeout;\n    }\n    function setEndOfMicrotask(func) {\n      callbacks.push(func);\n      if (pending) return;\n      pending = true;\n      timerFunc(handle, 0);\n    }\n    context.setEndOfMicrotask = setEndOfMicrotask;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var setEndOfMicrotask = scope.setEndOfMicrotask;\n    var wrapIfNeeded = scope.wrapIfNeeded;\n    var wrappers = scope.wrappers;\n    var registrationsTable = new WeakMap();\n    var globalMutationObservers = [];\n    var isScheduled = false;\n    function scheduleCallback(observer) {\n      if (observer.scheduled_) return;\n      observer.scheduled_ = true;\n      globalMutationObservers.push(observer);\n      if (isScheduled) return;\n      setEndOfMicrotask(notifyObservers);\n      isScheduled = true;\n    }\n    function notifyObservers() {\n      isScheduled = false;\n      while (globalMutationObservers.length) {\n        var notifyList = globalMutationObservers;\n        globalMutationObservers = [];\n        notifyList.sort(function(x, y) {\n          return x.uid_ - y.uid_;\n        });\n        for (var i = 0; i < notifyList.length; i++) {\n          var mo = notifyList[i];\n          mo.scheduled_ = false;\n          var queue = mo.takeRecords();\n          removeTransientObserversFor(mo);\n          if (queue.length) {\n            mo.callback_(queue, mo);\n          }\n        }\n      }\n    }\n    function MutationRecord(type, target) {\n      this.type = type;\n      this.target = target;\n      this.addedNodes = new wrappers.NodeList();\n      this.removedNodes = new wrappers.NodeList();\n      this.previousSibling = null;\n      this.nextSibling = null;\n      this.attributeName = null;\n      this.attributeNamespace = null;\n      this.oldValue = null;\n    }\n    function registerTransientObservers(ancestor, node) {\n      for (;ancestor; ancestor = ancestor.parentNode) {\n        var registrations = registrationsTable.get(ancestor);\n        if (!registrations) continue;\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.options.subtree) registration.addTransientObserver(node);\n        }\n      }\n    }\n    function removeTransientObserversFor(observer) {\n      for (var i = 0; i < observer.nodes_.length; i++) {\n        var node = observer.nodes_[i];\n        var registrations = registrationsTable.get(node);\n        if (!registrations) return;\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          if (registration.observer === observer) registration.removeTransientObservers();\n        }\n      }\n    }\n    function enqueueMutation(target, type, data) {\n      var interestedObservers = Object.create(null);\n      var associatedStrings = Object.create(null);\n      for (var node = target; node; node = node.parentNode) {\n        var registrations = registrationsTable.get(node);\n        if (!registrations) continue;\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n          if (node !== target && !options.subtree) continue;\n          if (type === "attributes" && !options.attributes) continue;\n          if (type === "attributes" && options.attributeFilter && (data.namespace !== null || options.attributeFilter.indexOf(data.name) === -1)) {\n            continue;\n          }\n          if (type === "characterData" && !options.characterData) continue;\n          if (type === "childList" && !options.childList) continue;\n          var observer = registration.observer;\n          interestedObservers[observer.uid_] = observer;\n          if (type === "attributes" && options.attributeOldValue || type === "characterData" && options.characterDataOldValue) {\n            associatedStrings[observer.uid_] = data.oldValue;\n          }\n        }\n      }\n      for (var uid in interestedObservers) {\n        var observer = interestedObservers[uid];\n        var record = new MutationRecord(type, target);\n        if ("name" in data && "namespace" in data) {\n          record.attributeName = data.name;\n          record.attributeNamespace = data.namespace;\n        }\n        if (data.addedNodes) record.addedNodes = data.addedNodes;\n        if (data.removedNodes) record.removedNodes = data.removedNodes;\n        if (data.previousSibling) record.previousSibling = data.previousSibling;\n        if (data.nextSibling) record.nextSibling = data.nextSibling;\n        if (associatedStrings[uid] !== undefined) record.oldValue = associatedStrings[uid];\n        scheduleCallback(observer);\n        observer.records_.push(record);\n      }\n    }\n    var slice = Array.prototype.slice;\n    function MutationObserverOptions(options) {\n      this.childList = !!options.childList;\n      this.subtree = !!options.subtree;\n      if (!("attributes" in options) && ("attributeOldValue" in options || "attributeFilter" in options)) {\n        this.attributes = true;\n      } else {\n        this.attributes = !!options.attributes;\n      }\n      if ("characterDataOldValue" in options && !("characterData" in options)) this.characterData = true; else this.characterData = !!options.characterData;\n      if (!this.attributes && (options.attributeOldValue || "attributeFilter" in options) || !this.characterData && options.characterDataOldValue) {\n        throw new TypeError();\n      }\n      this.characterData = !!options.characterData;\n      this.attributeOldValue = !!options.attributeOldValue;\n      this.characterDataOldValue = !!options.characterDataOldValue;\n      if ("attributeFilter" in options) {\n        if (options.attributeFilter == null || typeof options.attributeFilter !== "object") {\n          throw new TypeError();\n        }\n        this.attributeFilter = slice.call(options.attributeFilter);\n      } else {\n        this.attributeFilter = null;\n      }\n    }\n    var uidCounter = 0;\n    function MutationObserver(callback) {\n      this.callback_ = callback;\n      this.nodes_ = [];\n      this.records_ = [];\n      this.uid_ = ++uidCounter;\n      this.scheduled_ = false;\n    }\n    MutationObserver.prototype = {\n      constructor: MutationObserver,\n      observe: function(target, options) {\n        target = wrapIfNeeded(target);\n        var newOptions = new MutationObserverOptions(options);\n        var registration;\n        var registrations = registrationsTable.get(target);\n        if (!registrations) registrationsTable.set(target, registrations = []);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i].observer === this) {\n            registration = registrations[i];\n            registration.removeTransientObservers();\n            registration.options = newOptions;\n          }\n        }\n        if (!registration) {\n          registration = new Registration(this, target, newOptions);\n          registrations.push(registration);\n          this.nodes_.push(target);\n        }\n      },\n      disconnect: function() {\n        this.nodes_.forEach(function(node) {\n          var registrations = registrationsTable.get(node);\n          for (var i = 0; i < registrations.length; i++) {\n            var registration = registrations[i];\n            if (registration.observer === this) {\n              registrations.splice(i, 1);\n              break;\n            }\n          }\n        }, this);\n        this.records_ = [];\n      },\n      takeRecords: function() {\n        var copyOfRecords = this.records_;\n        this.records_ = [];\n        return copyOfRecords;\n      }\n    };\n    function Registration(observer, target, options) {\n      this.observer = observer;\n      this.target = target;\n      this.options = options;\n      this.transientObservedNodes = [];\n    }\n    Registration.prototype = {\n      addTransientObserver: function(node) {\n        if (node === this.target) return;\n        scheduleCallback(this.observer);\n        this.transientObservedNodes.push(node);\n        var registrations = registrationsTable.get(node);\n        if (!registrations) registrationsTable.set(node, registrations = []);\n        registrations.push(this);\n      },\n      removeTransientObservers: function() {\n        var transientObservedNodes = this.transientObservedNodes;\n        this.transientObservedNodes = [];\n        for (var i = 0; i < transientObservedNodes.length; i++) {\n          var node = transientObservedNodes[i];\n          var registrations = registrationsTable.get(node);\n          for (var j = 0; j < registrations.length; j++) {\n            if (registrations[j] === this) {\n              registrations.splice(j, 1);\n              break;\n            }\n          }\n        }\n      }\n    };\n    scope.enqueueMutation = enqueueMutation;\n    scope.registerTransientObservers = registerTransientObservers;\n    scope.wrappers.MutationObserver = MutationObserver;\n    scope.wrappers.MutationRecord = MutationRecord;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    function TreeScope(root, parent) {\n      this.root = root;\n      this.parent = parent;\n    }\n    TreeScope.prototype = {\n      get renderer() {\n        if (this.root instanceof scope.wrappers.ShadowRoot) {\n          return scope.getRendererForHost(this.root.host);\n        }\n        return null;\n      },\n      contains: function(treeScope) {\n        for (;treeScope; treeScope = treeScope.parent) {\n          if (treeScope === this) return true;\n        }\n        return false;\n      }\n    };\n    function setTreeScope(node, treeScope) {\n      if (node.treeScope_ !== treeScope) {\n        node.treeScope_ = treeScope;\n        for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {\n          sr.treeScope_.parent = treeScope;\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          setTreeScope(child, treeScope);\n        }\n      }\n    }\n    function getTreeScope(node) {\n      if (node instanceof scope.wrappers.Window) {\n        debugger;\n      }\n      if (node.treeScope_) return node.treeScope_;\n      var parent = node.parentNode;\n      var treeScope;\n      if (parent) treeScope = getTreeScope(parent); else treeScope = new TreeScope(node, null);\n      return node.treeScope_ = treeScope;\n    }\n    scope.TreeScope = TreeScope;\n    scope.getTreeScope = getTreeScope;\n    scope.setTreeScope = setTreeScope;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrappers = scope.wrappers;\n    var wrappedFuns = new WeakMap();\n    var listenersTable = new WeakMap();\n    var handledEventsTable = new WeakMap();\n    var currentlyDispatchingEvents = new WeakMap();\n    var targetTable = new WeakMap();\n    var currentTargetTable = new WeakMap();\n    var relatedTargetTable = new WeakMap();\n    var eventPhaseTable = new WeakMap();\n    var stopPropagationTable = new WeakMap();\n    var stopImmediatePropagationTable = new WeakMap();\n    var eventHandlersTable = new WeakMap();\n    var eventPathTable = new WeakMap();\n    function isShadowRoot(node) {\n      return node instanceof wrappers.ShadowRoot;\n    }\n    function rootOfNode(node) {\n      return getTreeScope(node).root;\n    }\n    function getEventPath(node, event) {\n      var path = [];\n      var current = node;\n      path.push(current);\n      while (current) {\n        var destinationInsertionPoints = getDestinationInsertionPoints(current);\n        if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {\n          for (var i = 0; i < destinationInsertionPoints.length; i++) {\n            var insertionPoint = destinationInsertionPoints[i];\n            if (isShadowInsertionPoint(insertionPoint)) {\n              var shadowRoot = rootOfNode(insertionPoint);\n              var olderShadowRoot = shadowRoot.olderShadowRoot;\n              if (olderShadowRoot) path.push(olderShadowRoot);\n            }\n            path.push(insertionPoint);\n          }\n          current = destinationInsertionPoints[destinationInsertionPoints.length - 1];\n        } else {\n          if (isShadowRoot(current)) {\n            if (inSameTree(node, current) && eventMustBeStopped(event)) {\n              break;\n            }\n            current = current.host;\n            path.push(current);\n          } else {\n            current = current.parentNode;\n            if (current) path.push(current);\n          }\n        }\n      }\n      return path;\n    }\n    function eventMustBeStopped(event) {\n      if (!event) return false;\n      switch (event.type) {\n       case "abort":\n       case "error":\n       case "select":\n       case "change":\n       case "load":\n       case "reset":\n       case "resize":\n       case "scroll":\n       case "selectstart":\n        return true;\n      }\n      return false;\n    }\n    function isShadowInsertionPoint(node) {\n      return node instanceof HTMLShadowElement;\n    }\n    function getDestinationInsertionPoints(node) {\n      return scope.getDestinationInsertionPoints(node);\n    }\n    function eventRetargetting(path, currentTarget) {\n      if (path.length === 0) return currentTarget;\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n      var currentTargetTree = getTreeScope(currentTarget);\n      var originalTarget = path[0];\n      var originalTargetTree = getTreeScope(originalTarget);\n      var relativeTargetTree = lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);\n      for (var i = 0; i < path.length; i++) {\n        var node = path[i];\n        if (getTreeScope(node) === relativeTargetTree) return node;\n      }\n      return path[path.length - 1];\n    }\n    function getTreeScopeAncestors(treeScope) {\n      var ancestors = [];\n      for (;treeScope; treeScope = treeScope.parent) {\n        ancestors.push(treeScope);\n      }\n      return ancestors;\n    }\n    function lowestCommonInclusiveAncestor(tsA, tsB) {\n      var ancestorsA = getTreeScopeAncestors(tsA);\n      var ancestorsB = getTreeScopeAncestors(tsB);\n      var result = null;\n      while (ancestorsA.length > 0 && ancestorsB.length > 0) {\n        var a = ancestorsA.pop();\n        var b = ancestorsB.pop();\n        if (a === b) result = a; else break;\n      }\n      return result;\n    }\n    function getTreeScopeRoot(ts) {\n      if (!ts.parent) return ts;\n      return getTreeScopeRoot(ts.parent);\n    }\n    function relatedTargetResolution(event, currentTarget, relatedTarget) {\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n      var currentTargetTree = getTreeScope(currentTarget);\n      var relatedTargetTree = getTreeScope(relatedTarget);\n      var relatedTargetEventPath = getEventPath(relatedTarget, event);\n      var lowestCommonAncestorTree;\n      var lowestCommonAncestorTree = lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);\n      if (!lowestCommonAncestorTree) lowestCommonAncestorTree = relatedTargetTree.root;\n      for (var commonAncestorTree = lowestCommonAncestorTree; commonAncestorTree; commonAncestorTree = commonAncestorTree.parent) {\n        var adjustedRelatedTarget;\n        for (var i = 0; i < relatedTargetEventPath.length; i++) {\n          var node = relatedTargetEventPath[i];\n          if (getTreeScope(node) === commonAncestorTree) return node;\n        }\n      }\n      return null;\n    }\n    function inSameTree(a, b) {\n      return getTreeScope(a) === getTreeScope(b);\n    }\n    var NONE = 0;\n    var CAPTURING_PHASE = 1;\n    var AT_TARGET = 2;\n    var BUBBLING_PHASE = 3;\n    var pendingError;\n    function dispatchOriginalEvent(originalEvent) {\n      if (handledEventsTable.get(originalEvent)) return;\n      handledEventsTable.set(originalEvent, true);\n      dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));\n      if (pendingError) {\n        var err = pendingError;\n        pendingError = null;\n        throw err;\n      }\n    }\n    function isLoadLikeEvent(event) {\n      switch (event.type) {\n       case "load":\n       case "beforeunload":\n       case "unload":\n        return true;\n      }\n      return false;\n    }\n    function dispatchEvent(event, originalWrapperTarget) {\n      if (currentlyDispatchingEvents.get(event)) throw new Error("InvalidStateError");\n      currentlyDispatchingEvents.set(event, true);\n      scope.renderAllPending();\n      var eventPath;\n      var overrideTarget;\n      var win;\n      if (isLoadLikeEvent(event) && !event.bubbles) {\n        var doc = originalWrapperTarget;\n        if (doc instanceof wrappers.Document && (win = doc.defaultView)) {\n          overrideTarget = doc;\n          eventPath = [];\n        }\n      }\n      if (!eventPath) {\n        if (originalWrapperTarget instanceof wrappers.Window) {\n          win = originalWrapperTarget;\n          eventPath = [];\n        } else {\n          eventPath = getEventPath(originalWrapperTarget, event);\n          if (!isLoadLikeEvent(event)) {\n            var doc = eventPath[eventPath.length - 1];\n            if (doc instanceof wrappers.Document) win = doc.defaultView;\n          }\n        }\n      }\n      eventPathTable.set(event, eventPath);\n      if (dispatchCapturing(event, eventPath, win, overrideTarget)) {\n        if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {\n          dispatchBubbling(event, eventPath, win, overrideTarget);\n        }\n      }\n      eventPhaseTable.set(event, NONE);\n      currentTargetTable.delete(event, null);\n      currentlyDispatchingEvents.delete(event);\n      return event.defaultPrevented;\n    }\n    function dispatchCapturing(event, eventPath, win, overrideTarget) {\n      var phase = CAPTURING_PHASE;\n      if (win) {\n        if (!invoke(win, event, phase, eventPath, overrideTarget)) return false;\n      }\n      for (var i = eventPath.length - 1; i > 0; i--) {\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return false;\n      }\n      return true;\n    }\n    function dispatchAtTarget(event, eventPath, win, overrideTarget) {\n      var phase = AT_TARGET;\n      var currentTarget = eventPath[0] || win;\n      return invoke(currentTarget, event, phase, eventPath, overrideTarget);\n    }\n    function dispatchBubbling(event, eventPath, win, overrideTarget) {\n      var phase = BUBBLING_PHASE;\n      for (var i = 1; i < eventPath.length; i++) {\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return;\n      }\n      if (win && eventPath.length > 0) {\n        invoke(win, event, phase, eventPath, overrideTarget);\n      }\n    }\n    function invoke(currentTarget, event, phase, eventPath, overrideTarget) {\n      var listeners = listenersTable.get(currentTarget);\n      if (!listeners) return true;\n      var target = overrideTarget || eventRetargetting(eventPath, currentTarget);\n      if (target === currentTarget) {\n        if (phase === CAPTURING_PHASE) return true;\n        if (phase === BUBBLING_PHASE) phase = AT_TARGET;\n      } else if (phase === BUBBLING_PHASE && !event.bubbles) {\n        return true;\n      }\n      if ("relatedTarget" in event) {\n        var originalEvent = unwrap(event);\n        var unwrappedRelatedTarget = originalEvent.relatedTarget;\n        if (unwrappedRelatedTarget) {\n          if (unwrappedRelatedTarget instanceof Object && unwrappedRelatedTarget.addEventListener) {\n            var relatedTarget = wrap(unwrappedRelatedTarget);\n            var adjusted = relatedTargetResolution(event, currentTarget, relatedTarget);\n            if (adjusted === target) return true;\n          } else {\n            adjusted = null;\n          }\n          relatedTargetTable.set(event, adjusted);\n        }\n      }\n      eventPhaseTable.set(event, phase);\n      var type = event.type;\n      var anyRemoved = false;\n      targetTable.set(event, target);\n      currentTargetTable.set(event, currentTarget);\n      listeners.depth++;\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        var listener = listeners[i];\n        if (listener.removed) {\n          anyRemoved = true;\n          continue;\n        }\n        if (listener.type !== type || !listener.capture && phase === CAPTURING_PHASE || listener.capture && phase === BUBBLING_PHASE) {\n          continue;\n        }\n        try {\n          if (typeof listener.handler === "function") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);\n          if (stopImmediatePropagationTable.get(event)) return false;\n        } catch (ex) {\n          if (!pendingError) pendingError = ex;\n        }\n      }\n      listeners.depth--;\n      if (anyRemoved && listeners.depth === 0) {\n        var copy = listeners.slice();\n        listeners.length = 0;\n        for (var i = 0; i < copy.length; i++) {\n          if (!copy[i].removed) listeners.push(copy[i]);\n        }\n      }\n      return !stopPropagationTable.get(event);\n    }\n    function Listener(type, handler, capture) {\n      this.type = type;\n      this.handler = handler;\n      this.capture = Boolean(capture);\n    }\n    Listener.prototype = {\n      equals: function(that) {\n        return this.handler === that.handler && this.type === that.type && this.capture === that.capture;\n      },\n      get removed() {\n        return this.handler === null;\n      },\n      remove: function() {\n        this.handler = null;\n      }\n    };\n    var OriginalEvent = window.Event;\n    OriginalEvent.prototype.polymerBlackList_ = {\n      returnValue: true,\n      keyLocation: true\n    };\n    function Event(type, options) {\n      if (type instanceof OriginalEvent) {\n        var impl = type;\n        if (!OriginalBeforeUnloadEvent && impl.type === "beforeunload" && !(this instanceof BeforeUnloadEvent)) {\n          return new BeforeUnloadEvent(impl);\n        }\n        setWrapper(impl, this);\n      } else {\n        return wrap(constructEvent(OriginalEvent, "Event", type, options));\n      }\n    }\n    Event.prototype = {\n      get target() {\n        return targetTable.get(this);\n      },\n      get currentTarget() {\n        return currentTargetTable.get(this);\n      },\n      get eventPhase() {\n        return eventPhaseTable.get(this);\n      },\n      get path() {\n        var eventPath = eventPathTable.get(this);\n        if (!eventPath) return [];\n        return eventPath.slice();\n      },\n      stopPropagation: function() {\n        stopPropagationTable.set(this, true);\n      },\n      stopImmediatePropagation: function() {\n        stopPropagationTable.set(this, true);\n        stopImmediatePropagationTable.set(this, true);\n      }\n    };\n    var supportsDefaultPrevented = function() {\n      var e = document.createEvent("Event");\n      e.initEvent("test", true, true);\n      e.preventDefault();\n      return e.defaultPrevented;\n    }();\n    if (!supportsDefaultPrevented) {\n      Event.prototype.preventDefault = function() {\n        if (!this.cancelable) return;\n        unsafeUnwrap(this).preventDefault();\n        Object.defineProperty(this, "defaultPrevented", {\n          get: function() {\n            return true;\n          },\n          configurable: true\n        });\n      };\n    }\n    registerWrapper(OriginalEvent, Event, document.createEvent("Event"));\n    function unwrapOptions(options) {\n      if (!options || !options.relatedTarget) return options;\n      return Object.create(options, {\n        relatedTarget: {\n          value: unwrap(options.relatedTarget)\n        }\n      });\n    }\n    function registerGenericEvent(name, SuperEvent, prototype) {\n      var OriginalEvent = window[name];\n      var GenericEvent = function(type, options) {\n        if (type instanceof OriginalEvent) setWrapper(type, this); else return wrap(constructEvent(OriginalEvent, name, type, options));\n      };\n      GenericEvent.prototype = Object.create(SuperEvent.prototype);\n      if (prototype) mixin(GenericEvent.prototype, prototype);\n      if (OriginalEvent) {\n        try {\n          registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent("temp"));\n        } catch (ex) {\n          registerWrapper(OriginalEvent, GenericEvent, document.createEvent(name));\n        }\n      }\n      return GenericEvent;\n    }\n    var UIEvent = registerGenericEvent("UIEvent", Event);\n    var CustomEvent = registerGenericEvent("CustomEvent", Event);\n    var relatedTargetProto = {\n      get relatedTarget() {\n        var relatedTarget = relatedTargetTable.get(this);\n        if (relatedTarget !== undefined) return relatedTarget;\n        return wrap(unwrap(this).relatedTarget);\n      }\n    };\n    function getInitFunction(name, relatedTargetIndex) {\n      return function() {\n        arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);\n        var impl = unwrap(this);\n        impl[name].apply(impl, arguments);\n      };\n    }\n    var mouseEventProto = mixin({\n      initMouseEvent: getInitFunction("initMouseEvent", 14)\n    }, relatedTargetProto);\n    var focusEventProto = mixin({\n      initFocusEvent: getInitFunction("initFocusEvent", 5)\n    }, relatedTargetProto);\n    var MouseEvent = registerGenericEvent("MouseEvent", UIEvent, mouseEventProto);\n    var FocusEvent = registerGenericEvent("FocusEvent", UIEvent, focusEventProto);\n    var defaultInitDicts = Object.create(null);\n    var supportsEventConstructors = function() {\n      try {\n        new window.FocusEvent("focus");\n      } catch (ex) {\n        return false;\n      }\n      return true;\n    }();\n    function constructEvent(OriginalEvent, name, type, options) {\n      if (supportsEventConstructors) return new OriginalEvent(type, unwrapOptions(options));\n      var event = unwrap(document.createEvent(name));\n      var defaultDict = defaultInitDicts[name];\n      var args = [ type ];\n      Object.keys(defaultDict).forEach(function(key) {\n        var v = options != null && key in options ? options[key] : defaultDict[key];\n        if (key === "relatedTarget") v = unwrap(v);\n        args.push(v);\n      });\n      event["init" + name].apply(event, args);\n      return event;\n    }\n    if (!supportsEventConstructors) {\n      var configureEventConstructor = function(name, initDict, superName) {\n        if (superName) {\n          var superDict = defaultInitDicts[superName];\n          initDict = mixin(mixin({}, superDict), initDict);\n        }\n        defaultInitDicts[name] = initDict;\n      };\n      configureEventConstructor("Event", {\n        bubbles: false,\n        cancelable: false\n      });\n      configureEventConstructor("CustomEvent", {\n        detail: null\n      }, "Event");\n      configureEventConstructor("UIEvent", {\n        view: null,\n        detail: 0\n      }, "Event");\n      configureEventConstructor("MouseEvent", {\n        screenX: 0,\n        screenY: 0,\n        clientX: 0,\n        clientY: 0,\n        ctrlKey: false,\n        altKey: false,\n        shiftKey: false,\n        metaKey: false,\n        button: 0,\n        relatedTarget: null\n      }, "UIEvent");\n      configureEventConstructor("FocusEvent", {\n        relatedTarget: null\n      }, "UIEvent");\n    }\n    var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;\n    function BeforeUnloadEvent(impl) {\n      Event.call(this, impl);\n    }\n    BeforeUnloadEvent.prototype = Object.create(Event.prototype);\n    mixin(BeforeUnloadEvent.prototype, {\n      get returnValue() {\n        return unsafeUnwrap(this).returnValue;\n      },\n      set returnValue(v) {\n        unsafeUnwrap(this).returnValue = v;\n      }\n    });\n    if (OriginalBeforeUnloadEvent) registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);\n    function isValidListener(fun) {\n      if (typeof fun === "function") return true;\n      return fun && fun.handleEvent;\n    }\n    function isMutationEvent(type) {\n      switch (type) {\n       case "DOMAttrModified":\n       case "DOMAttributeNameChanged":\n       case "DOMCharacterDataModified":\n       case "DOMElementNameChanged":\n       case "DOMNodeInserted":\n       case "DOMNodeInsertedIntoDocument":\n       case "DOMNodeRemoved":\n       case "DOMNodeRemovedFromDocument":\n       case "DOMSubtreeModified":\n        return true;\n      }\n      return false;\n    }\n    var OriginalEventTarget = window.EventTarget;\n    function EventTarget(impl) {\n      setWrapper(impl, this);\n    }\n    var methodNames = [ "addEventListener", "removeEventListener", "dispatchEvent" ];\n    [ Node, Window ].forEach(function(constructor) {\n      var p = constructor.prototype;\n      methodNames.forEach(function(name) {\n        Object.defineProperty(p, name + "_", {\n          value: p[name]\n        });\n      });\n    });\n    function getTargetToListenAt(wrapper) {\n      if (wrapper instanceof wrappers.ShadowRoot) wrapper = wrapper.host;\n      return unwrap(wrapper);\n    }\n    EventTarget.prototype = {\n      addEventListener: function(type, fun, capture) {\n        if (!isValidListener(fun) || isMutationEvent(type)) return;\n        var listener = new Listener(type, fun, capture);\n        var listeners = listenersTable.get(this);\n        if (!listeners) {\n          listeners = [];\n          listeners.depth = 0;\n          listenersTable.set(this, listeners);\n        } else {\n          for (var i = 0; i < listeners.length; i++) {\n            if (listener.equals(listeners[i])) return;\n          }\n        }\n        listeners.push(listener);\n        var target = getTargetToListenAt(this);\n        target.addEventListener_(type, dispatchOriginalEvent, true);\n      },\n      removeEventListener: function(type, fun, capture) {\n        capture = Boolean(capture);\n        var listeners = listenersTable.get(this);\n        if (!listeners) return;\n        var count = 0, found = false;\n        for (var i = 0; i < listeners.length; i++) {\n          if (listeners[i].type === type && listeners[i].capture === capture) {\n            count++;\n            if (listeners[i].handler === fun) {\n              found = true;\n              listeners[i].remove();\n            }\n          }\n        }\n        if (found && count === 1) {\n          var target = getTargetToListenAt(this);\n          target.removeEventListener_(type, dispatchOriginalEvent, true);\n        }\n      },\n      dispatchEvent: function(event) {\n        var nativeEvent = unwrap(event);\n        var eventType = nativeEvent.type;\n        handledEventsTable.set(nativeEvent, false);\n        scope.renderAllPending();\n        var tempListener;\n        if (!hasListenerInAncestors(this, eventType)) {\n          tempListener = function() {};\n          this.addEventListener(eventType, tempListener, true);\n        }\n        try {\n          return unwrap(this).dispatchEvent_(nativeEvent);\n        } finally {\n          if (tempListener) this.removeEventListener(eventType, tempListener, true);\n        }\n      }\n    };\n    function hasListener(node, type) {\n      var listeners = listenersTable.get(node);\n      if (listeners) {\n        for (var i = 0; i < listeners.length; i++) {\n          if (!listeners[i].removed && listeners[i].type === type) return true;\n        }\n      }\n      return false;\n    }\n    function hasListenerInAncestors(target, type) {\n      for (var node = unwrap(target); node; node = node.parentNode) {\n        if (hasListener(wrap(node), type)) return true;\n      }\n      return false;\n    }\n    if (OriginalEventTarget) registerWrapper(OriginalEventTarget, EventTarget);\n    function wrapEventTargetMethods(constructors) {\n      forwardMethodsToWrapper(constructors, methodNames);\n    }\n    var originalElementFromPoint = document.elementFromPoint;\n    function elementFromPoint(self, document, x, y) {\n      scope.renderAllPending();\n      var element = wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));\n      if (!element) return null;\n      var path = getEventPath(element, null);\n      var idx = path.lastIndexOf(self);\n      if (idx == -1) return null; else path = path.slice(0, idx);\n      return eventRetargetting(path, self);\n    }\n    function getEventHandlerGetter(name) {\n      return function() {\n        var inlineEventHandlers = eventHandlersTable.get(this);\n        return inlineEventHandlers && inlineEventHandlers[name] && inlineEventHandlers[name].value || null;\n      };\n    }\n    function getEventHandlerSetter(name) {\n      var eventType = name.slice(2);\n      return function(value) {\n        var inlineEventHandlers = eventHandlersTable.get(this);\n        if (!inlineEventHandlers) {\n          inlineEventHandlers = Object.create(null);\n          eventHandlersTable.set(this, inlineEventHandlers);\n        }\n        var old = inlineEventHandlers[name];\n        if (old) this.removeEventListener(eventType, old.wrapped, false);\n        if (typeof value === "function") {\n          var wrapped = function(e) {\n            var rv = value.call(this, e);\n            if (rv === false) e.preventDefault(); else if (name === "onbeforeunload" && typeof rv === "string") e.returnValue = rv;\n          };\n          this.addEventListener(eventType, wrapped, false);\n          inlineEventHandlers[name] = {\n            value: value,\n            wrapped: wrapped\n          };\n        }\n      };\n    }\n    scope.elementFromPoint = elementFromPoint;\n    scope.getEventHandlerGetter = getEventHandlerGetter;\n    scope.getEventHandlerSetter = getEventHandlerSetter;\n    scope.wrapEventTargetMethods = wrapEventTargetMethods;\n    scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;\n    scope.wrappers.CustomEvent = CustomEvent;\n    scope.wrappers.Event = Event;\n    scope.wrappers.EventTarget = EventTarget;\n    scope.wrappers.FocusEvent = FocusEvent;\n    scope.wrappers.MouseEvent = MouseEvent;\n    scope.wrappers.UIEvent = UIEvent;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var UIEvent = scope.wrappers.UIEvent;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalTouchEvent = window.TouchEvent;\n    if (!OriginalTouchEvent) return;\n    var nativeEvent;\n    try {\n      nativeEvent = document.createEvent("TouchEvent");\n    } catch (ex) {\n      return;\n    }\n    var nonEnumDescriptor = {\n      enumerable: false\n    };\n    function nonEnum(obj, prop) {\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\n    }\n    function Touch(impl) {\n      setWrapper(impl, this);\n    }\n    Touch.prototype = {\n      get target() {\n        return wrap(unsafeUnwrap(this).target);\n      }\n    };\n    var descr = {\n      configurable: true,\n      enumerable: true,\n      get: null\n    };\n    [ "clientX", "clientY", "screenX", "screenY", "pageX", "pageY", "identifier", "webkitRadiusX", "webkitRadiusY", "webkitRotationAngle", "webkitForce" ].forEach(function(name) {\n      descr.get = function() {\n        return unsafeUnwrap(this)[name];\n      };\n      Object.defineProperty(Touch.prototype, name, descr);\n    });\n    function TouchList() {\n      this.length = 0;\n      nonEnum(this, "length");\n    }\n    TouchList.prototype = {\n      item: function(index) {\n        return this[index];\n      }\n    };\n    function wrapTouchList(nativeTouchList) {\n      var list = new TouchList();\n      for (var i = 0; i < nativeTouchList.length; i++) {\n        list[i] = new Touch(nativeTouchList[i]);\n      }\n      list.length = i;\n      return list;\n    }\n    function TouchEvent(impl) {\n      UIEvent.call(this, impl);\n    }\n    TouchEvent.prototype = Object.create(UIEvent.prototype);\n    mixin(TouchEvent.prototype, {\n      get touches() {\n        return wrapTouchList(unsafeUnwrap(this).touches);\n      },\n      get targetTouches() {\n        return wrapTouchList(unsafeUnwrap(this).targetTouches);\n      },\n      get changedTouches() {\n        return wrapTouchList(unsafeUnwrap(this).changedTouches);\n      },\n      initTouchEvent: function() {\n        throw new Error("Not implemented");\n      }\n    });\n    registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);\n    scope.wrappers.Touch = Touch;\n    scope.wrappers.TouchEvent = TouchEvent;\n    scope.wrappers.TouchList = TouchList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var nonEnumDescriptor = {\n      enumerable: false\n    };\n    function nonEnum(obj, prop) {\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\n    }\n    function NodeList() {\n      this.length = 0;\n      nonEnum(this, "length");\n    }\n    NodeList.prototype = {\n      item: function(index) {\n        return this[index];\n      }\n    };\n    nonEnum(NodeList.prototype, "item");\n    function wrapNodeList(list) {\n      if (list == null) return list;\n      var wrapperList = new NodeList();\n      for (var i = 0, length = list.length; i < length; i++) {\n        wrapperList[i] = wrap(list[i]);\n      }\n      wrapperList.length = length;\n      return wrapperList;\n    }\n    function addWrapNodeListMethod(wrapperConstructor, name) {\n      wrapperConstructor.prototype[name] = function() {\n        return wrapNodeList(unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    scope.wrappers.NodeList = NodeList;\n    scope.addWrapNodeListMethod = addWrapNodeListMethod;\n    scope.wrapNodeList = wrapNodeList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    scope.wrapHTMLCollection = scope.wrapNodeList;\n    scope.wrappers.HTMLCollection = scope.wrappers.NodeList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var EventTarget = scope.wrappers.EventTarget;\n    var NodeList = scope.wrappers.NodeList;\n    var TreeScope = scope.TreeScope;\n    var assert = scope.assert;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var enqueueMutation = scope.enqueueMutation;\n    var getTreeScope = scope.getTreeScope;\n    var isWrapper = scope.isWrapper;\n    var mixin = scope.mixin;\n    var registerTransientObservers = scope.registerTransientObservers;\n    var registerWrapper = scope.registerWrapper;\n    var setTreeScope = scope.setTreeScope;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var wrapIfNeeded = scope.wrapIfNeeded;\n    var wrappers = scope.wrappers;\n    function assertIsNodeWrapper(node) {\n      assert(node instanceof Node);\n    }\n    function createOneElementNodeList(node) {\n      var nodes = new NodeList();\n      nodes[0] = node;\n      nodes.length = 1;\n      return nodes;\n    }\n    var surpressMutations = false;\n    function enqueueRemovalForInsertedNodes(node, parent, nodes) {\n      enqueueMutation(parent, "childList", {\n        removedNodes: nodes,\n        previousSibling: node.previousSibling,\n        nextSibling: node.nextSibling\n      });\n    }\n    function enqueueRemovalForInsertedDocumentFragment(df, nodes) {\n      enqueueMutation(df, "childList", {\n        removedNodes: nodes\n      });\n    }\n    function collectNodes(node, parentNode, previousNode, nextNode) {\n      if (node instanceof DocumentFragment) {\n        var nodes = collectNodesForDocumentFragment(node);\n        surpressMutations = true;\n        for (var i = nodes.length - 1; i >= 0; i--) {\n          node.removeChild(nodes[i]);\n          nodes[i].parentNode_ = parentNode;\n        }\n        surpressMutations = false;\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].previousSibling_ = nodes[i - 1] || previousNode;\n          nodes[i].nextSibling_ = nodes[i + 1] || nextNode;\n        }\n        if (previousNode) previousNode.nextSibling_ = nodes[0];\n        if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];\n        return nodes;\n      }\n      var nodes = createOneElementNodeList(node);\n      var oldParent = node.parentNode;\n      if (oldParent) {\n        oldParent.removeChild(node);\n      }\n      node.parentNode_ = parentNode;\n      node.previousSibling_ = previousNode;\n      node.nextSibling_ = nextNode;\n      if (previousNode) previousNode.nextSibling_ = node;\n      if (nextNode) nextNode.previousSibling_ = node;\n      return nodes;\n    }\n    function collectNodesNative(node) {\n      if (node instanceof DocumentFragment) return collectNodesForDocumentFragment(node);\n      var nodes = createOneElementNodeList(node);\n      var oldParent = node.parentNode;\n      if (oldParent) enqueueRemovalForInsertedNodes(node, oldParent, nodes);\n      return nodes;\n    }\n    function collectNodesForDocumentFragment(node) {\n      var nodes = new NodeList();\n      var i = 0;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        nodes[i++] = child;\n      }\n      nodes.length = i;\n      enqueueRemovalForInsertedDocumentFragment(node, nodes);\n      return nodes;\n    }\n    function snapshotNodeList(nodeList) {\n      return nodeList;\n    }\n    function nodeWasAdded(node, treeScope) {\n      setTreeScope(node, treeScope);\n      node.nodeIsInserted_();\n    }\n    function nodesWereAdded(nodes, parent) {\n      var treeScope = getTreeScope(parent);\n      for (var i = 0; i < nodes.length; i++) {\n        nodeWasAdded(nodes[i], treeScope);\n      }\n    }\n    function nodeWasRemoved(node) {\n      setTreeScope(node, new TreeScope(node, null));\n    }\n    function nodesWereRemoved(nodes) {\n      for (var i = 0; i < nodes.length; i++) {\n        nodeWasRemoved(nodes[i]);\n      }\n    }\n    function ensureSameOwnerDocument(parent, child) {\n      var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ? parent : parent.ownerDocument;\n      if (ownerDoc !== child.ownerDocument) ownerDoc.adoptNode(child);\n    }\n    function adoptNodesIfNeeded(owner, nodes) {\n      if (!nodes.length) return;\n      var ownerDoc = owner.ownerDocument;\n      if (ownerDoc === nodes[0].ownerDocument) return;\n      for (var i = 0; i < nodes.length; i++) {\n        scope.adoptNodeNoRemove(nodes[i], ownerDoc);\n      }\n    }\n    function unwrapNodesForInsertion(owner, nodes) {\n      adoptNodesIfNeeded(owner, nodes);\n      var length = nodes.length;\n      if (length === 1) return unwrap(nodes[0]);\n      var df = unwrap(owner.ownerDocument.createDocumentFragment());\n      for (var i = 0; i < length; i++) {\n        df.appendChild(unwrap(nodes[i]));\n      }\n      return df;\n    }\n    function clearChildNodes(wrapper) {\n      if (wrapper.firstChild_ !== undefined) {\n        var child = wrapper.firstChild_;\n        while (child) {\n          var tmp = child;\n          child = child.nextSibling_;\n          tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;\n        }\n      }\n      wrapper.firstChild_ = wrapper.lastChild_ = undefined;\n    }\n    function removeAllChildNodes(wrapper) {\n      if (wrapper.invalidateShadowRenderer()) {\n        var childWrapper = wrapper.firstChild;\n        while (childWrapper) {\n          assert(childWrapper.parentNode === wrapper);\n          var nextSibling = childWrapper.nextSibling;\n          var childNode = unwrap(childWrapper);\n          var parentNode = childNode.parentNode;\n          if (parentNode) originalRemoveChild.call(parentNode, childNode);\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;\n          childWrapper = nextSibling;\n        }\n        wrapper.firstChild_ = wrapper.lastChild_ = null;\n      } else {\n        var node = unwrap(wrapper);\n        var child = node.firstChild;\n        var nextSibling;\n        while (child) {\n          nextSibling = child.nextSibling;\n          originalRemoveChild.call(node, child);\n          child = nextSibling;\n        }\n      }\n    }\n    function invalidateParent(node) {\n      var p = node.parentNode;\n      return p && p.invalidateShadowRenderer();\n    }\n    function cleanupNodes(nodes) {\n      for (var i = 0, n; i < nodes.length; i++) {\n        n = nodes[i];\n        n.parentNode.removeChild(n);\n      }\n    }\n    var originalImportNode = document.importNode;\n    var originalCloneNode = window.Node.prototype.cloneNode;\n    function cloneNode(node, deep, opt_doc) {\n      var clone;\n      if (opt_doc) clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false)); else clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));\n      if (deep) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          clone.appendChild(cloneNode(child, true, opt_doc));\n        }\n        if (node instanceof wrappers.HTMLTemplateElement) {\n          var cloneContent = clone.content;\n          for (var child = node.content.firstChild; child; child = child.nextSibling) {\n            cloneContent.appendChild(cloneNode(child, true, opt_doc));\n          }\n        }\n      }\n      return clone;\n    }\n    function contains(self, child) {\n      if (!child || getTreeScope(self) !== getTreeScope(child)) return false;\n      for (var node = child; node; node = node.parentNode) {\n        if (node === self) return true;\n      }\n      return false;\n    }\n    var OriginalNode = window.Node;\n    function Node(original) {\n      assert(original instanceof OriginalNode);\n      EventTarget.call(this, original);\n      this.parentNode_ = undefined;\n      this.firstChild_ = undefined;\n      this.lastChild_ = undefined;\n      this.nextSibling_ = undefined;\n      this.previousSibling_ = undefined;\n      this.treeScope_ = undefined;\n    }\n    var OriginalDocumentFragment = window.DocumentFragment;\n    var originalAppendChild = OriginalNode.prototype.appendChild;\n    var originalCompareDocumentPosition = OriginalNode.prototype.compareDocumentPosition;\n    var originalIsEqualNode = OriginalNode.prototype.isEqualNode;\n    var originalInsertBefore = OriginalNode.prototype.insertBefore;\n    var originalRemoveChild = OriginalNode.prototype.removeChild;\n    var originalReplaceChild = OriginalNode.prototype.replaceChild;\n    var isIEOrEdge = /Trident|Edge/.test(navigator.userAgent);\n    var removeChildOriginalHelper = isIEOrEdge ? function(parent, child) {\n      try {\n        originalRemoveChild.call(parent, child);\n      } catch (ex) {\n        if (!(parent instanceof OriginalDocumentFragment)) throw ex;\n      }\n    } : function(parent, child) {\n      originalRemoveChild.call(parent, child);\n    };\n    Node.prototype = Object.create(EventTarget.prototype);\n    mixin(Node.prototype, {\n      appendChild: function(childWrapper) {\n        return this.insertBefore(childWrapper, null);\n      },\n      insertBefore: function(childWrapper, refWrapper) {\n        assertIsNodeWrapper(childWrapper);\n        var refNode;\n        if (refWrapper) {\n          if (isWrapper(refWrapper)) {\n            refNode = unwrap(refWrapper);\n          } else {\n            refNode = refWrapper;\n            refWrapper = wrap(refNode);\n          }\n        } else {\n          refWrapper = null;\n          refNode = null;\n        }\n        refWrapper && assert(refWrapper.parentNode === this);\n        var nodes;\n        var previousNode = refWrapper ? refWrapper.previousSibling : this.lastChild;\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(childWrapper);\n        if (useNative) nodes = collectNodesNative(childWrapper); else nodes = collectNodes(childWrapper, this, previousNode, refWrapper);\n        if (useNative) {\n          ensureSameOwnerDocument(this, childWrapper);\n          clearChildNodes(this);\n          originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);\n        } else {\n          if (!previousNode) this.firstChild_ = nodes[0];\n          if (!refWrapper) {\n            this.lastChild_ = nodes[nodes.length - 1];\n            if (this.firstChild_ === undefined) this.firstChild_ = this.firstChild;\n          }\n          var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);\n          if (parentNode) {\n            originalInsertBefore.call(parentNode, unwrapNodesForInsertion(this, nodes), refNode);\n          } else {\n            adoptNodesIfNeeded(this, nodes);\n          }\n        }\n        enqueueMutation(this, "childList", {\n          addedNodes: nodes,\n          nextSibling: refWrapper,\n          previousSibling: previousNode\n        });\n        nodesWereAdded(nodes, this);\n        return childWrapper;\n      },\n      removeChild: function(childWrapper) {\n        assertIsNodeWrapper(childWrapper);\n        if (childWrapper.parentNode !== this) {\n          var found = false;\n          var childNodes = this.childNodes;\n          for (var ieChild = this.firstChild; ieChild; ieChild = ieChild.nextSibling) {\n            if (ieChild === childWrapper) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new Error("NotFoundError");\n          }\n        }\n        var childNode = unwrap(childWrapper);\n        var childWrapperNextSibling = childWrapper.nextSibling;\n        var childWrapperPreviousSibling = childWrapper.previousSibling;\n        if (this.invalidateShadowRenderer()) {\n          var thisFirstChild = this.firstChild;\n          var thisLastChild = this.lastChild;\n          var parentNode = childNode.parentNode;\n          if (parentNode) removeChildOriginalHelper(parentNode, childNode);\n          if (thisFirstChild === childWrapper) this.firstChild_ = childWrapperNextSibling;\n          if (thisLastChild === childWrapper) this.lastChild_ = childWrapperPreviousSibling;\n          if (childWrapperPreviousSibling) childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;\n          if (childWrapperNextSibling) {\n            childWrapperNextSibling.previousSibling_ = childWrapperPreviousSibling;\n          }\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = undefined;\n        } else {\n          clearChildNodes(this);\n          removeChildOriginalHelper(unsafeUnwrap(this), childNode);\n        }\n        if (!surpressMutations) {\n          enqueueMutation(this, "childList", {\n            removedNodes: createOneElementNodeList(childWrapper),\n            nextSibling: childWrapperNextSibling,\n            previousSibling: childWrapperPreviousSibling\n          });\n        }\n        registerTransientObservers(this, childWrapper);\n        return childWrapper;\n      },\n      replaceChild: function(newChildWrapper, oldChildWrapper) {\n        assertIsNodeWrapper(newChildWrapper);\n        var oldChildNode;\n        if (isWrapper(oldChildWrapper)) {\n          oldChildNode = unwrap(oldChildWrapper);\n        } else {\n          oldChildNode = oldChildWrapper;\n          oldChildWrapper = wrap(oldChildNode);\n        }\n        if (oldChildWrapper.parentNode !== this) {\n          throw new Error("NotFoundError");\n        }\n        var nextNode = oldChildWrapper.nextSibling;\n        var previousNode = oldChildWrapper.previousSibling;\n        var nodes;\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(newChildWrapper);\n        if (useNative) {\n          nodes = collectNodesNative(newChildWrapper);\n        } else {\n          if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;\n          nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);\n        }\n        if (!useNative) {\n          if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];\n          if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];\n          oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ = oldChildWrapper.parentNode_ = undefined;\n          if (oldChildNode.parentNode) {\n            originalReplaceChild.call(oldChildNode.parentNode, unwrapNodesForInsertion(this, nodes), oldChildNode);\n          }\n        } else {\n          ensureSameOwnerDocument(this, newChildWrapper);\n          clearChildNodes(this);\n          originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper), oldChildNode);\n        }\n        enqueueMutation(this, "childList", {\n          addedNodes: nodes,\n          removedNodes: createOneElementNodeList(oldChildWrapper),\n          nextSibling: nextNode,\n          previousSibling: previousNode\n        });\n        nodeWasRemoved(oldChildWrapper);\n        nodesWereAdded(nodes, this);\n        return oldChildWrapper;\n      },\n      nodeIsInserted_: function() {\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          child.nodeIsInserted_();\n        }\n      },\n      hasChildNodes: function() {\n        return this.firstChild !== null;\n      },\n      get parentNode() {\n        return this.parentNode_ !== undefined ? this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);\n      },\n      get firstChild() {\n        return this.firstChild_ !== undefined ? this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);\n      },\n      get lastChild() {\n        return this.lastChild_ !== undefined ? this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);\n      },\n      get nextSibling() {\n        return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);\n      },\n      get previousSibling() {\n        return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);\n      },\n      get parentElement() {\n        var p = this.parentNode;\n        while (p && p.nodeType !== Node.ELEMENT_NODE) {\n          p = p.parentNode;\n        }\n        return p;\n      },\n      get textContent() {\n        var s = "";\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType != Node.COMMENT_NODE) {\n            s += child.textContent;\n          }\n        }\n        return s;\n      },\n      set textContent(textContent) {\n        if (textContent == null) textContent = "";\n        var removedNodes = snapshotNodeList(this.childNodes);\n        if (this.invalidateShadowRenderer()) {\n          removeAllChildNodes(this);\n          if (textContent !== "") {\n            var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);\n            this.appendChild(textNode);\n          }\n        } else {\n          clearChildNodes(this);\n          unsafeUnwrap(this).textContent = textContent;\n        }\n        var addedNodes = snapshotNodeList(this.childNodes);\n        enqueueMutation(this, "childList", {\n          addedNodes: addedNodes,\n          removedNodes: removedNodes\n        });\n        nodesWereRemoved(removedNodes);\n        nodesWereAdded(addedNodes, this);\n      },\n      get childNodes() {\n        var wrapperList = new NodeList();\n        var i = 0;\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          wrapperList[i++] = child;\n        }\n        wrapperList.length = i;\n        return wrapperList;\n      },\n      cloneNode: function(deep) {\n        return cloneNode(this, deep);\n      },\n      contains: function(child) {\n        return contains(this, wrapIfNeeded(child));\n      },\n      compareDocumentPosition: function(otherNode) {\n        return originalCompareDocumentPosition.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n      },\n      isEqualNode: function(otherNode) {\n        return originalIsEqualNode.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n      },\n      normalize: function() {\n        var nodes = snapshotNodeList(this.childNodes);\n        var remNodes = [];\n        var s = "";\n        var modNode;\n        for (var i = 0, n; i < nodes.length; i++) {\n          n = nodes[i];\n          if (n.nodeType === Node.TEXT_NODE) {\n            if (!modNode && !n.data.length) this.removeChild(n); else if (!modNode) modNode = n; else {\n              s += n.data;\n              remNodes.push(n);\n            }\n          } else {\n            if (modNode && remNodes.length) {\n              modNode.data += s;\n              cleanupNodes(remNodes);\n            }\n            remNodes = [];\n            s = "";\n            modNode = null;\n            if (n.childNodes.length) n.normalize();\n          }\n        }\n        if (modNode && remNodes.length) {\n          modNode.data += s;\n          cleanupNodes(remNodes);\n        }\n      }\n    });\n    defineWrapGetter(Node, "ownerDocument");\n    registerWrapper(OriginalNode, Node, document.createDocumentFragment());\n    delete Node.prototype.querySelector;\n    delete Node.prototype.querySelectorAll;\n    Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);\n    scope.cloneNode = cloneNode;\n    scope.nodeWasAdded = nodeWasAdded;\n    scope.nodeWasRemoved = nodeWasRemoved;\n    scope.nodesWereAdded = nodesWereAdded;\n    scope.nodesWereRemoved = nodesWereRemoved;\n    scope.originalInsertBefore = originalInsertBefore;\n    scope.originalRemoveChild = originalRemoveChild;\n    scope.snapshotNodeList = snapshotNodeList;\n    scope.wrappers.Node = Node;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLCollection = scope.wrappers.HTMLCollection;\n    var NodeList = scope.wrappers.NodeList;\n    var getTreeScope = scope.getTreeScope;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var originalDocumentQuerySelector = document.querySelector;\n    var originalElementQuerySelector = document.documentElement.querySelector;\n    var originalDocumentQuerySelectorAll = document.querySelectorAll;\n    var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;\n    var originalDocumentGetElementsByTagName = document.getElementsByTagName;\n    var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;\n    var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;\n    var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;\n    var OriginalElement = window.Element;\n    var OriginalDocument = window.HTMLDocument || window.Document;\n    function filterNodeList(list, index, result, deep) {\n      var wrappedItem = null;\n      var root = null;\n      for (var i = 0, length = list.length; i < length; i++) {\n        wrappedItem = wrap(list[i]);\n        if (!deep && (root = getTreeScope(wrappedItem).root)) {\n          if (root instanceof scope.wrappers.ShadowRoot) {\n            continue;\n          }\n        }\n        result[index++] = wrappedItem;\n      }\n      return index;\n    }\n    function shimSelector(selector) {\n      return String(selector).replace(/\\/deep\\/|::shadow|>>>/g, " ");\n    }\n    function shimMatchesSelector(selector) {\n      return String(selector).replace(/:host\\(([^\\s]+)\\)/g, "$1").replace(/([^\\s]):host/g, "$1").replace(":host", "*").replace(/\\^|\\/shadow\\/|\\/shadow-deep\\/|::shadow|\\/deep\\/|::content|>>>/g, " ");\n    }\n    function findOne(node, selector) {\n      var m, el = node.firstElementChild;\n      while (el) {\n        if (el.matches(selector)) return el;\n        m = findOne(el, selector);\n        if (m) return m;\n        el = el.nextElementSibling;\n      }\n      return null;\n    }\n    function matchesSelector(el, selector) {\n      return el.matches(selector);\n    }\n    var XHTML_NS = "http://www.w3.org/1999/xhtml";\n    function matchesTagName(el, localName, localNameLowerCase) {\n      var ln = el.localName;\n      return ln === localName || ln === localNameLowerCase && el.namespaceURI === XHTML_NS;\n    }\n    function matchesEveryThing() {\n      return true;\n    }\n    function matchesLocalNameOnly(el, ns, localName) {\n      return el.localName === localName;\n    }\n    function matchesNameSpace(el, ns) {\n      return el.namespaceURI === ns;\n    }\n    function matchesLocalNameNS(el, ns, localName) {\n      return el.namespaceURI === ns && el.localName === localName;\n    }\n    function findElements(node, index, result, p, arg0, arg1) {\n      var el = node.firstElementChild;\n      while (el) {\n        if (p(el, arg0, arg1)) result[index++] = el;\n        index = findElements(el, index, result, p, arg0, arg1);\n        el = el.nextElementSibling;\n      }\n      return index;\n    }\n    function querySelectorAllFiltered(p, index, result, selector, deep) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, selector, null);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementQuerySelectorAll.call(target, selector);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentQuerySelectorAll.call(target, selector);\n      } else {\n        return findElements(this, index, result, p, selector, null);\n      }\n      return filterNodeList(list, index, result, deep);\n    }\n    var SelectorsInterface = {\n      querySelector: function(selector) {\n        var shimmed = shimSelector(selector);\n        var deep = shimmed !== selector;\n        selector = shimmed;\n        var target = unsafeUnwrap(this);\n        var wrappedItem;\n        var root = getTreeScope(this).root;\n        if (root instanceof scope.wrappers.ShadowRoot) {\n          return findOne(this, selector);\n        } else if (target instanceof OriginalElement) {\n          wrappedItem = wrap(originalElementQuerySelector.call(target, selector));\n        } else if (target instanceof OriginalDocument) {\n          wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));\n        } else {\n          return findOne(this, selector);\n        }\n        if (!wrappedItem) {\n          return wrappedItem;\n        } else if (!deep && (root = getTreeScope(wrappedItem).root)) {\n          if (root instanceof scope.wrappers.ShadowRoot) {\n            return findOne(this, selector);\n          }\n        }\n        return wrappedItem;\n      },\n      querySelectorAll: function(selector) {\n        var shimmed = shimSelector(selector);\n        var deep = shimmed !== selector;\n        selector = shimmed;\n        var result = new NodeList();\n        result.length = querySelectorAllFiltered.call(this, matchesSelector, 0, result, selector, deep);\n        return result;\n      }\n    };\n    var MatchesInterface = {\n      matches: function(selector) {\n        selector = shimMatchesSelector(selector);\n        return scope.originalMatches.call(unsafeUnwrap(this), selector);\n      }\n    };\n    function getElementsByTagNameFiltered(p, index, result, localName, lowercase) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, localName, lowercase);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementGetElementsByTagName.call(target, localName, lowercase);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentGetElementsByTagName.call(target, localName, lowercase);\n      } else {\n        return findElements(this, index, result, p, localName, lowercase);\n      }\n      return filterNodeList(list, index, result, false);\n    }\n    function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, ns, localName);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementGetElementsByTagNameNS.call(target, ns, localName);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);\n      } else {\n        return findElements(this, index, result, p, ns, localName);\n      }\n      return filterNodeList(list, index, result, false);\n    }\n    var GetElementsByInterface = {\n      getElementsByTagName: function(localName) {\n        var result = new HTMLCollection();\n        var match = localName === "*" ? matchesEveryThing : matchesTagName;\n        result.length = getElementsByTagNameFiltered.call(this, match, 0, result, localName, localName.toLowerCase());\n        return result;\n      },\n      getElementsByClassName: function(className) {\n        return this.querySelectorAll("." + className);\n      },\n      getElementsByTagNameNS: function(ns, localName) {\n        var result = new HTMLCollection();\n        var match = null;\n        if (ns === "*") {\n          match = localName === "*" ? matchesEveryThing : matchesLocalNameOnly;\n        } else {\n          match = localName === "*" ? matchesNameSpace : matchesLocalNameNS;\n        }\n        result.length = getElementsByTagNameNSFiltered.call(this, match, 0, result, ns || null, localName);\n        return result;\n      }\n    };\n    scope.GetElementsByInterface = GetElementsByInterface;\n    scope.SelectorsInterface = SelectorsInterface;\n    scope.MatchesInterface = MatchesInterface;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var NodeList = scope.wrappers.NodeList;\n    function forwardElement(node) {\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n        node = node.nextSibling;\n      }\n      return node;\n    }\n    function backwardsElement(node) {\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n        node = node.previousSibling;\n      }\n      return node;\n    }\n    var ParentNodeInterface = {\n      get firstElementChild() {\n        return forwardElement(this.firstChild);\n      },\n      get lastElementChild() {\n        return backwardsElement(this.lastChild);\n      },\n      get childElementCount() {\n        var count = 0;\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n          count++;\n        }\n        return count;\n      },\n      get children() {\n        var wrapperList = new NodeList();\n        var i = 0;\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n          wrapperList[i++] = child;\n        }\n        wrapperList.length = i;\n        return wrapperList;\n      },\n      remove: function() {\n        var p = this.parentNode;\n        if (p) p.removeChild(this);\n      }\n    };\n    var ChildNodeInterface = {\n      get nextElementSibling() {\n        return forwardElement(this.nextSibling);\n      },\n      get previousElementSibling() {\n        return backwardsElement(this.previousSibling);\n      }\n    };\n    var NonElementParentNodeInterface = {\n      getElementById: function(id) {\n        if (/[ \\t\\n\\r\\f]/.test(id)) return null;\n        return this.querySelector(\'[id="\' + id + \'"]\');\n      }\n    };\n    scope.ChildNodeInterface = ChildNodeInterface;\n    scope.NonElementParentNodeInterface = NonElementParentNodeInterface;\n    scope.ParentNodeInterface = ParentNodeInterface;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var ChildNodeInterface = scope.ChildNodeInterface;\n    var Node = scope.wrappers.Node;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var OriginalCharacterData = window.CharacterData;\n    function CharacterData(node) {\n      Node.call(this, node);\n    }\n    CharacterData.prototype = Object.create(Node.prototype);\n    mixin(CharacterData.prototype, {\n      get nodeValue() {\n        return this.data;\n      },\n      set nodeValue(data) {\n        this.data = data;\n      },\n      get textContent() {\n        return this.data;\n      },\n      set textContent(value) {\n        this.data = value;\n      },\n      get data() {\n        return unsafeUnwrap(this).data;\n      },\n      set data(value) {\n        var oldValue = unsafeUnwrap(this).data;\n        enqueueMutation(this, "characterData", {\n          oldValue: oldValue\n        });\n        unsafeUnwrap(this).data = value;\n      }\n    });\n    mixin(CharacterData.prototype, ChildNodeInterface);\n    registerWrapper(OriginalCharacterData, CharacterData, document.createTextNode(""));\n    scope.wrappers.CharacterData = CharacterData;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var CharacterData = scope.wrappers.CharacterData;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    function toUInt32(x) {\n      return x >>> 0;\n    }\n    var OriginalText = window.Text;\n    function Text(node) {\n      CharacterData.call(this, node);\n    }\n    Text.prototype = Object.create(CharacterData.prototype);\n    mixin(Text.prototype, {\n      splitText: function(offset) {\n        offset = toUInt32(offset);\n        var s = this.data;\n        if (offset > s.length) throw new Error("IndexSizeError");\n        var head = s.slice(0, offset);\n        var tail = s.slice(offset);\n        this.data = head;\n        var newTextNode = this.ownerDocument.createTextNode(tail);\n        if (this.parentNode) this.parentNode.insertBefore(newTextNode, this.nextSibling);\n        return newTextNode;\n      }\n    });\n    registerWrapper(OriginalText, Text, document.createTextNode(""));\n    scope.wrappers.Text = Text;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    if (!window.DOMTokenList) {\n      console.warn("Missing DOMTokenList prototype, please include a " + "compatible classList polyfill such as http://goo.gl/uTcepH.");\n      return;\n    }\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var enqueueMutation = scope.enqueueMutation;\n    function getClass(el) {\n      return unsafeUnwrap(el).getAttribute("class");\n    }\n    function enqueueClassAttributeChange(el, oldValue) {\n      enqueueMutation(el, "attributes", {\n        name: "class",\n        namespace: null,\n        oldValue: oldValue\n      });\n    }\n    function invalidateClass(el) {\n      scope.invalidateRendererBasedOnAttribute(el, "class");\n    }\n    function changeClass(tokenList, method, args) {\n      var ownerElement = tokenList.ownerElement_;\n      if (ownerElement == null) {\n        return method.apply(tokenList, args);\n      }\n      var oldValue = getClass(ownerElement);\n      var retv = method.apply(tokenList, args);\n      if (getClass(ownerElement) !== oldValue) {\n        enqueueClassAttributeChange(ownerElement, oldValue);\n        invalidateClass(ownerElement);\n      }\n      return retv;\n    }\n    var oldAdd = DOMTokenList.prototype.add;\n    DOMTokenList.prototype.add = function() {\n      changeClass(this, oldAdd, arguments);\n    };\n    var oldRemove = DOMTokenList.prototype.remove;\n    DOMTokenList.prototype.remove = function() {\n      changeClass(this, oldRemove, arguments);\n    };\n    var oldToggle = DOMTokenList.prototype.toggle;\n    DOMTokenList.prototype.toggle = function() {\n      return changeClass(this, oldToggle, arguments);\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var ChildNodeInterface = scope.ChildNodeInterface;\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var Node = scope.wrappers.Node;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var MatchesInterface = scope.MatchesInterface;\n    var addWrapNodeListMethod = scope.addWrapNodeListMethod;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var oneOf = scope.oneOf;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrappers = scope.wrappers;\n    var OriginalElement = window.Element;\n    var matchesNames = [ "matches", "mozMatchesSelector", "msMatchesSelector", "webkitMatchesSelector" ].filter(function(name) {\n      return OriginalElement.prototype[name];\n    });\n    var matchesName = matchesNames[0];\n    var originalMatches = OriginalElement.prototype[matchesName];\n    function invalidateRendererBasedOnAttribute(element, name) {\n      var p = element.parentNode;\n      if (!p || !p.shadowRoot) return;\n      var renderer = scope.getRendererForHost(p);\n      if (renderer.dependsOnAttribute(name)) renderer.invalidate();\n    }\n    function enqueAttributeChange(element, name, oldValue) {\n      enqueueMutation(element, "attributes", {\n        name: name,\n        namespace: null,\n        oldValue: oldValue\n      });\n    }\n    var classListTable = new WeakMap();\n    function Element(node) {\n      Node.call(this, node);\n    }\n    Element.prototype = Object.create(Node.prototype);\n    mixin(Element.prototype, {\n      createShadowRoot: function() {\n        var newShadowRoot = new wrappers.ShadowRoot(this);\n        unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;\n        var renderer = scope.getRendererForHost(this);\n        renderer.invalidate();\n        return newShadowRoot;\n      },\n      get shadowRoot() {\n        return unsafeUnwrap(this).polymerShadowRoot_ || null;\n      },\n      setAttribute: function(name, value) {\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\n        unsafeUnwrap(this).setAttribute(name, value);\n        enqueAttributeChange(this, name, oldValue);\n        invalidateRendererBasedOnAttribute(this, name);\n      },\n      removeAttribute: function(name) {\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\n        unsafeUnwrap(this).removeAttribute(name);\n        enqueAttributeChange(this, name, oldValue);\n        invalidateRendererBasedOnAttribute(this, name);\n      },\n      get classList() {\n        var list = classListTable.get(this);\n        if (!list) {\n          list = unsafeUnwrap(this).classList;\n          if (!list) return;\n          list.ownerElement_ = this;\n          classListTable.set(this, list);\n        }\n        return list;\n      },\n      get className() {\n        return unsafeUnwrap(this).className;\n      },\n      set className(v) {\n        this.setAttribute("class", v);\n      },\n      get id() {\n        return unsafeUnwrap(this).id;\n      },\n      set id(v) {\n        this.setAttribute("id", v);\n      }\n    });\n    matchesNames.forEach(function(name) {\n      if (name !== "matches") {\n        Element.prototype[name] = function(selector) {\n          return this.matches(selector);\n        };\n      }\n    });\n    if (OriginalElement.prototype.webkitCreateShadowRoot) {\n      Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;\n    }\n    mixin(Element.prototype, ChildNodeInterface);\n    mixin(Element.prototype, GetElementsByInterface);\n    mixin(Element.prototype, ParentNodeInterface);\n    mixin(Element.prototype, SelectorsInterface);\n    mixin(Element.prototype, MatchesInterface);\n    registerWrapper(OriginalElement, Element, document.createElementNS(null, "x"));\n    scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;\n    scope.matchesNames = matchesNames;\n    scope.originalMatches = originalMatches;\n    scope.wrappers.Element = Element;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var Element = scope.wrappers.Element;\n    var defineGetter = scope.defineGetter;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var nodesWereAdded = scope.nodesWereAdded;\n    var nodesWereRemoved = scope.nodesWereRemoved;\n    var registerWrapper = scope.registerWrapper;\n    var snapshotNodeList = scope.snapshotNodeList;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrappers = scope.wrappers;\n    var escapeAttrRegExp = /[&\\u00A0"]/g;\n    var escapeDataRegExp = /[&\\u00A0<>]/g;\n    function escapeReplace(c) {\n      switch (c) {\n       case "&":\n        return "&amp;";\n\n       case "<":\n        return "&lt;";\n\n       case ">":\n        return "&gt;";\n\n       case \'"\':\n        return "&quot;";\n\n       case "":\n        return "&nbsp;";\n      }\n    }\n    function escapeAttr(s) {\n      return s.replace(escapeAttrRegExp, escapeReplace);\n    }\n    function escapeData(s) {\n      return s.replace(escapeDataRegExp, escapeReplace);\n    }\n    function makeSet(arr) {\n      var set = {};\n      for (var i = 0; i < arr.length; i++) {\n        set[arr[i]] = true;\n      }\n      return set;\n    }\n    var voidElements = makeSet([ "area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr" ]);\n    var plaintextParents = makeSet([ "style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript" ]);\n    var XHTML_NS = "http://www.w3.org/1999/xhtml";\n    function needsSelfClosingSlash(node) {\n      if (node.namespaceURI !== XHTML_NS) return true;\n      var doctype = node.ownerDocument.doctype;\n      return doctype && doctype.publicId && doctype.systemId;\n    }\n    function getOuterHTML(node, parentNode) {\n      switch (node.nodeType) {\n       case Node.ELEMENT_NODE:\n        var tagName = node.tagName.toLowerCase();\n        var s = "<" + tagName;\n        var attrs = node.attributes;\n        for (var i = 0, attr; attr = attrs[i]; i++) {\n          s += " " + attr.name + \'="\' + escapeAttr(attr.value) + \'"\';\n        }\n        if (voidElements[tagName]) {\n          if (needsSelfClosingSlash(node)) s += "/";\n          return s + ">";\n        }\n        return s + ">" + getInnerHTML(node) + "</" + tagName + ">";\n\n       case Node.TEXT_NODE:\n        var data = node.data;\n        if (parentNode && plaintextParents[parentNode.localName]) return data;\n        return escapeData(data);\n\n       case Node.COMMENT_NODE:\n        return "<!--" + node.data + "-->";\n\n       default:\n        console.error(node);\n        throw new Error("not implemented");\n      }\n    }\n    function getInnerHTML(node) {\n      if (node instanceof wrappers.HTMLTemplateElement) node = node.content;\n      var s = "";\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        s += getOuterHTML(child, node);\n      }\n      return s;\n    }\n    function setInnerHTML(node, value, opt_tagName) {\n      var tagName = opt_tagName || "div";\n      node.textContent = "";\n      var tempElement = unwrap(node.ownerDocument.createElement(tagName));\n      tempElement.innerHTML = value;\n      var firstChild;\n      while (firstChild = tempElement.firstChild) {\n        node.appendChild(wrap(firstChild));\n      }\n    }\n    var oldIe = /MSIE/.test(navigator.userAgent);\n    var OriginalHTMLElement = window.HTMLElement;\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n    function HTMLElement(node) {\n      Element.call(this, node);\n    }\n    HTMLElement.prototype = Object.create(Element.prototype);\n    mixin(HTMLElement.prototype, {\n      get innerHTML() {\n        return getInnerHTML(this);\n      },\n      set innerHTML(value) {\n        if (oldIe && plaintextParents[this.localName]) {\n          this.textContent = value;\n          return;\n        }\n        var removedNodes = snapshotNodeList(this.childNodes);\n        if (this.invalidateShadowRenderer()) {\n          if (this instanceof wrappers.HTMLTemplateElement) setInnerHTML(this.content, value); else setInnerHTML(this, value, this.tagName);\n        } else if (!OriginalHTMLTemplateElement && this instanceof wrappers.HTMLTemplateElement) {\n          setInnerHTML(this.content, value);\n        } else {\n          unsafeUnwrap(this).innerHTML = value;\n        }\n        var addedNodes = snapshotNodeList(this.childNodes);\n        enqueueMutation(this, "childList", {\n          addedNodes: addedNodes,\n          removedNodes: removedNodes\n        });\n        nodesWereRemoved(removedNodes);\n        nodesWereAdded(addedNodes, this);\n      },\n      get outerHTML() {\n        return getOuterHTML(this, this.parentNode);\n      },\n      set outerHTML(value) {\n        var p = this.parentNode;\n        if (p) {\n          p.invalidateShadowRenderer();\n          var df = frag(p, value);\n          p.replaceChild(df, this);\n        }\n      },\n      insertAdjacentHTML: function(position, text) {\n        var contextElement, refNode;\n        switch (String(position).toLowerCase()) {\n         case "beforebegin":\n          contextElement = this.parentNode;\n          refNode = this;\n          break;\n\n         case "afterend":\n          contextElement = this.parentNode;\n          refNode = this.nextSibling;\n          break;\n\n         case "afterbegin":\n          contextElement = this;\n          refNode = this.firstChild;\n          break;\n\n         case "beforeend":\n          contextElement = this;\n          refNode = null;\n          break;\n\n         default:\n          return;\n        }\n        var df = frag(contextElement, text);\n        contextElement.insertBefore(df, refNode);\n      },\n      get hidden() {\n        return this.hasAttribute("hidden");\n      },\n      set hidden(v) {\n        if (v) {\n          this.setAttribute("hidden", "");\n        } else {\n          this.removeAttribute("hidden");\n        }\n      }\n    });\n    function frag(contextElement, html) {\n      var p = unwrap(contextElement.cloneNode(false));\n      p.innerHTML = html;\n      var df = unwrap(document.createDocumentFragment());\n      var c;\n      while (c = p.firstChild) {\n        df.appendChild(c);\n      }\n      return wrap(df);\n    }\n    function getter(name) {\n      return function() {\n        scope.renderAllPending();\n        return unsafeUnwrap(this)[name];\n      };\n    }\n    function getterRequiresRendering(name) {\n      defineGetter(HTMLElement, name, getter(name));\n    }\n    [ "clientHeight", "clientLeft", "clientTop", "clientWidth", "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth", "scrollHeight", "scrollWidth" ].forEach(getterRequiresRendering);\n    function getterAndSetterRequiresRendering(name) {\n      Object.defineProperty(HTMLElement.prototype, name, {\n        get: getter(name),\n        set: function(v) {\n          scope.renderAllPending();\n          unsafeUnwrap(this)[name] = v;\n        },\n        configurable: true,\n        enumerable: true\n      });\n    }\n    [ "scrollLeft", "scrollTop" ].forEach(getterAndSetterRequiresRendering);\n    function methodRequiresRendering(name) {\n      Object.defineProperty(HTMLElement.prototype, name, {\n        value: function() {\n          scope.renderAllPending();\n          return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);\n        },\n        configurable: true,\n        enumerable: true\n      });\n    }\n    [ "focus", "getBoundingClientRect", "getClientRects", "scrollIntoView" ].forEach(methodRequiresRendering);\n    registerWrapper(OriginalHTMLElement, HTMLElement, document.createElement("b"));\n    scope.wrappers.HTMLElement = HTMLElement;\n    scope.getInnerHTML = getInnerHTML;\n    scope.setInnerHTML = setInnerHTML;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLCanvasElement = window.HTMLCanvasElement;\n    function HTMLCanvasElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLCanvasElement.prototype, {\n      getContext: function() {\n        var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);\n        return context && wrap(context);\n      }\n    });\n    registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement, document.createElement("canvas"));\n    scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLContentElement = window.HTMLContentElement;\n    function HTMLContentElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLContentElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLContentElement.prototype, {\n      constructor: HTMLContentElement,\n      get select() {\n        return this.getAttribute("select");\n      },\n      set select(value) {\n        this.setAttribute("select", value);\n      },\n      setAttribute: function(n, v) {\n        HTMLElement.prototype.setAttribute.call(this, n, v);\n        if (String(n).toLowerCase() === "select") this.invalidateShadowRenderer(true);\n      }\n    });\n    if (OriginalHTMLContentElement) registerWrapper(OriginalHTMLContentElement, HTMLContentElement);\n    scope.wrappers.HTMLContentElement = HTMLContentElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var OriginalHTMLFormElement = window.HTMLFormElement;\n    function HTMLFormElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLFormElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLFormElement.prototype, {\n      get elements() {\n        return wrapHTMLCollection(unwrap(this).elements);\n      }\n    });\n    registerWrapper(OriginalHTMLFormElement, HTMLFormElement, document.createElement("form"));\n    scope.wrappers.HTMLFormElement = HTMLFormElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var rewrap = scope.rewrap;\n    var OriginalHTMLImageElement = window.HTMLImageElement;\n    function HTMLImageElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLImageElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLImageElement, HTMLImageElement, document.createElement("img"));\n    function Image(width, height) {\n      if (!(this instanceof Image)) {\n        throw new TypeError("DOM object constructor cannot be called as a function.");\n      }\n      var node = unwrap(document.createElement("img"));\n      HTMLElement.call(this, node);\n      rewrap(node, this);\n      if (width !== undefined) node.width = width;\n      if (height !== undefined) node.height = height;\n    }\n    Image.prototype = HTMLImageElement.prototype;\n    scope.wrappers.HTMLImageElement = HTMLImageElement;\n    scope.wrappers.Image = Image;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var NodeList = scope.wrappers.NodeList;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLShadowElement = window.HTMLShadowElement;\n    function HTMLShadowElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);\n    HTMLShadowElement.prototype.constructor = HTMLShadowElement;\n    if (OriginalHTMLShadowElement) registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);\n    scope.wrappers.HTMLShadowElement = HTMLShadowElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var contentTable = new WeakMap();\n    var templateContentsOwnerTable = new WeakMap();\n    function getTemplateContentsOwner(doc) {\n      if (!doc.defaultView) return doc;\n      var d = templateContentsOwnerTable.get(doc);\n      if (!d) {\n        d = doc.implementation.createHTMLDocument("");\n        while (d.lastChild) {\n          d.removeChild(d.lastChild);\n        }\n        templateContentsOwnerTable.set(doc, d);\n      }\n      return d;\n    }\n    function extractContent(templateElement) {\n      var doc = getTemplateContentsOwner(templateElement.ownerDocument);\n      var df = unwrap(doc.createDocumentFragment());\n      var child;\n      while (child = templateElement.firstChild) {\n        df.appendChild(child);\n      }\n      return df;\n    }\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n    function HTMLTemplateElement(node) {\n      HTMLElement.call(this, node);\n      if (!OriginalHTMLTemplateElement) {\n        var content = extractContent(node);\n        contentTable.set(this, wrap(content));\n      }\n    }\n    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTemplateElement.prototype, {\n      constructor: HTMLTemplateElement,\n      get content() {\n        if (OriginalHTMLTemplateElement) return wrap(unsafeUnwrap(this).content);\n        return contentTable.get(this);\n      }\n    });\n    if (OriginalHTMLTemplateElement) registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);\n    scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLMediaElement = window.HTMLMediaElement;\n    if (!OriginalHTMLMediaElement) return;\n    function HTMLMediaElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement, document.createElement("audio"));\n    scope.wrappers.HTMLMediaElement = HTMLMediaElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLMediaElement = scope.wrappers.HTMLMediaElement;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var rewrap = scope.rewrap;\n    var OriginalHTMLAudioElement = window.HTMLAudioElement;\n    if (!OriginalHTMLAudioElement) return;\n    function HTMLAudioElement(node) {\n      HTMLMediaElement.call(this, node);\n    }\n    HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);\n    registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement, document.createElement("audio"));\n    function Audio(src) {\n      if (!(this instanceof Audio)) {\n        throw new TypeError("DOM object constructor cannot be called as a function.");\n      }\n      var node = unwrap(document.createElement("audio"));\n      HTMLMediaElement.call(this, node);\n      rewrap(node, this);\n      node.setAttribute("preload", "auto");\n      if (src !== undefined) node.setAttribute("src", src);\n    }\n    Audio.prototype = HTMLAudioElement.prototype;\n    scope.wrappers.HTMLAudioElement = HTMLAudioElement;\n    scope.wrappers.Audio = Audio;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var rewrap = scope.rewrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLOptionElement = window.HTMLOptionElement;\n    function trimText(s) {\n      return s.replace(/\\s+/g, " ").trim();\n    }\n    function HTMLOptionElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLOptionElement.prototype, {\n      get text() {\n        return trimText(this.textContent);\n      },\n      set text(value) {\n        this.textContent = trimText(String(value));\n      },\n      get form() {\n        return wrap(unwrap(this).form);\n      }\n    });\n    registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement, document.createElement("option"));\n    function Option(text, value, defaultSelected, selected) {\n      if (!(this instanceof Option)) {\n        throw new TypeError("DOM object constructor cannot be called as a function.");\n      }\n      var node = unwrap(document.createElement("option"));\n      HTMLElement.call(this, node);\n      rewrap(node, this);\n      if (text !== undefined) node.text = text;\n      if (value !== undefined) node.setAttribute("value", value);\n      if (defaultSelected === true) node.setAttribute("selected", "");\n      node.selected = selected === true;\n    }\n    Option.prototype = HTMLOptionElement.prototype;\n    scope.wrappers.HTMLOptionElement = HTMLOptionElement;\n    scope.wrappers.Option = Option;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLSelectElement = window.HTMLSelectElement;\n    function HTMLSelectElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLSelectElement.prototype, {\n      add: function(element, before) {\n        if (typeof before === "object") before = unwrap(before);\n        unwrap(this).add(unwrap(element), before);\n      },\n      remove: function(indexOrNode) {\n        if (indexOrNode === undefined) {\n          HTMLElement.prototype.remove.call(this);\n          return;\n        }\n        if (typeof indexOrNode === "object") indexOrNode = unwrap(indexOrNode);\n        unwrap(this).remove(indexOrNode);\n      },\n      get form() {\n        return wrap(unwrap(this).form);\n      }\n    });\n    registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement, document.createElement("select"));\n    scope.wrappers.HTMLSelectElement = HTMLSelectElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var OriginalHTMLTableElement = window.HTMLTableElement;\n    function HTMLTableElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableElement.prototype, {\n      get caption() {\n        return wrap(unwrap(this).caption);\n      },\n      createCaption: function() {\n        return wrap(unwrap(this).createCaption());\n      },\n      get tHead() {\n        return wrap(unwrap(this).tHead);\n      },\n      createTHead: function() {\n        return wrap(unwrap(this).createTHead());\n      },\n      createTFoot: function() {\n        return wrap(unwrap(this).createTFoot());\n      },\n      get tFoot() {\n        return wrap(unwrap(this).tFoot);\n      },\n      get tBodies() {\n        return wrapHTMLCollection(unwrap(this).tBodies);\n      },\n      createTBody: function() {\n        return wrap(unwrap(this).createTBody());\n      },\n      get rows() {\n        return wrapHTMLCollection(unwrap(this).rows);\n      },\n      insertRow: function(index) {\n        return wrap(unwrap(this).insertRow(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableElement, HTMLTableElement, document.createElement("table"));\n    scope.wrappers.HTMLTableElement = HTMLTableElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;\n    function HTMLTableSectionElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableSectionElement.prototype, {\n      constructor: HTMLTableSectionElement,\n      get rows() {\n        return wrapHTMLCollection(unwrap(this).rows);\n      },\n      insertRow: function(index) {\n        return wrap(unwrap(this).insertRow(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement, document.createElement("thead"));\n    scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLTableRowElement = window.HTMLTableRowElement;\n    function HTMLTableRowElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableRowElement.prototype, {\n      get cells() {\n        return wrapHTMLCollection(unwrap(this).cells);\n      },\n      insertCell: function(index) {\n        return wrap(unwrap(this).insertCell(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement, document.createElement("tr"));\n    scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n    var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLUnknownElement = window.HTMLUnknownElement;\n    function HTMLUnknownElement(node) {\n      switch (node.localName) {\n       case "content":\n        return new HTMLContentElement(node);\n\n       case "shadow":\n        return new HTMLShadowElement(node);\n\n       case "template":\n        return new HTMLTemplateElement(node);\n      }\n      HTMLElement.call(this, node);\n    }\n    HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);\n    scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var Element = scope.wrappers.Element;\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var mixin = scope.mixin;\n    var SVG_NS = "http://www.w3.org/2000/svg";\n    var OriginalSVGElement = window.SVGElement;\n    var svgTitleElement = document.createElementNS(SVG_NS, "title");\n    if (!("classList" in svgTitleElement)) {\n      var descr = Object.getOwnPropertyDescriptor(Element.prototype, "classList");\n      Object.defineProperty(HTMLElement.prototype, "classList", descr);\n      delete Element.prototype.classList;\n    }\n    function SVGElement(node) {\n      Element.call(this, node);\n    }\n    SVGElement.prototype = Object.create(Element.prototype);\n    mixin(SVGElement.prototype, {\n      get ownerSVGElement() {\n        return wrap(unsafeUnwrap(this).ownerSVGElement);\n      }\n    });\n    registerWrapper(OriginalSVGElement, SVGElement, document.createElementNS(SVG_NS, "title"));\n    scope.wrappers.SVGElement = SVGElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalSVGUseElement = window.SVGUseElement;\n    var SVG_NS = "http://www.w3.org/2000/svg";\n    var gWrapper = wrap(document.createElementNS(SVG_NS, "g"));\n    var useElement = document.createElementNS(SVG_NS, "use");\n    var SVGGElement = gWrapper.constructor;\n    var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);\n    var parentInterface = parentInterfacePrototype.constructor;\n    function SVGUseElement(impl) {\n      parentInterface.call(this, impl);\n    }\n    SVGUseElement.prototype = Object.create(parentInterfacePrototype);\n    if ("instanceRoot" in useElement) {\n      mixin(SVGUseElement.prototype, {\n        get instanceRoot() {\n          return wrap(unwrap(this).instanceRoot);\n        },\n        get animatedInstanceRoot() {\n          return wrap(unwrap(this).animatedInstanceRoot);\n        }\n      });\n    }\n    registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);\n    scope.wrappers.SVGUseElement = SVGUseElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var EventTarget = scope.wrappers.EventTarget;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalSVGElementInstance = window.SVGElementInstance;\n    if (!OriginalSVGElementInstance) return;\n    function SVGElementInstance(impl) {\n      EventTarget.call(this, impl);\n    }\n    SVGElementInstance.prototype = Object.create(EventTarget.prototype);\n    mixin(SVGElementInstance.prototype, {\n      get correspondingElement() {\n        return wrap(unsafeUnwrap(this).correspondingElement);\n      },\n      get correspondingUseElement() {\n        return wrap(unsafeUnwrap(this).correspondingUseElement);\n      },\n      get parentNode() {\n        return wrap(unsafeUnwrap(this).parentNode);\n      },\n      get childNodes() {\n        throw new Error("Not implemented");\n      },\n      get firstChild() {\n        return wrap(unsafeUnwrap(this).firstChild);\n      },\n      get lastChild() {\n        return wrap(unsafeUnwrap(this).lastChild);\n      },\n      get previousSibling() {\n        return wrap(unsafeUnwrap(this).previousSibling);\n      },\n      get nextSibling() {\n        return wrap(unsafeUnwrap(this).nextSibling);\n      }\n    });\n    registerWrapper(OriginalSVGElementInstance, SVGElementInstance);\n    scope.wrappers.SVGElementInstance = SVGElementInstance;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;\n    function CanvasRenderingContext2D(impl) {\n      setWrapper(impl, this);\n    }\n    mixin(CanvasRenderingContext2D.prototype, {\n      get canvas() {\n        return wrap(unsafeUnwrap(this).canvas);\n      },\n      drawImage: function() {\n        arguments[0] = unwrapIfNeeded(arguments[0]);\n        unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);\n      },\n      createPattern: function() {\n        arguments[0] = unwrap(arguments[0]);\n        return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);\n      }\n    });\n    registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D, document.createElement("canvas").getContext("2d"));\n    scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var addForwardingProperties = scope.addForwardingProperties;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalWebGLRenderingContext = window.WebGLRenderingContext;\n    if (!OriginalWebGLRenderingContext) return;\n    function WebGLRenderingContext(impl) {\n      setWrapper(impl, this);\n    }\n    mixin(WebGLRenderingContext.prototype, {\n      get canvas() {\n        return wrap(unsafeUnwrap(this).canvas);\n      },\n      texImage2D: function() {\n        arguments[5] = unwrapIfNeeded(arguments[5]);\n        unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);\n      },\n      texSubImage2D: function() {\n        arguments[6] = unwrapIfNeeded(arguments[6]);\n        unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);\n      }\n    });\n    var OriginalWebGLRenderingContextBase = Object.getPrototypeOf(OriginalWebGLRenderingContext.prototype);\n    if (OriginalWebGLRenderingContextBase !== Object.prototype) {\n      addForwardingProperties(OriginalWebGLRenderingContextBase, WebGLRenderingContext.prototype);\n    }\n    var instanceProperties = /WebKit/.test(navigator.userAgent) ? {\n      drawingBufferHeight: null,\n      drawingBufferWidth: null\n    } : {};\n    registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext, instanceProperties);\n    scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var Node = scope.wrappers.Node;\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var mixin = scope.mixin;\n    var registerObject = scope.registerObject;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalDocumentFragment = window.DocumentFragment;\n    function DocumentFragment(node) {\n      Node.call(this, node);\n    }\n    DocumentFragment.prototype = Object.create(Node.prototype);\n    mixin(DocumentFragment.prototype, ParentNodeInterface);\n    mixin(DocumentFragment.prototype, SelectorsInterface);\n    mixin(DocumentFragment.prototype, GetElementsByInterface);\n    mixin(DocumentFragment.prototype, NonElementParentNodeInterface);\n    registerWrapper(OriginalDocumentFragment, DocumentFragment, document.createDocumentFragment());\n    scope.wrappers.DocumentFragment = DocumentFragment;\n    var Comment = registerObject(document.createComment(""));\n    scope.wrappers.Comment = Comment;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var DocumentFragment = scope.wrappers.DocumentFragment;\n    var TreeScope = scope.TreeScope;\n    var elementFromPoint = scope.elementFromPoint;\n    var getInnerHTML = scope.getInnerHTML;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var rewrap = scope.rewrap;\n    var setInnerHTML = scope.setInnerHTML;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var shadowHostTable = new WeakMap();\n    var nextOlderShadowTreeTable = new WeakMap();\n    function ShadowRoot(hostWrapper) {\n      var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());\n      DocumentFragment.call(this, node);\n      rewrap(node, this);\n      var oldShadowRoot = hostWrapper.shadowRoot;\n      nextOlderShadowTreeTable.set(this, oldShadowRoot);\n      this.treeScope_ = new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));\n      shadowHostTable.set(this, hostWrapper);\n    }\n    ShadowRoot.prototype = Object.create(DocumentFragment.prototype);\n    mixin(ShadowRoot.prototype, {\n      constructor: ShadowRoot,\n      get innerHTML() {\n        return getInnerHTML(this);\n      },\n      set innerHTML(value) {\n        setInnerHTML(this, value);\n        this.invalidateShadowRenderer();\n      },\n      get olderShadowRoot() {\n        return nextOlderShadowTreeTable.get(this) || null;\n      },\n      get host() {\n        return shadowHostTable.get(this) || null;\n      },\n      invalidateShadowRenderer: function() {\n        return shadowHostTable.get(this).invalidateShadowRenderer();\n      },\n      elementFromPoint: function(x, y) {\n        return elementFromPoint(this, this.ownerDocument, x, y);\n      },\n      getSelection: function() {\n        return document.getSelection();\n      },\n      get activeElement() {\n        var unwrappedActiveElement = unwrap(this).ownerDocument.activeElement;\n        if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType) return null;\n        var activeElement = wrap(unwrappedActiveElement);\n        while (!this.contains(activeElement)) {\n          while (activeElement.parentNode) {\n            activeElement = activeElement.parentNode;\n          }\n          if (activeElement.host) {\n            activeElement = activeElement.host;\n          } else {\n            return null;\n          }\n        }\n        return activeElement;\n      }\n    });\n    scope.wrappers.ShadowRoot = ShadowRoot;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var getTreeScope = scope.getTreeScope;\n    var OriginalRange = window.Range;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    function getHost(node) {\n      var root = getTreeScope(node).root;\n      if (root instanceof ShadowRoot) {\n        return root.host;\n      }\n      return null;\n    }\n    function hostNodeToShadowNode(refNode, offset) {\n      if (refNode.shadowRoot) {\n        offset = Math.min(refNode.childNodes.length - 1, offset);\n        var child = refNode.childNodes[offset];\n        if (child) {\n          var insertionPoint = scope.getDestinationInsertionPoints(child);\n          if (insertionPoint.length > 0) {\n            var parentNode = insertionPoint[0].parentNode;\n            if (parentNode.nodeType == Node.ELEMENT_NODE) {\n              refNode = parentNode;\n            }\n          }\n        }\n      }\n      return refNode;\n    }\n    function shadowNodeToHostNode(node) {\n      node = wrap(node);\n      return getHost(node) || node;\n    }\n    function Range(impl) {\n      setWrapper(impl, this);\n    }\n    Range.prototype = {\n      get startContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).startContainer);\n      },\n      get endContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).endContainer);\n      },\n      get commonAncestorContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).commonAncestorContainer);\n      },\n      setStart: function(refNode, offset) {\n        refNode = hostNodeToShadowNode(refNode, offset);\n        unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);\n      },\n      setEnd: function(refNode, offset) {\n        refNode = hostNodeToShadowNode(refNode, offset);\n        unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);\n      },\n      setStartBefore: function(refNode) {\n        unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));\n      },\n      setStartAfter: function(refNode) {\n        unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));\n      },\n      setEndBefore: function(refNode) {\n        unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));\n      },\n      setEndAfter: function(refNode) {\n        unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));\n      },\n      selectNode: function(refNode) {\n        unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));\n      },\n      selectNodeContents: function(refNode) {\n        unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));\n      },\n      compareBoundaryPoints: function(how, sourceRange) {\n        return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));\n      },\n      extractContents: function() {\n        return wrap(unsafeUnwrap(this).extractContents());\n      },\n      cloneContents: function() {\n        return wrap(unsafeUnwrap(this).cloneContents());\n      },\n      insertNode: function(node) {\n        unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));\n      },\n      surroundContents: function(newParent) {\n        unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));\n      },\n      cloneRange: function() {\n        return wrap(unsafeUnwrap(this).cloneRange());\n      },\n      isPointInRange: function(node, offset) {\n        return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);\n      },\n      comparePoint: function(node, offset) {\n        return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);\n      },\n      intersectsNode: function(node) {\n        return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));\n      },\n      toString: function() {\n        return unsafeUnwrap(this).toString();\n      }\n    };\n    if (OriginalRange.prototype.createContextualFragment) {\n      Range.prototype.createContextualFragment = function(html) {\n        return wrap(unsafeUnwrap(this).createContextualFragment(html));\n      };\n    }\n    registerWrapper(window.Range, Range, document.createRange());\n    scope.wrappers.Range = Range;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var Element = scope.wrappers.Element;\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n    var Node = scope.wrappers.Node;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    var assert = scope.assert;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var oneOf = scope.oneOf;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var ArraySplice = scope.ArraySplice;\n    function updateWrapperUpAndSideways(wrapper) {\n      wrapper.previousSibling_ = wrapper.previousSibling;\n      wrapper.nextSibling_ = wrapper.nextSibling;\n      wrapper.parentNode_ = wrapper.parentNode;\n    }\n    function updateWrapperDown(wrapper) {\n      wrapper.firstChild_ = wrapper.firstChild;\n      wrapper.lastChild_ = wrapper.lastChild;\n    }\n    function updateAllChildNodes(parentNodeWrapper) {\n      assert(parentNodeWrapper instanceof Node);\n      for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {\n        updateWrapperUpAndSideways(childWrapper);\n      }\n      updateWrapperDown(parentNodeWrapper);\n    }\n    function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {\n      var parentNode = unwrap(parentNodeWrapper);\n      var newChild = unwrap(newChildWrapper);\n      var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;\n      remove(newChildWrapper);\n      updateWrapperUpAndSideways(newChildWrapper);\n      if (!refChildWrapper) {\n        parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;\n        if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;\n        var lastChildWrapper = wrap(parentNode.lastChild);\n        if (lastChildWrapper) lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;\n      } else {\n        if (parentNodeWrapper.firstChild === refChildWrapper) parentNodeWrapper.firstChild_ = refChildWrapper;\n        refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;\n      }\n      scope.originalInsertBefore.call(parentNode, newChild, refChild);\n    }\n    function remove(nodeWrapper) {\n      var node = unwrap(nodeWrapper);\n      var parentNode = node.parentNode;\n      if (!parentNode) return;\n      var parentNodeWrapper = wrap(parentNode);\n      updateWrapperUpAndSideways(nodeWrapper);\n      if (nodeWrapper.previousSibling) nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;\n      if (nodeWrapper.nextSibling) nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;\n      if (parentNodeWrapper.lastChild === nodeWrapper) parentNodeWrapper.lastChild_ = nodeWrapper;\n      if (parentNodeWrapper.firstChild === nodeWrapper) parentNodeWrapper.firstChild_ = nodeWrapper;\n      scope.originalRemoveChild.call(parentNode, node);\n    }\n    var distributedNodesTable = new WeakMap();\n    var destinationInsertionPointsTable = new WeakMap();\n    var rendererForHostTable = new WeakMap();\n    function resetDistributedNodes(insertionPoint) {\n      distributedNodesTable.set(insertionPoint, []);\n    }\n    function getDistributedNodes(insertionPoint) {\n      var rv = distributedNodesTable.get(insertionPoint);\n      if (!rv) distributedNodesTable.set(insertionPoint, rv = []);\n      return rv;\n    }\n    function getChildNodesSnapshot(node) {\n      var result = [], i = 0;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        result[i++] = child;\n      }\n      return result;\n    }\n    var request = oneOf(window, [ "requestAnimationFrame", "mozRequestAnimationFrame", "webkitRequestAnimationFrame", "setTimeout" ]);\n    var pendingDirtyRenderers = [];\n    var renderTimer;\n    function renderAllPending() {\n      for (var i = 0; i < pendingDirtyRenderers.length; i++) {\n        var renderer = pendingDirtyRenderers[i];\n        var parentRenderer = renderer.parentRenderer;\n        if (parentRenderer && parentRenderer.dirty) continue;\n        renderer.render();\n      }\n      pendingDirtyRenderers = [];\n    }\n    function handleRequestAnimationFrame() {\n      renderTimer = null;\n      renderAllPending();\n    }\n    function getRendererForHost(host) {\n      var renderer = rendererForHostTable.get(host);\n      if (!renderer) {\n        renderer = new ShadowRenderer(host);\n        rendererForHostTable.set(host, renderer);\n      }\n      return renderer;\n    }\n    function getShadowRootAncestor(node) {\n      var root = getTreeScope(node).root;\n      if (root instanceof ShadowRoot) return root;\n      return null;\n    }\n    function getRendererForShadowRoot(shadowRoot) {\n      return getRendererForHost(shadowRoot.host);\n    }\n    var spliceDiff = new ArraySplice();\n    spliceDiff.equals = function(renderNode, rawNode) {\n      return unwrap(renderNode.node) === rawNode;\n    };\n    function RenderNode(node) {\n      this.skip = false;\n      this.node = node;\n      this.childNodes = [];\n    }\n    RenderNode.prototype = {\n      append: function(node) {\n        var rv = new RenderNode(node);\n        this.childNodes.push(rv);\n        return rv;\n      },\n      sync: function(opt_added) {\n        if (this.skip) return;\n        var nodeWrapper = this.node;\n        var newChildren = this.childNodes;\n        var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));\n        var added = opt_added || new WeakMap();\n        var splices = spliceDiff.calculateSplices(newChildren, oldChildren);\n        var newIndex = 0, oldIndex = 0;\n        var lastIndex = 0;\n        for (var i = 0; i < splices.length; i++) {\n          var splice = splices[i];\n          for (;lastIndex < splice.index; lastIndex++) {\n            oldIndex++;\n            newChildren[newIndex++].sync(added);\n          }\n          var removedCount = splice.removed.length;\n          for (var j = 0; j < removedCount; j++) {\n            var wrapper = wrap(oldChildren[oldIndex++]);\n            if (!added.get(wrapper)) remove(wrapper);\n          }\n          var addedCount = splice.addedCount;\n          var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);\n          for (var j = 0; j < addedCount; j++) {\n            var newChildRenderNode = newChildren[newIndex++];\n            var newChildWrapper = newChildRenderNode.node;\n            insertBefore(nodeWrapper, newChildWrapper, refNode);\n            added.set(newChildWrapper, true);\n            newChildRenderNode.sync(added);\n          }\n          lastIndex += addedCount;\n        }\n        for (var i = lastIndex; i < newChildren.length; i++) {\n          newChildren[i].sync(added);\n        }\n      }\n    };\n    function ShadowRenderer(host) {\n      this.host = host;\n      this.dirty = false;\n      this.invalidateAttributes();\n      this.associateNode(host);\n    }\n    ShadowRenderer.prototype = {\n      render: function(opt_renderNode) {\n        if (!this.dirty) return;\n        this.invalidateAttributes();\n        var host = this.host;\n        this.distribution(host);\n        var renderNode = opt_renderNode || new RenderNode(host);\n        this.buildRenderTree(renderNode, host);\n        var topMostRenderer = !opt_renderNode;\n        if (topMostRenderer) renderNode.sync();\n        this.dirty = false;\n      },\n      get parentRenderer() {\n        return getTreeScope(this.host).renderer;\n      },\n      invalidate: function() {\n        if (!this.dirty) {\n          this.dirty = true;\n          var parentRenderer = this.parentRenderer;\n          if (parentRenderer) parentRenderer.invalidate();\n          pendingDirtyRenderers.push(this);\n          if (renderTimer) return;\n          renderTimer = window[request](handleRequestAnimationFrame, 0);\n        }\n      },\n      distribution: function(root) {\n        this.resetAllSubtrees(root);\n        this.distributionResolution(root);\n      },\n      resetAll: function(node) {\n        if (isInsertionPoint(node)) resetDistributedNodes(node); else resetDestinationInsertionPoints(node);\n        this.resetAllSubtrees(node);\n      },\n      resetAllSubtrees: function(node) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.resetAll(child);\n        }\n        if (node.shadowRoot) this.resetAll(node.shadowRoot);\n        if (node.olderShadowRoot) this.resetAll(node.olderShadowRoot);\n      },\n      distributionResolution: function(node) {\n        if (isShadowHost(node)) {\n          var shadowHost = node;\n          var pool = poolPopulation(shadowHost);\n          var shadowTrees = getShadowTrees(shadowHost);\n          for (var i = 0; i < shadowTrees.length; i++) {\n            this.poolDistribution(shadowTrees[i], pool);\n          }\n          for (var i = shadowTrees.length - 1; i >= 0; i--) {\n            var shadowTree = shadowTrees[i];\n            var shadow = getShadowInsertionPoint(shadowTree);\n            if (shadow) {\n              var olderShadowRoot = shadowTree.olderShadowRoot;\n              if (olderShadowRoot) {\n                pool = poolPopulation(olderShadowRoot);\n              }\n              for (var j = 0; j < pool.length; j++) {\n                destributeNodeInto(pool[j], shadow);\n              }\n            }\n            this.distributionResolution(shadowTree);\n          }\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.distributionResolution(child);\n        }\n      },\n      poolDistribution: function(node, pool) {\n        if (node instanceof HTMLShadowElement) return;\n        if (node instanceof HTMLContentElement) {\n          var content = node;\n          this.updateDependentAttributes(content.getAttribute("select"));\n          var anyDistributed = false;\n          for (var i = 0; i < pool.length; i++) {\n            var node = pool[i];\n            if (!node) continue;\n            if (matches(node, content)) {\n              destributeNodeInto(node, content);\n              pool[i] = undefined;\n              anyDistributed = true;\n            }\n          }\n          if (!anyDistributed) {\n            for (var child = content.firstChild; child; child = child.nextSibling) {\n              destributeNodeInto(child, content);\n            }\n          }\n          return;\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.poolDistribution(child, pool);\n        }\n      },\n      buildRenderTree: function(renderNode, node) {\n        var children = this.compose(node);\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          var childRenderNode = renderNode.append(child);\n          this.buildRenderTree(childRenderNode, child);\n        }\n        if (isShadowHost(node)) {\n          var renderer = getRendererForHost(node);\n          renderer.dirty = false;\n        }\n      },\n      compose: function(node) {\n        var children = [];\n        var p = node.shadowRoot || node;\n        for (var child = p.firstChild; child; child = child.nextSibling) {\n          if (isInsertionPoint(child)) {\n            this.associateNode(p);\n            var distributedNodes = getDistributedNodes(child);\n            for (var j = 0; j < distributedNodes.length; j++) {\n              var distributedNode = distributedNodes[j];\n              if (isFinalDestination(child, distributedNode)) children.push(distributedNode);\n            }\n          } else {\n            children.push(child);\n          }\n        }\n        return children;\n      },\n      invalidateAttributes: function() {\n        this.attributes = Object.create(null);\n      },\n      updateDependentAttributes: function(selector) {\n        if (!selector) return;\n        var attributes = this.attributes;\n        if (/\\.\\w+/.test(selector)) attributes["class"] = true;\n        if (/#\\w+/.test(selector)) attributes["id"] = true;\n        selector.replace(/\\[\\s*([^\\s=\\|~\\]]+)/g, function(_, name) {\n          attributes[name] = true;\n        });\n      },\n      dependsOnAttribute: function(name) {\n        return this.attributes[name];\n      },\n      associateNode: function(node) {\n        unsafeUnwrap(node).polymerShadowRenderer_ = this;\n      }\n    };\n    function poolPopulation(node) {\n      var pool = [];\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        if (isInsertionPoint(child)) {\n          pool.push.apply(pool, getDistributedNodes(child));\n        } else {\n          pool.push(child);\n        }\n      }\n      return pool;\n    }\n    function getShadowInsertionPoint(node) {\n      if (node instanceof HTMLShadowElement) return node;\n      if (node instanceof HTMLContentElement) return null;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        var res = getShadowInsertionPoint(child);\n        if (res) return res;\n      }\n      return null;\n    }\n    function destributeNodeInto(child, insertionPoint) {\n      getDistributedNodes(insertionPoint).push(child);\n      var points = destinationInsertionPointsTable.get(child);\n      if (!points) destinationInsertionPointsTable.set(child, [ insertionPoint ]); else points.push(insertionPoint);\n    }\n    function getDestinationInsertionPoints(node) {\n      return destinationInsertionPointsTable.get(node);\n    }\n    function resetDestinationInsertionPoints(node) {\n      destinationInsertionPointsTable.set(node, undefined);\n    }\n    var selectorStartCharRe = /^(:not\\()?[*.#[a-zA-Z_|]/;\n    function matches(node, contentElement) {\n      var select = contentElement.getAttribute("select");\n      if (!select) return true;\n      select = select.trim();\n      if (!select) return true;\n      if (!(node instanceof Element)) return false;\n      if (!selectorStartCharRe.test(select)) return false;\n      try {\n        return node.matches(select);\n      } catch (ex) {\n        return false;\n      }\n    }\n    function isFinalDestination(insertionPoint, node) {\n      var points = getDestinationInsertionPoints(node);\n      return points && points[points.length - 1] === insertionPoint;\n    }\n    function isInsertionPoint(node) {\n      return node instanceof HTMLContentElement || node instanceof HTMLShadowElement;\n    }\n    function isShadowHost(shadowHost) {\n      return shadowHost.shadowRoot;\n    }\n    function getShadowTrees(host) {\n      var trees = [];\n      for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {\n        trees.push(tree);\n      }\n      return trees;\n    }\n    function render(host) {\n      new ShadowRenderer(host).render();\n    }\n    Node.prototype.invalidateShadowRenderer = function(force) {\n      var renderer = unsafeUnwrap(this).polymerShadowRenderer_;\n      if (renderer) {\n        renderer.invalidate();\n        return true;\n      }\n      return false;\n    };\n    HTMLContentElement.prototype.getDistributedNodes = HTMLShadowElement.prototype.getDistributedNodes = function() {\n      renderAllPending();\n      return getDistributedNodes(this);\n    };\n    Element.prototype.getDestinationInsertionPoints = function() {\n      renderAllPending();\n      return getDestinationInsertionPoints(this) || [];\n    };\n    HTMLContentElement.prototype.nodeIsInserted_ = HTMLShadowElement.prototype.nodeIsInserted_ = function() {\n      this.invalidateShadowRenderer();\n      var shadowRoot = getShadowRootAncestor(this);\n      var renderer;\n      if (shadowRoot) renderer = getRendererForShadowRoot(shadowRoot);\n      unsafeUnwrap(this).polymerShadowRenderer_ = renderer;\n      if (renderer) renderer.invalidate();\n    };\n    scope.getRendererForHost = getRendererForHost;\n    scope.getShadowTrees = getShadowTrees;\n    scope.renderAllPending = renderAllPending;\n    scope.getDestinationInsertionPoints = getDestinationInsertionPoints;\n    scope.visual = {\n      insertBefore: insertBefore,\n      remove: remove\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var assert = scope.assert;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var elementsWithFormProperty = [ "HTMLButtonElement", "HTMLFieldSetElement", "HTMLInputElement", "HTMLKeygenElement", "HTMLLabelElement", "HTMLLegendElement", "HTMLObjectElement", "HTMLOutputElement", "HTMLTextAreaElement" ];\n    function createWrapperConstructor(name) {\n      if (!window[name]) return;\n      assert(!scope.wrappers[name]);\n      var GeneratedWrapper = function(node) {\n        HTMLElement.call(this, node);\n      };\n      GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);\n      mixin(GeneratedWrapper.prototype, {\n        get form() {\n          return wrap(unwrap(this).form);\n        }\n      });\n      registerWrapper(window[name], GeneratedWrapper, document.createElement(name.slice(4, -7)));\n      scope.wrappers[name] = GeneratedWrapper;\n    }\n    elementsWithFormProperty.forEach(createWrapperConstructor);\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalSelection = window.Selection;\n    function Selection(impl) {\n      setWrapper(impl, this);\n    }\n    Selection.prototype = {\n      get anchorNode() {\n        return wrap(unsafeUnwrap(this).anchorNode);\n      },\n      get focusNode() {\n        return wrap(unsafeUnwrap(this).focusNode);\n      },\n      addRange: function(range) {\n        unsafeUnwrap(this).addRange(unwrapIfNeeded(range));\n      },\n      collapse: function(node, index) {\n        unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);\n      },\n      containsNode: function(node, allowPartial) {\n        return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);\n      },\n      getRangeAt: function(index) {\n        return wrap(unsafeUnwrap(this).getRangeAt(index));\n      },\n      removeRange: function(range) {\n        unsafeUnwrap(this).removeRange(unwrap(range));\n      },\n      selectAllChildren: function(node) {\n        unsafeUnwrap(this).selectAllChildren(node instanceof ShadowRoot ? unsafeUnwrap(node.host) : unwrapIfNeeded(node));\n      },\n      toString: function() {\n        return unsafeUnwrap(this).toString();\n      }\n    };\n    if (OriginalSelection.prototype.extend) {\n      Selection.prototype.extend = function(node, offset) {\n        unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);\n      };\n    }\n    registerWrapper(window.Selection, Selection, window.getSelection());\n    scope.wrappers.Selection = Selection;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalTreeWalker = window.TreeWalker;\n    function TreeWalker(impl) {\n      setWrapper(impl, this);\n    }\n    TreeWalker.prototype = {\n      get root() {\n        return wrap(unsafeUnwrap(this).root);\n      },\n      get currentNode() {\n        return wrap(unsafeUnwrap(this).currentNode);\n      },\n      set currentNode(node) {\n        unsafeUnwrap(this).currentNode = unwrapIfNeeded(node);\n      },\n      get filter() {\n        return unsafeUnwrap(this).filter;\n      },\n      parentNode: function() {\n        return wrap(unsafeUnwrap(this).parentNode());\n      },\n      firstChild: function() {\n        return wrap(unsafeUnwrap(this).firstChild());\n      },\n      lastChild: function() {\n        return wrap(unsafeUnwrap(this).lastChild());\n      },\n      previousSibling: function() {\n        return wrap(unsafeUnwrap(this).previousSibling());\n      },\n      previousNode: function() {\n        return wrap(unsafeUnwrap(this).previousNode());\n      },\n      nextNode: function() {\n        return wrap(unsafeUnwrap(this).nextNode());\n      }\n    };\n    registerWrapper(OriginalTreeWalker, TreeWalker);\n    scope.wrappers.TreeWalker = TreeWalker;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var Node = scope.wrappers.Node;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n    var Selection = scope.wrappers.Selection;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    var TreeScope = scope.TreeScope;\n    var cloneNode = scope.cloneNode;\n    var defineGetter = scope.defineGetter;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var elementFromPoint = scope.elementFromPoint;\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n    var matchesNames = scope.matchesNames;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var renderAllPending = scope.renderAllPending;\n    var rewrap = scope.rewrap;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrapEventTargetMethods = scope.wrapEventTargetMethods;\n    var wrapNodeList = scope.wrapNodeList;\n    var implementationTable = new WeakMap();\n    function Document(node) {\n      Node.call(this, node);\n      this.treeScope_ = new TreeScope(this, null);\n    }\n    Document.prototype = Object.create(Node.prototype);\n    defineWrapGetter(Document, "documentElement");\n    defineWrapGetter(Document, "body");\n    defineWrapGetter(Document, "head");\n    defineGetter(Document, "activeElement", function() {\n      var unwrappedActiveElement = unwrap(this).activeElement;\n      if (!unwrappedActiveElement || !unwrappedActiveElement.nodeType) return null;\n      var activeElement = wrap(unwrappedActiveElement);\n      while (!this.contains(activeElement)) {\n        while (activeElement.parentNode) {\n          activeElement = activeElement.parentNode;\n        }\n        if (activeElement.host) {\n          activeElement = activeElement.host;\n        } else {\n          return null;\n        }\n      }\n      return activeElement;\n    });\n    function wrapMethod(name) {\n      var original = document[name];\n      Document.prototype[name] = function() {\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    [ "createComment", "createDocumentFragment", "createElement", "createElementNS", "createEvent", "createEventNS", "createRange", "createTextNode" ].forEach(wrapMethod);\n    var originalAdoptNode = document.adoptNode;\n    function adoptNodeNoRemove(node, doc) {\n      originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));\n      adoptSubtree(node, doc);\n    }\n    function adoptSubtree(node, doc) {\n      if (node.shadowRoot) doc.adoptNode(node.shadowRoot);\n      if (node instanceof ShadowRoot) adoptOlderShadowRoots(node, doc);\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        adoptSubtree(child, doc);\n      }\n    }\n    function adoptOlderShadowRoots(shadowRoot, doc) {\n      var oldShadowRoot = shadowRoot.olderShadowRoot;\n      if (oldShadowRoot) doc.adoptNode(oldShadowRoot);\n    }\n    var originalGetSelection = document.getSelection;\n    mixin(Document.prototype, {\n      adoptNode: function(node) {\n        if (node.parentNode) node.parentNode.removeChild(node);\n        adoptNodeNoRemove(node, this);\n        return node;\n      },\n      elementFromPoint: function(x, y) {\n        return elementFromPoint(this, this, x, y);\n      },\n      importNode: function(node, deep) {\n        return cloneNode(node, deep, unsafeUnwrap(this));\n      },\n      getSelection: function() {\n        renderAllPending();\n        return new Selection(originalGetSelection.call(unwrap(this)));\n      },\n      getElementsByName: function(name) {\n        return SelectorsInterface.querySelectorAll.call(this, "[name=" + JSON.stringify(String(name)) + "]");\n      }\n    });\n    var originalCreateTreeWalker = document.createTreeWalker;\n    var TreeWalkerWrapper = scope.wrappers.TreeWalker;\n    Document.prototype.createTreeWalker = function(root, whatToShow, filter, expandEntityReferences) {\n      var newFilter = null;\n      if (filter) {\n        if (filter.acceptNode && typeof filter.acceptNode === "function") {\n          newFilter = {\n            acceptNode: function(node) {\n              return filter.acceptNode(wrap(node));\n            }\n          };\n        } else if (typeof filter === "function") {\n          newFilter = function(node) {\n            return filter(wrap(node));\n          };\n        }\n      }\n      return new TreeWalkerWrapper(originalCreateTreeWalker.call(unwrap(this), unwrap(root), whatToShow, newFilter, expandEntityReferences));\n    };\n    if (document.registerElement) {\n      var originalRegisterElement = document.registerElement;\n      Document.prototype.registerElement = function(tagName, object) {\n        var prototype, extendsOption;\n        if (object !== undefined) {\n          prototype = object.prototype;\n          extendsOption = object.extends;\n        }\n        if (!prototype) prototype = Object.create(HTMLElement.prototype);\n        if (scope.nativePrototypeTable.get(prototype)) {\n          throw new Error("NotSupportedError");\n        }\n        var proto = Object.getPrototypeOf(prototype);\n        var nativePrototype;\n        var prototypes = [];\n        while (proto) {\n          nativePrototype = scope.nativePrototypeTable.get(proto);\n          if (nativePrototype) break;\n          prototypes.push(proto);\n          proto = Object.getPrototypeOf(proto);\n        }\n        if (!nativePrototype) {\n          throw new Error("NotSupportedError");\n        }\n        var newPrototype = Object.create(nativePrototype);\n        for (var i = prototypes.length - 1; i >= 0; i--) {\n          newPrototype = Object.create(newPrototype);\n        }\n        [ "createdCallback", "attachedCallback", "detachedCallback", "attributeChangedCallback" ].forEach(function(name) {\n          var f = prototype[name];\n          if (!f) return;\n          newPrototype[name] = function() {\n            if (!(wrap(this) instanceof CustomElementConstructor)) {\n              rewrap(this);\n            }\n            f.apply(wrap(this), arguments);\n          };\n        });\n        var p = {\n          prototype: newPrototype\n        };\n        if (extendsOption) p.extends = extendsOption;\n        function CustomElementConstructor(node) {\n          if (!node) {\n            if (extendsOption) {\n              return document.createElement(extendsOption, tagName);\n            } else {\n              return document.createElement(tagName);\n            }\n          }\n          setWrapper(node, this);\n        }\n        CustomElementConstructor.prototype = prototype;\n        CustomElementConstructor.prototype.constructor = CustomElementConstructor;\n        scope.constructorTable.set(newPrototype, CustomElementConstructor);\n        scope.nativePrototypeTable.set(prototype, newPrototype);\n        var nativeConstructor = originalRegisterElement.call(unwrap(this), tagName, p);\n        return CustomElementConstructor;\n      };\n      forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ "registerElement" ]);\n    }\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement, window.HTMLHtmlElement ], [ "appendChild", "compareDocumentPosition", "contains", "getElementsByClassName", "getElementsByTagName", "getElementsByTagNameNS", "insertBefore", "querySelector", "querySelectorAll", "removeChild", "replaceChild" ]);\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLHeadElement, window.HTMLHtmlElement ], matchesNames);\n    forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ "adoptNode", "importNode", "contains", "createComment", "createDocumentFragment", "createElement", "createElementNS", "createEvent", "createEventNS", "createRange", "createTextNode", "createTreeWalker", "elementFromPoint", "getElementById", "getElementsByName", "getSelection" ]);\n    mixin(Document.prototype, GetElementsByInterface);\n    mixin(Document.prototype, ParentNodeInterface);\n    mixin(Document.prototype, SelectorsInterface);\n    mixin(Document.prototype, NonElementParentNodeInterface);\n    mixin(Document.prototype, {\n      get implementation() {\n        var implementation = implementationTable.get(this);\n        if (implementation) return implementation;\n        implementation = new DOMImplementation(unwrap(this).implementation);\n        implementationTable.set(this, implementation);\n        return implementation;\n      },\n      get defaultView() {\n        return wrap(unwrap(this).defaultView);\n      }\n    });\n    registerWrapper(window.Document, Document, document.implementation.createHTMLDocument(""));\n    if (window.HTMLDocument) registerWrapper(window.HTMLDocument, Document);\n    wrapEventTargetMethods([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement ]);\n    function DOMImplementation(impl) {\n      setWrapper(impl, this);\n    }\n    var originalCreateDocument = document.implementation.createDocument;\n    DOMImplementation.prototype.createDocument = function() {\n      arguments[2] = unwrap(arguments[2]);\n      return wrap(originalCreateDocument.apply(unsafeUnwrap(this), arguments));\n    };\n    function wrapImplMethod(constructor, name) {\n      var original = document.implementation[name];\n      constructor.prototype[name] = function() {\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    function forwardImplMethod(constructor, name) {\n      var original = document.implementation[name];\n      constructor.prototype[name] = function() {\n        return original.apply(unsafeUnwrap(this), arguments);\n      };\n    }\n    wrapImplMethod(DOMImplementation, "createDocumentType");\n    wrapImplMethod(DOMImplementation, "createHTMLDocument");\n    forwardImplMethod(DOMImplementation, "hasFeature");\n    registerWrapper(window.DOMImplementation, DOMImplementation);\n    forwardMethodsToWrapper([ window.DOMImplementation ], [ "createDocument", "createDocumentType", "createHTMLDocument", "hasFeature" ]);\n    scope.adoptNodeNoRemove = adoptNodeNoRemove;\n    scope.wrappers.DOMImplementation = DOMImplementation;\n    scope.wrappers.Document = Document;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var EventTarget = scope.wrappers.EventTarget;\n    var Selection = scope.wrappers.Selection;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var renderAllPending = scope.renderAllPending;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalWindow = window.Window;\n    var originalGetComputedStyle = window.getComputedStyle;\n    var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;\n    var originalGetSelection = window.getSelection;\n    function Window(impl) {\n      EventTarget.call(this, impl);\n    }\n    Window.prototype = Object.create(EventTarget.prototype);\n    OriginalWindow.prototype.getComputedStyle = function(el, pseudo) {\n      return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);\n    };\n    if (originalGetDefaultComputedStyle) {\n      OriginalWindow.prototype.getDefaultComputedStyle = function(el, pseudo) {\n        return wrap(this || window).getDefaultComputedStyle(unwrapIfNeeded(el), pseudo);\n      };\n    }\n    OriginalWindow.prototype.getSelection = function() {\n      return wrap(this || window).getSelection();\n    };\n    delete window.getComputedStyle;\n    delete window.getDefaultComputedStyle;\n    delete window.getSelection;\n    [ "addEventListener", "removeEventListener", "dispatchEvent" ].forEach(function(name) {\n      OriginalWindow.prototype[name] = function() {\n        var w = wrap(this || window);\n        return w[name].apply(w, arguments);\n      };\n      delete window[name];\n    });\n    mixin(Window.prototype, {\n      getComputedStyle: function(el, pseudo) {\n        renderAllPending();\n        return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n      },\n      getSelection: function() {\n        renderAllPending();\n        return new Selection(originalGetSelection.call(unwrap(this)));\n      },\n      get document() {\n        return wrap(unwrap(this).document);\n      }\n    });\n    if (originalGetDefaultComputedStyle) {\n      Window.prototype.getDefaultComputedStyle = function(el, pseudo) {\n        renderAllPending();\n        return originalGetDefaultComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n      };\n    }\n    registerWrapper(OriginalWindow, Window, window);\n    scope.wrappers.Window = Window;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var unwrap = scope.unwrap;\n    var OriginalDataTransfer = window.DataTransfer || window.Clipboard;\n    var OriginalDataTransferSetDragImage = OriginalDataTransfer.prototype.setDragImage;\n    if (OriginalDataTransferSetDragImage) {\n      OriginalDataTransfer.prototype.setDragImage = function(image, x, y) {\n        OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);\n      };\n    }\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unwrap = scope.unwrap;\n    var OriginalFormData = window.FormData;\n    if (!OriginalFormData) return;\n    function FormData(formElement) {\n      var impl;\n      if (formElement instanceof OriginalFormData) {\n        impl = formElement;\n      } else {\n        impl = new OriginalFormData(formElement && unwrap(formElement));\n      }\n      setWrapper(impl, this);\n    }\n    registerWrapper(OriginalFormData, FormData, new OriginalFormData());\n    scope.wrappers.FormData = FormData;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var originalSend = XMLHttpRequest.prototype.send;\n    XMLHttpRequest.prototype.send = function(obj) {\n      return originalSend.call(this, unwrapIfNeeded(obj));\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    "use strict";\n    var isWrapperFor = scope.isWrapperFor;\n    var elements = {\n      a: "HTMLAnchorElement",\n      area: "HTMLAreaElement",\n      audio: "HTMLAudioElement",\n      base: "HTMLBaseElement",\n      body: "HTMLBodyElement",\n      br: "HTMLBRElement",\n      button: "HTMLButtonElement",\n      canvas: "HTMLCanvasElement",\n      caption: "HTMLTableCaptionElement",\n      col: "HTMLTableColElement",\n      content: "HTMLContentElement",\n      data: "HTMLDataElement",\n      datalist: "HTMLDataListElement",\n      del: "HTMLModElement",\n      dir: "HTMLDirectoryElement",\n      div: "HTMLDivElement",\n      dl: "HTMLDListElement",\n      embed: "HTMLEmbedElement",\n      fieldset: "HTMLFieldSetElement",\n      font: "HTMLFontElement",\n      form: "HTMLFormElement",\n      frame: "HTMLFrameElement",\n      frameset: "HTMLFrameSetElement",\n      h1: "HTMLHeadingElement",\n      head: "HTMLHeadElement",\n      hr: "HTMLHRElement",\n      html: "HTMLHtmlElement",\n      iframe: "HTMLIFrameElement",\n      img: "HTMLImageElement",\n      input: "HTMLInputElement",\n      keygen: "HTMLKeygenElement",\n      label: "HTMLLabelElement",\n      legend: "HTMLLegendElement",\n      li: "HTMLLIElement",\n      link: "HTMLLinkElement",\n      map: "HTMLMapElement",\n      marquee: "HTMLMarqueeElement",\n      menu: "HTMLMenuElement",\n      menuitem: "HTMLMenuItemElement",\n      meta: "HTMLMetaElement",\n      meter: "HTMLMeterElement",\n      object: "HTMLObjectElement",\n      ol: "HTMLOListElement",\n      optgroup: "HTMLOptGroupElement",\n      option: "HTMLOptionElement",\n      output: "HTMLOutputElement",\n      p: "HTMLParagraphElement",\n      param: "HTMLParamElement",\n      pre: "HTMLPreElement",\n      progress: "HTMLProgressElement",\n      q: "HTMLQuoteElement",\n      script: "HTMLScriptElement",\n      select: "HTMLSelectElement",\n      shadow: "HTMLShadowElement",\n      source: "HTMLSourceElement",\n      span: "HTMLSpanElement",\n      style: "HTMLStyleElement",\n      table: "HTMLTableElement",\n      tbody: "HTMLTableSectionElement",\n      template: "HTMLTemplateElement",\n      textarea: "HTMLTextAreaElement",\n      thead: "HTMLTableSectionElement",\n      time: "HTMLTimeElement",\n      title: "HTMLTitleElement",\n      tr: "HTMLTableRowElement",\n      track: "HTMLTrackElement",\n      ul: "HTMLUListElement",\n      video: "HTMLVideoElement"\n    };\n    function overrideConstructor(tagName) {\n      var nativeConstructorName = elements[tagName];\n      var nativeConstructor = window[nativeConstructorName];\n      if (!nativeConstructor) return;\n      var element = document.createElement(tagName);\n      var wrapperConstructor = element.constructor;\n      window[nativeConstructorName] = wrapperConstructor;\n    }\n    Object.keys(elements).forEach(overrideConstructor);\n    Object.getOwnPropertyNames(scope.wrappers).forEach(function(name) {\n      window[name] = scope.wrappers[name];\n    });\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    var ShadowCSS = {\n      strictStyling: false,\n      registry: {},\n      shimStyling: function(root, name, extendsName) {\n        var scopeStyles = this.prepareRoot(root, name, extendsName);\n        var typeExtension = this.isTypeExtension(extendsName);\n        var scopeSelector = this.makeScopeSelector(name, typeExtension);\n        var cssText = stylesToCssText(scopeStyles, true);\n        cssText = this.scopeCssText(cssText, scopeSelector);\n        if (root) {\n          root.shimmedStyle = cssText;\n        }\n        this.addCssToDocument(cssText, name);\n      },\n      shimStyle: function(style, selector) {\n        return this.shimCssText(style.textContent, selector);\n      },\n      shimCssText: function(cssText, selector) {\n        cssText = this.insertDirectives(cssText);\n        return this.scopeCssText(cssText, selector);\n      },\n      makeScopeSelector: function(name, typeExtension) {\n        if (name) {\n          return typeExtension ? "[is=" + name + "]" : name;\n        }\n        return "";\n      },\n      isTypeExtension: function(extendsName) {\n        return extendsName && extendsName.indexOf("-") < 0;\n      },\n      prepareRoot: function(root, name, extendsName) {\n        var def = this.registerRoot(root, name, extendsName);\n        this.replaceTextInStyles(def.rootStyles, this.insertDirectives);\n        this.removeStyles(root, def.rootStyles);\n        if (this.strictStyling) {\n          this.applyScopeToContent(root, name);\n        }\n        return def.scopeStyles;\n      },\n      removeStyles: function(root, styles) {\n        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\n          s.parentNode.removeChild(s);\n        }\n      },\n      registerRoot: function(root, name, extendsName) {\n        var def = this.registry[name] = {\n          root: root,\n          name: name,\n          extendsName: extendsName\n        };\n        var styles = this.findStyles(root);\n        def.rootStyles = styles;\n        def.scopeStyles = def.rootStyles;\n        var extendee = this.registry[def.extendsName];\n        if (extendee) {\n          def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);\n        }\n        return def;\n      },\n      findStyles: function(root) {\n        if (!root) {\n          return [];\n        }\n        var styles = root.querySelectorAll("style");\n        return Array.prototype.filter.call(styles, function(s) {\n          return !s.hasAttribute(NO_SHIM_ATTRIBUTE);\n        });\n      },\n      applyScopeToContent: function(root, name) {\n        if (root) {\n          Array.prototype.forEach.call(root.querySelectorAll("*"), function(node) {\n            node.setAttribute(name, "");\n          });\n          Array.prototype.forEach.call(root.querySelectorAll("template"), function(template) {\n            this.applyScopeToContent(template.content, name);\n          }, this);\n        }\n      },\n      insertDirectives: function(cssText) {\n        cssText = this.insertPolyfillDirectivesInCssText(cssText);\n        return this.insertPolyfillRulesInCssText(cssText);\n      },\n      insertPolyfillDirectivesInCssText: function(cssText) {\n        cssText = cssText.replace(cssCommentNextSelectorRe, function(match, p1) {\n          return p1.slice(0, -2) + "{";\n        });\n        return cssText.replace(cssContentNextSelectorRe, function(match, p1) {\n          return p1 + " {";\n        });\n      },\n      insertPolyfillRulesInCssText: function(cssText) {\n        cssText = cssText.replace(cssCommentRuleRe, function(match, p1) {\n          return p1.slice(0, -1);\n        });\n        return cssText.replace(cssContentRuleRe, function(match, p1, p2, p3) {\n          var rule = match.replace(p1, "").replace(p2, "");\n          return p3 + rule;\n        });\n      },\n      scopeCssText: function(cssText, scopeSelector) {\n        var unscoped = this.extractUnscopedRulesFromCssText(cssText);\n        cssText = this.insertPolyfillHostInCssText(cssText);\n        cssText = this.convertColonHost(cssText);\n        cssText = this.convertColonHostContext(cssText);\n        cssText = this.convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n          var self = this, cssText;\n          withCssRules(cssText, function(rules) {\n            cssText = self.scopeRules(rules, scopeSelector);\n          });\n        }\n        cssText = cssText + "\\n" + unscoped;\n        return cssText.trim();\n      },\n      extractUnscopedRulesFromCssText: function(cssText) {\n        var r = "", m;\n        while (m = cssCommentUnscopedRuleRe.exec(cssText)) {\n          r += m[1].slice(0, -1) + "\\n\\n";\n        }\n        while (m = cssContentUnscopedRuleRe.exec(cssText)) {\n          r += m[0].replace(m[2], "").replace(m[1], m[3]) + "\\n\\n";\n        }\n        return r;\n      },\n      convertColonHost: function(cssText) {\n        return this.convertColonRule(cssText, cssColonHostRe, this.colonHostPartReplacer);\n      },\n      convertColonHostContext: function(cssText) {\n        return this.convertColonRule(cssText, cssColonHostContextRe, this.colonHostContextPartReplacer);\n      },\n      convertColonRule: function(cssText, regExp, partReplacer) {\n        return cssText.replace(regExp, function(m, p1, p2, p3) {\n          p1 = polyfillHostNoCombinator;\n          if (p2) {\n            var parts = p2.split(","), r = [];\n            for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {\n              p = p.trim();\n              r.push(partReplacer(p1, p, p3));\n            }\n            return r.join(",");\n          } else {\n            return p1 + p3;\n          }\n        });\n      },\n      colonHostContextPartReplacer: function(host, part, suffix) {\n        if (part.match(polyfillHost)) {\n          return this.colonHostPartReplacer(host, part, suffix);\n        } else {\n          return host + part + suffix + ", " + part + " " + host + suffix;\n        }\n      },\n      colonHostPartReplacer: function(host, part, suffix) {\n        return host + part.replace(polyfillHost, "") + suffix;\n      },\n      convertShadowDOMSelectors: function(cssText) {\n        for (var i = 0; i < shadowDOMSelectorsRe.length; i++) {\n          cssText = cssText.replace(shadowDOMSelectorsRe[i], " ");\n        }\n        return cssText;\n      },\n      scopeRules: function(cssRules, scopeSelector) {\n        var cssText = "";\n        if (cssRules) {\n          Array.prototype.forEach.call(cssRules, function(rule) {\n            if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {\n              cssText += this.scopeSelector(rule.selectorText, scopeSelector, this.strictStyling) + " {\\n\\t";\n              cssText += this.propertiesFromRule(rule) + "\\n}\\n\\n";\n            } else if (rule.type === CSSRule.MEDIA_RULE) {\n              cssText += "@media " + rule.media.mediaText + " {\\n";\n              cssText += this.scopeRules(rule.cssRules, scopeSelector);\n              cssText += "\\n}\\n\\n";\n            } else {\n              try {\n                if (rule.cssText) {\n                  cssText += rule.cssText + "\\n\\n";\n                }\n              } catch (x) {\n                if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {\n                  cssText += this.ieSafeCssTextFromKeyFrameRule(rule);\n                }\n              }\n            }\n          }, this);\n        }\n        return cssText;\n      },\n      ieSafeCssTextFromKeyFrameRule: function(rule) {\n        var cssText = "@keyframes " + rule.name + " {";\n        Array.prototype.forEach.call(rule.cssRules, function(rule) {\n          cssText += " " + rule.keyText + " {" + rule.style.cssText + "}";\n        });\n        cssText += " }";\n        return cssText;\n      },\n      scopeSelector: function(selector, scopeSelector, strict) {\n        var r = [], parts = selector.split(",");\n        parts.forEach(function(p) {\n          p = p.trim();\n          if (this.selectorNeedsScoping(p, scopeSelector)) {\n            p = strict && !p.match(polyfillHostNoCombinator) ? this.applyStrictSelectorScope(p, scopeSelector) : this.applySelectorScope(p, scopeSelector);\n          }\n          r.push(p);\n        }, this);\n        return r.join(", ");\n      },\n      selectorNeedsScoping: function(selector, scopeSelector) {\n        if (Array.isArray(scopeSelector)) {\n          return true;\n        }\n        var re = this.makeScopeMatcher(scopeSelector);\n        return !selector.match(re);\n      },\n      makeScopeMatcher: function(scopeSelector) {\n        scopeSelector = scopeSelector.replace(/\\[/g, "\\\\[").replace(/\\]/g, "\\\\]");\n        return new RegExp("^(" + scopeSelector + ")" + selectorReSuffix, "m");\n      },\n      applySelectorScope: function(selector, selectorScope) {\n        return Array.isArray(selectorScope) ? this.applySelectorScopeList(selector, selectorScope) : this.applySimpleSelectorScope(selector, selectorScope);\n      },\n      applySelectorScopeList: function(selector, scopeSelectorList) {\n        var r = [];\n        for (var i = 0, s; s = scopeSelectorList[i]; i++) {\n          r.push(this.applySimpleSelectorScope(selector, s));\n        }\n        return r.join(", ");\n      },\n      applySimpleSelectorScope: function(selector, scopeSelector) {\n        if (selector.match(polyfillHostRe)) {\n          selector = selector.replace(polyfillHostNoCombinator, scopeSelector);\n          return selector.replace(polyfillHostRe, scopeSelector + " ");\n        } else {\n          return scopeSelector + " " + selector;\n        }\n      },\n      applyStrictSelectorScope: function(selector, scopeSelector) {\n        scopeSelector = scopeSelector.replace(/\\[is=([^\\]]*)\\]/g, "$1");\n        var splits = [ " ", ">", "+", "~" ], scoped = selector, attrName = "[" + scopeSelector + "]";\n        splits.forEach(function(sep) {\n          var parts = scoped.split(sep);\n          scoped = parts.map(function(p) {\n            var t = p.trim().replace(polyfillHostRe, "");\n            if (t && splits.indexOf(t) < 0 && t.indexOf(attrName) < 0) {\n              p = t.replace(/([^:]*)(:*)(.*)/, "$1" + attrName + "$2$3");\n            }\n            return p;\n          }).join(sep);\n        });\n        return scoped;\n      },\n      insertPolyfillHostInCssText: function(selector) {\n        return selector.replace(colonHostContextRe, polyfillHostContext).replace(colonHostRe, polyfillHost);\n      },\n      propertiesFromRule: function(rule) {\n        var cssText = rule.style.cssText;\n        if (rule.style.content && !rule.style.content.match(/[\'"]+|attr/)) {\n          cssText = cssText.replace(/content:[^;]*;/g, "content: \'" + rule.style.content + "\';");\n        }\n        var style = rule.style;\n        for (var i in style) {\n          if (style[i] === "initial") {\n            cssText += i + ": initial; ";\n          }\n        }\n        return cssText;\n      },\n      replaceTextInStyles: function(styles, action) {\n        if (styles && action) {\n          if (!(styles instanceof Array)) {\n            styles = [ styles ];\n          }\n          Array.prototype.forEach.call(styles, function(s) {\n            s.textContent = action.call(this, s.textContent);\n          }, this);\n        }\n      },\n      addCssToDocument: function(cssText, name) {\n        if (cssText.match("@import")) {\n          addOwnSheet(cssText, name);\n        } else {\n          addCssToDocument(cssText);\n        }\n      }\n    };\n    var selectorRe = /([^{]*)({[\\s\\S]*?})/gim, cssCommentRe = /\\/\\*[^*]*\\*+([^\\/*][^*]*\\*+)*\\//gim, cssCommentNextSelectorRe = /\\/\\*\\s*@polyfill ([^*]*\\*+([^\\/*][^*]*\\*+)*\\/)([^{]*?){/gim, cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\\:[\\s]*?[\'"](.*?)[\'"][;\\s]*}([^{]*?){/gim, cssCommentRuleRe = /\\/\\*\\s@polyfill-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentRuleRe = /(polyfill-rule)[^}]*(content\\:[\\s]*[\'"](.*?)[\'"])[;\\s]*[^}]*}/gim, cssCommentUnscopedRuleRe = /\\/\\*\\s@polyfill-unscoped-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\\:[\\s]*[\'"](.*?)[\'"])[;\\s]*[^}]*}/gim, cssPseudoRe = /::(x-[^\\s{,(]*)/gim, cssPartRe = /::part\\(([^)]*)\\)/gim, polyfillHost = "-shadowcsshost", polyfillHostContext = "-shadowcsscontext", parenSuffix = ")(?:\\\\((" + "(?:\\\\([^)(]*\\\\)|[^)(]*)+?" + ")\\\\))?([^,{]*)";\n    var cssColonHostRe = new RegExp("(" + polyfillHost + parenSuffix, "gim"), cssColonHostContextRe = new RegExp("(" + polyfillHostContext + parenSuffix, "gim"), selectorReSuffix = "([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$", colonHostRe = /\\:host/gim, colonHostContextRe = /\\:host-context/gim, polyfillHostNoCombinator = polyfillHost + "-no-combinator", polyfillHostRe = new RegExp(polyfillHost, "gim"), polyfillHostContextRe = new RegExp(polyfillHostContext, "gim"), shadowDOMSelectorsRe = [ />>>/g, /::shadow/g, /::content/g, /\\/deep\\//g, /\\/shadow\\//g, /\\/shadow-deep\\//g, /\\^\\^/g, /\\^(?!=)/g ];\n    function stylesToCssText(styles, preserveComments) {\n      var cssText = "";\n      Array.prototype.forEach.call(styles, function(s) {\n        cssText += s.textContent + "\\n\\n";\n      });\n      if (!preserveComments) {\n        cssText = cssText.replace(cssCommentRe, "");\n      }\n      return cssText;\n    }\n    function cssTextToStyle(cssText) {\n      var style = document.createElement("style");\n      style.textContent = cssText;\n      return style;\n    }\n    function cssToRules(cssText) {\n      var style = cssTextToStyle(cssText);\n      document.head.appendChild(style);\n      var rules = [];\n      if (style.sheet) {\n        try {\n          rules = style.sheet.cssRules;\n        } catch (e) {}\n      } else {\n        console.warn("sheet not found", style);\n      }\n      style.parentNode.removeChild(style);\n      return rules;\n    }\n    var frame = document.createElement("iframe");\n    frame.style.display = "none";\n    function initFrame() {\n      frame.initialized = true;\n      document.body.appendChild(frame);\n      var doc = frame.contentDocument;\n      var base = doc.createElement("base");\n      base.href = document.baseURI;\n      doc.head.appendChild(base);\n    }\n    function inFrame(fn) {\n      if (!frame.initialized) {\n        initFrame();\n      }\n      document.body.appendChild(frame);\n      fn(frame.contentDocument);\n      document.body.removeChild(frame);\n    }\n    var isChrome = navigator.userAgent.match("Chrome");\n    function withCssRules(cssText, callback) {\n      if (!callback) {\n        return;\n      }\n      var rules;\n      if (cssText.match("@import") && isChrome) {\n        var style = cssTextToStyle(cssText);\n        inFrame(function(doc) {\n          doc.head.appendChild(style.impl);\n          rules = Array.prototype.slice.call(style.sheet.cssRules, 0);\n          callback(rules);\n        });\n      } else {\n        rules = cssToRules(cssText);\n        callback(rules);\n      }\n    }\n    function rulesToCss(cssRules) {\n      for (var i = 0, css = []; i < cssRules.length; i++) {\n        css.push(cssRules[i].cssText);\n      }\n      return css.join("\\n\\n");\n    }\n    function addCssToDocument(cssText) {\n      if (cssText) {\n        getSheet().appendChild(document.createTextNode(cssText));\n      }\n    }\n    function addOwnSheet(cssText, name) {\n      var style = cssTextToStyle(cssText);\n      style.setAttribute(name, "");\n      style.setAttribute(SHIMMED_ATTRIBUTE, "");\n      document.head.appendChild(style);\n    }\n    var SHIM_ATTRIBUTE = "shim-shadowdom";\n    var SHIMMED_ATTRIBUTE = "shim-shadowdom-css";\n    var NO_SHIM_ATTRIBUTE = "no-shim";\n    var sheet;\n    function getSheet() {\n      if (!sheet) {\n        sheet = document.createElement("style");\n        sheet.setAttribute(SHIMMED_ATTRIBUTE, "");\n        sheet[SHIMMED_ATTRIBUTE] = true;\n      }\n      return sheet;\n    }\n    if (window.ShadowDOMPolyfill) {\n      addCssToDocument("style { display: none !important; }\\n");\n      var doc = ShadowDOMPolyfill.wrap(document);\n      var head = doc.querySelector("head");\n      head.insertBefore(getSheet(), head.childNodes[0]);\n      document.addEventListener("DOMContentLoaded", function() {\n        var urlResolver = scope.urlResolver;\n        if (window.HTMLImports && !HTMLImports.useNative) {\n          var SHIM_SHEET_SELECTOR = "link[rel=stylesheet]" + "[" + SHIM_ATTRIBUTE + "]";\n          var SHIM_STYLE_SELECTOR = "style[" + SHIM_ATTRIBUTE + "]";\n          HTMLImports.importer.documentPreloadSelectors += "," + SHIM_SHEET_SELECTOR;\n          HTMLImports.importer.importsPreloadSelectors += "," + SHIM_SHEET_SELECTOR;\n          HTMLImports.parser.documentSelectors = [ HTMLImports.parser.documentSelectors, SHIM_SHEET_SELECTOR, SHIM_STYLE_SELECTOR ].join(",");\n          var originalParseGeneric = HTMLImports.parser.parseGeneric;\n          HTMLImports.parser.parseGeneric = function(elt) {\n            if (elt[SHIMMED_ATTRIBUTE]) {\n              return;\n            }\n            var style = elt.__importElement || elt;\n            if (!style.hasAttribute(SHIM_ATTRIBUTE)) {\n              originalParseGeneric.call(this, elt);\n              return;\n            }\n            if (elt.__resource) {\n              style = elt.ownerDocument.createElement("style");\n              style.textContent = elt.__resource;\n            }\n            HTMLImports.path.resolveUrlsInStyle(style, elt.href);\n            style.textContent = ShadowCSS.shimStyle(style);\n            style.removeAttribute(SHIM_ATTRIBUTE, "");\n            style.setAttribute(SHIMMED_ATTRIBUTE, "");\n            style[SHIMMED_ATTRIBUTE] = true;\n            if (style.parentNode !== head) {\n              if (elt.parentNode === head) {\n                head.replaceChild(style, elt);\n              } else {\n                this.addElementToDocument(style);\n              }\n            }\n            style.__importParsed = true;\n            this.markParsingComplete(elt);\n            this.parseNext();\n          };\n          var hasResource = HTMLImports.parser.hasResource;\n          HTMLImports.parser.hasResource = function(node) {\n            if (node.localName === "link" && node.rel === "stylesheet" && node.hasAttribute(SHIM_ATTRIBUTE)) {\n              return node.__resource;\n            } else {\n              return hasResource.call(this, node);\n            }\n          };\n        }\n      });\n    }\n    scope.ShadowCSS = ShadowCSS;\n  })(window.WebComponents);\n}\n\n(function(scope) {\n  if (window.ShadowDOMPolyfill) {\n    window.wrap = ShadowDOMPolyfill.wrapIfNeeded;\n    window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;\n  } else {\n    window.wrap = window.unwrap = function(n) {\n      return n;\n    };\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  "use strict";\n  var hasWorkingUrl = false;\n  if (!scope.forceJURL) {\n    try {\n      var u = new URL("b", "http://a");\n      u.pathname = "c%20d";\n      hasWorkingUrl = u.href === "http://a/c%20d";\n    } catch (e) {}\n  }\n  if (hasWorkingUrl) return;\n  var relative = Object.create(null);\n  relative["ftp"] = 21;\n  relative["file"] = 0;\n  relative["gopher"] = 70;\n  relative["http"] = 80;\n  relative["https"] = 443;\n  relative["ws"] = 80;\n  relative["wss"] = 443;\n  var relativePathDotMapping = Object.create(null);\n  relativePathDotMapping["%2e"] = ".";\n  relativePathDotMapping[".%2e"] = "..";\n  relativePathDotMapping["%2e."] = "..";\n  relativePathDotMapping["%2e%2e"] = "..";\n  function isRelativeScheme(scheme) {\n    return relative[scheme] !== undefined;\n  }\n  function invalid() {\n    clear.call(this);\n    this._isInvalid = true;\n  }\n  function IDNAToASCII(h) {\n    if ("" == h) {\n      invalid.call(this);\n    }\n    return h.toLowerCase();\n  }\n  function percentEscape(c) {\n    var unicode = c.charCodeAt(0);\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n  function percentEscapeQuery(c) {\n    var unicode = c.charCodeAt(0);\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\\+\\-\\.]/;\n  function parse(input, stateOverride, base) {\n    function err(message) {\n      errors.push(message);\n    }\n    var state = stateOverride || "scheme start", cursor = 0, buffer = "", seenAt = false, seenBracket = false, errors = [];\n    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {\n      var c = input[cursor];\n      switch (state) {\n       case "scheme start":\n        if (c && ALPHA.test(c)) {\n          buffer += c.toLowerCase();\n          state = "scheme";\n        } else if (!stateOverride) {\n          buffer = "";\n          state = "no scheme";\n          continue;\n        } else {\n          err("Invalid scheme.");\n          break loop;\n        }\n        break;\n\n       case "scheme":\n        if (c && ALPHANUMERIC.test(c)) {\n          buffer += c.toLowerCase();\n        } else if (":" == c) {\n          this._scheme = buffer;\n          buffer = "";\n          if (stateOverride) {\n            break loop;\n          }\n          if (isRelativeScheme(this._scheme)) {\n            this._isRelative = true;\n          }\n          if ("file" == this._scheme) {\n            state = "relative";\n          } else if (this._isRelative && base && base._scheme == this._scheme) {\n            state = "relative or authority";\n          } else if (this._isRelative) {\n            state = "authority first slash";\n          } else {\n            state = "scheme data";\n          }\n        } else if (!stateOverride) {\n          buffer = "";\n          cursor = 0;\n          state = "no scheme";\n          continue;\n        } else if (EOF == c) {\n          break loop;\n        } else {\n          err("Code point not allowed in scheme: " + c);\n          break loop;\n        }\n        break;\n\n       case "scheme data":\n        if ("?" == c) {\n          this._query = "?";\n          state = "query";\n        } else if ("#" == c) {\n          this._fragment = "#";\n          state = "fragment";\n        } else {\n          if (EOF != c && "\\t" != c && "\\n" != c && "\\r" != c) {\n            this._schemeData += percentEscape(c);\n          }\n        }\n        break;\n\n       case "no scheme":\n        if (!base || !isRelativeScheme(base._scheme)) {\n          err("Missing scheme.");\n          invalid.call(this);\n        } else {\n          state = "relative";\n          continue;\n        }\n        break;\n\n       case "relative or authority":\n        if ("/" == c && "/" == input[cursor + 1]) {\n          state = "authority ignore slashes";\n        } else {\n          err("Expected /, got: " + c);\n          state = "relative";\n          continue;\n        }\n        break;\n\n       case "relative":\n        this._isRelative = true;\n        if ("file" != this._scheme) this._scheme = base._scheme;\n        if (EOF == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = base._query;\n          this._username = base._username;\n          this._password = base._password;\n          break loop;\n        } else if ("/" == c || "\\\\" == c) {\n          if ("\\\\" == c) err("\\\\ is an invalid code point.");\n          state = "relative slash";\n        } else if ("?" == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = "?";\n          this._username = base._username;\n          this._password = base._password;\n          state = "query";\n        } else if ("#" == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = base._query;\n          this._fragment = "#";\n          this._username = base._username;\n          this._password = base._password;\n          state = "fragment";\n        } else {\n          var nextC = input[cursor + 1];\n          var nextNextC = input[cursor + 2];\n          if ("file" != this._scheme || !ALPHA.test(c) || nextC != ":" && nextC != "|" || EOF != nextNextC && "/" != nextNextC && "\\\\" != nextNextC && "?" != nextNextC && "#" != nextNextC) {\n            this._host = base._host;\n            this._port = base._port;\n            this._username = base._username;\n            this._password = base._password;\n            this._path = base._path.slice();\n            this._path.pop();\n          }\n          state = "relative path";\n          continue;\n        }\n        break;\n\n       case "relative slash":\n        if ("/" == c || "\\\\" == c) {\n          if ("\\\\" == c) {\n            err("\\\\ is an invalid code point.");\n          }\n          if ("file" == this._scheme) {\n            state = "file host";\n          } else {\n            state = "authority ignore slashes";\n          }\n        } else {\n          if ("file" != this._scheme) {\n            this._host = base._host;\n            this._port = base._port;\n            this._username = base._username;\n            this._password = base._password;\n          }\n          state = "relative path";\n          continue;\n        }\n        break;\n\n       case "authority first slash":\n        if ("/" == c) {\n          state = "authority second slash";\n        } else {\n          err("Expected \'/\', got: " + c);\n          state = "authority ignore slashes";\n          continue;\n        }\n        break;\n\n       case "authority second slash":\n        state = "authority ignore slashes";\n        if ("/" != c) {\n          err("Expected \'/\', got: " + c);\n          continue;\n        }\n        break;\n\n       case "authority ignore slashes":\n        if ("/" != c && "\\\\" != c) {\n          state = "authority";\n          continue;\n        } else {\n          err("Expected authority, got: " + c);\n        }\n        break;\n\n       case "authority":\n        if ("@" == c) {\n          if (seenAt) {\n            err("@ already seen.");\n            buffer += "%40";\n          }\n          seenAt = true;\n          for (var i = 0; i < buffer.length; i++) {\n            var cp = buffer[i];\n            if ("\\t" == cp || "\\n" == cp || "\\r" == cp) {\n              err("Invalid whitespace in authority.");\n              continue;\n            }\n            if (":" == cp && null === this._password) {\n              this._password = "";\n              continue;\n            }\n            var tempC = percentEscape(cp);\n            null !== this._password ? this._password += tempC : this._username += tempC;\n          }\n          buffer = "";\n        } else if (EOF == c || "/" == c || "\\\\" == c || "?" == c || "#" == c) {\n          cursor -= buffer.length;\n          buffer = "";\n          state = "host";\n          continue;\n        } else {\n          buffer += c;\n        }\n        break;\n\n       case "file host":\n        if (EOF == c || "/" == c || "\\\\" == c || "?" == c || "#" == c) {\n          if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ":" || buffer[1] == "|")) {\n            state = "relative path";\n          } else if (buffer.length == 0) {\n            state = "relative path start";\n          } else {\n            this._host = IDNAToASCII.call(this, buffer);\n            buffer = "";\n            state = "relative path start";\n          }\n          continue;\n        } else if ("\\t" == c || "\\n" == c || "\\r" == c) {\n          err("Invalid whitespace in file host.");\n        } else {\n          buffer += c;\n        }\n        break;\n\n       case "host":\n       case "hostname":\n        if (":" == c && !seenBracket) {\n          this._host = IDNAToASCII.call(this, buffer);\n          buffer = "";\n          state = "port";\n          if ("hostname" == stateOverride) {\n            break loop;\n          }\n        } else if (EOF == c || "/" == c || "\\\\" == c || "?" == c || "#" == c) {\n          this._host = IDNAToASCII.call(this, buffer);\n          buffer = "";\n          state = "relative path start";\n          if (stateOverride) {\n            break loop;\n          }\n          continue;\n        } else if ("\\t" != c && "\\n" != c && "\\r" != c) {\n          if ("[" == c) {\n            seenBracket = true;\n          } else if ("]" == c) {\n            seenBracket = false;\n          }\n          buffer += c;\n        } else {\n          err("Invalid code point in host/hostname: " + c);\n        }\n        break;\n\n       case "port":\n        if (/[0-9]/.test(c)) {\n          buffer += c;\n        } else if (EOF == c || "/" == c || "\\\\" == c || "?" == c || "#" == c || stateOverride) {\n          if ("" != buffer) {\n            var temp = parseInt(buffer, 10);\n            if (temp != relative[this._scheme]) {\n              this._port = temp + "";\n            }\n            buffer = "";\n          }\n          if (stateOverride) {\n            break loop;\n          }\n          state = "relative path start";\n          continue;\n        } else if ("\\t" == c || "\\n" == c || "\\r" == c) {\n          err("Invalid code point in port: " + c);\n        } else {\n          invalid.call(this);\n        }\n        break;\n\n       case "relative path start":\n        if ("\\\\" == c) err("\'\\\\\' not allowed in path.");\n        state = "relative path";\n        if ("/" != c && "\\\\" != c) {\n          continue;\n        }\n        break;\n\n       case "relative path":\n        if (EOF == c || "/" == c || "\\\\" == c || !stateOverride && ("?" == c || "#" == c)) {\n          if ("\\\\" == c) {\n            err("\\\\ not allowed in relative path.");\n          }\n          var tmp;\n          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\n            buffer = tmp;\n          }\n          if (".." == buffer) {\n            this._path.pop();\n            if ("/" != c && "\\\\" != c) {\n              this._path.push("");\n            }\n          } else if ("." == buffer && "/" != c && "\\\\" != c) {\n            this._path.push("");\n          } else if ("." != buffer) {\n            if ("file" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == "|") {\n              buffer = buffer[0] + ":";\n            }\n            this._path.push(buffer);\n          }\n          buffer = "";\n          if ("?" == c) {\n            this._query = "?";\n            state = "query";\n          } else if ("#" == c) {\n            this._fragment = "#";\n            state = "fragment";\n          }\n        } else if ("\\t" != c && "\\n" != c && "\\r" != c) {\n          buffer += percentEscape(c);\n        }\n        break;\n\n       case "query":\n        if (!stateOverride && "#" == c) {\n          this._fragment = "#";\n          state = "fragment";\n        } else if (EOF != c && "\\t" != c && "\\n" != c && "\\r" != c) {\n          this._query += percentEscapeQuery(c);\n        }\n        break;\n\n       case "fragment":\n        if (EOF != c && "\\t" != c && "\\n" != c && "\\r" != c) {\n          this._fragment += c;\n        }\n        break;\n      }\n      cursor++;\n    }\n  }\n  function clear() {\n    this._scheme = "";\n    this._schemeData = "";\n    this._username = "";\n    this._password = null;\n    this._host = "";\n    this._port = "";\n    this._path = [];\n    this._query = "";\n    this._fragment = "";\n    this._isInvalid = false;\n    this._isRelative = false;\n  }\n  function jURL(url, base) {\n    if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));\n    this._url = url;\n    clear.call(this);\n    var input = url.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g, "");\n    parse.call(this, input, null, base);\n  }\n  jURL.prototype = {\n    toString: function() {\n      return this.href;\n    },\n    get href() {\n      if (this._isInvalid) return this._url;\n      var authority = "";\n      if ("" != this._username || null != this._password) {\n        authority = this._username + (null != this._password ? ":" + this._password : "") + "@";\n      }\n      return this.protocol + (this._isRelative ? "//" + authority + this.host : "") + this.pathname + this._query + this._fragment;\n    },\n    set href(href) {\n      clear.call(this);\n      parse.call(this, href);\n    },\n    get protocol() {\n      return this._scheme + ":";\n    },\n    set protocol(protocol) {\n      if (this._isInvalid) return;\n      parse.call(this, protocol + ":", "scheme start");\n    },\n    get host() {\n      return this._isInvalid ? "" : this._port ? this._host + ":" + this._port : this._host;\n    },\n    set host(host) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, host, "host");\n    },\n    get hostname() {\n      return this._host;\n    },\n    set hostname(hostname) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, hostname, "hostname");\n    },\n    get port() {\n      return this._port;\n    },\n    set port(port) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, port, "port");\n    },\n    get pathname() {\n      return this._isInvalid ? "" : this._isRelative ? "/" + this._path.join("/") : this._schemeData;\n    },\n    set pathname(pathname) {\n      if (this._isInvalid || !this._isRelative) return;\n      this._path = [];\n      parse.call(this, pathname, "relative path start");\n    },\n    get search() {\n      return this._isInvalid || !this._query || "?" == this._query ? "" : this._query;\n    },\n    set search(search) {\n      if (this._isInvalid || !this._isRelative) return;\n      this._query = "?";\n      if ("?" == search[0]) search = search.slice(1);\n      parse.call(this, search, "query");\n    },\n    get hash() {\n      return this._isInvalid || !this._fragment || "#" == this._fragment ? "" : this._fragment;\n    },\n    set hash(hash) {\n      if (this._isInvalid) return;\n      this._fragment = "#";\n      if ("#" == hash[0]) hash = hash.slice(1);\n      parse.call(this, hash, "fragment");\n    },\n    get origin() {\n      var host;\n      if (this._isInvalid || !this._scheme) {\n        return "";\n      }\n      switch (this._scheme) {\n       case "data":\n       case "file":\n       case "javascript":\n       case "mailto":\n        return "null";\n      }\n      host = this.host;\n      if (!host) {\n        return "";\n      }\n      return this._scheme + "://" + host;\n    }\n  };\n  var OriginalURL = scope.URL;\n  if (OriginalURL) {\n    jURL.createObjectURL = function(blob) {\n      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\n    };\n    jURL.revokeObjectURL = function(url) {\n      OriginalURL.revokeObjectURL(url);\n    };\n  }\n  scope.URL = jURL;\n})(self);\n\n(function(global) {\n  if (global.JsMutationObserver) {\n    return;\n  }\n  var registrationsTable = new WeakMap();\n  var setImmediate;\n  if (/Trident|Edge/.test(navigator.userAgent)) {\n    setImmediate = setTimeout;\n  } else if (window.setImmediate) {\n    setImmediate = window.setImmediate;\n  } else {\n    var setImmediateQueue = [];\n    var sentinel = String(Math.random());\n    window.addEventListener("message", function(e) {\n      if (e.data === sentinel) {\n        var queue = setImmediateQueue;\n        setImmediateQueue = [];\n        queue.forEach(function(func) {\n          func();\n        });\n      }\n    });\n    setImmediate = function(func) {\n      setImmediateQueue.push(func);\n      window.postMessage(sentinel, "*");\n    };\n  }\n  var isScheduled = false;\n  var scheduledObservers = [];\n  function scheduleCallback(observer) {\n    scheduledObservers.push(observer);\n    if (!isScheduled) {\n      isScheduled = true;\n      setImmediate(dispatchCallbacks);\n    }\n  }\n  function wrapIfNeeded(node) {\n    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;\n  }\n  function dispatchCallbacks() {\n    isScheduled = false;\n    var observers = scheduledObservers;\n    scheduledObservers = [];\n    observers.sort(function(o1, o2) {\n      return o1.uid_ - o2.uid_;\n    });\n    var anyNonEmpty = false;\n    observers.forEach(function(observer) {\n      var queue = observer.takeRecords();\n      removeTransientObserversFor(observer);\n      if (queue.length) {\n        observer.callback_(queue, observer);\n        anyNonEmpty = true;\n      }\n    });\n    if (anyNonEmpty) dispatchCallbacks();\n  }\n  function removeTransientObserversFor(observer) {\n    observer.nodes_.forEach(function(node) {\n      var registrations = registrationsTable.get(node);\n      if (!registrations) return;\n      registrations.forEach(function(registration) {\n        if (registration.observer === observer) registration.removeTransientObservers();\n      });\n    });\n  }\n  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\n    for (var node = target; node; node = node.parentNode) {\n      var registrations = registrationsTable.get(node);\n      if (registrations) {\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n          if (node !== target && !options.subtree) continue;\n          var record = callback(options);\n          if (record) registration.enqueue(record);\n        }\n      }\n    }\n  }\n  var uidCounter = 0;\n  function JsMutationObserver(callback) {\n    this.callback_ = callback;\n    this.nodes_ = [];\n    this.records_ = [];\n    this.uid_ = ++uidCounter;\n  }\n  JsMutationObserver.prototype = {\n    observe: function(target, options) {\n      target = wrapIfNeeded(target);\n      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {\n        throw new SyntaxError();\n      }\n      var registrations = registrationsTable.get(target);\n      if (!registrations) registrationsTable.set(target, registrations = []);\n      var registration;\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i].observer === this) {\n          registration = registrations[i];\n          registration.removeListeners();\n          registration.options = options;\n          break;\n        }\n      }\n      if (!registration) {\n        registration = new Registration(this, target, options);\n        registrations.push(registration);\n        this.nodes_.push(target);\n      }\n      registration.addListeners();\n    },\n    disconnect: function() {\n      this.nodes_.forEach(function(node) {\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.observer === this) {\n            registration.removeListeners();\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n      this.records_ = [];\n    },\n    takeRecords: function() {\n      var copyOfRecords = this.records_;\n      this.records_ = [];\n      return copyOfRecords;\n    }\n  };\n  function MutationRecord(type, target) {\n    this.type = type;\n    this.target = target;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.oldValue = null;\n  }\n  function copyMutationRecord(original) {\n    var record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  }\n  var currentRecord, recordWithOldValue;\n  function getRecord(type, target) {\n    return currentRecord = new MutationRecord(type, target);\n  }\n  function getRecordWithOldValue(oldValue) {\n    if (recordWithOldValue) return recordWithOldValue;\n    recordWithOldValue = copyMutationRecord(currentRecord);\n    recordWithOldValue.oldValue = oldValue;\n    return recordWithOldValue;\n  }\n  function clearRecords() {\n    currentRecord = recordWithOldValue = undefined;\n  }\n  function recordRepresentsCurrentMutation(record) {\n    return record === recordWithOldValue || record === currentRecord;\n  }\n  function selectRecord(lastRecord, newRecord) {\n    if (lastRecord === newRecord) return lastRecord;\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n    return null;\n  }\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n  Registration.prototype = {\n    enqueue: function(record) {\n      var records = this.observer.records_;\n      var length = records.length;\n      if (records.length > 0) {\n        var lastRecord = records[length - 1];\n        var recordToReplaceLast = selectRecord(lastRecord, record);\n        if (recordToReplaceLast) {\n          records[length - 1] = recordToReplaceLast;\n          return;\n        }\n      } else {\n        scheduleCallback(this.observer);\n      }\n      records[length] = record;\n    },\n    addListeners: function() {\n      this.addListeners_(this.target);\n    },\n    addListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);\n      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);\n      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);\n      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);\n    },\n    removeListeners: function() {\n      this.removeListeners_(this.target);\n    },\n    removeListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);\n      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);\n      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);\n      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);\n    },\n    addTransientObserver: function(node) {\n      if (node === this.target) return;\n      this.addListeners_(node);\n      this.transientObservedNodes.push(node);\n      var registrations = registrationsTable.get(node);\n      if (!registrations) registrationsTable.set(node, registrations = []);\n      registrations.push(this);\n    },\n    removeTransientObservers: function() {\n      var transientObservedNodes = this.transientObservedNodes;\n      this.transientObservedNodes = [];\n      transientObservedNodes.forEach(function(node) {\n        this.removeListeners_(node);\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i] === this) {\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n    },\n    handleEvent: function(e) {\n      e.stopImmediatePropagation();\n      switch (e.type) {\n       case "DOMAttrModified":\n        var name = e.attrName;\n        var namespace = e.relatedNode.namespaceURI;\n        var target = e.target;\n        var record = new getRecord("attributes", target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace;\n        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          if (!options.attributes) return;\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\n            return;\n          }\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\n          return record;\n        });\n        break;\n\n       case "DOMCharacterDataModified":\n        var target = e.target;\n        var record = getRecord("characterData", target);\n        var oldValue = e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          if (!options.characterData) return;\n          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);\n          return record;\n        });\n        break;\n\n       case "DOMNodeRemoved":\n        this.addTransientObserver(e.target);\n\n       case "DOMNodeInserted":\n        var changedNode = e.target;\n        var addedNodes, removedNodes;\n        if (e.type === "DOMNodeInserted") {\n          addedNodes = [ changedNode ];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [ changedNode ];\n        }\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling;\n        var record = getRecord("childList", e.target.parentNode);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {\n          if (!options.childList) return;\n          return record;\n        });\n      }\n      clearRecords();\n    }\n  };\n  global.JsMutationObserver = JsMutationObserver;\n  if (!global.MutationObserver) {\n    global.MutationObserver = JsMutationObserver;\n    JsMutationObserver._isPolyfilled = true;\n  }\n})(self);\n\n(function(scope) {\n  "use strict";\n  if (!(window.performance && window.performance.now)) {\n    var start = Date.now();\n    window.performance = {\n      now: function() {\n        return Date.now() - start;\n      }\n    };\n  }\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function() {\n      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n      return nativeRaf ? function(callback) {\n        return nativeRaf(function() {\n          callback(performance.now());\n        });\n      } : function(callback) {\n        return window.setTimeout(callback, 1e3 / 60);\n      };\n    }();\n  }\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function() {\n      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {\n        clearTimeout(id);\n      };\n    }();\n  }\n  var workingDefaultPrevented = function() {\n    var e = document.createEvent("Event");\n    e.initEvent("foo", true, true);\n    e.preventDefault();\n    return e.defaultPrevented;\n  }();\n  if (!workingDefaultPrevented) {\n    var origPreventDefault = Event.prototype.preventDefault;\n    Event.prototype.preventDefault = function() {\n      if (!this.cancelable) {\n        return;\n      }\n      origPreventDefault.call(this);\n      Object.defineProperty(this, "defaultPrevented", {\n        get: function() {\n          return true;\n        },\n        configurable: true\n      });\n    };\n  }\n  var isIE = /Trident/.test(navigator.userAgent);\n  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== "function") {\n    window.CustomEvent = function(inType, params) {\n      params = params || {};\n      var e = document.createEvent("CustomEvent");\n      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n      return e;\n    };\n    window.CustomEvent.prototype = window.Event.prototype;\n  }\n  if (!window.Event || isIE && typeof window.Event !== "function") {\n    var origEvent = window.Event;\n    window.Event = function(inType, params) {\n      params = params || {};\n      var e = document.createEvent("Event");\n      e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n      return e;\n    };\n    window.Event.prototype = origEvent.prototype;\n  }\n})(window.WebComponents);\n\nwindow.HTMLImports = window.HTMLImports || {\n  flags: {}\n};\n\n(function(scope) {\n  var IMPORT_LINK_TYPE = "import";\n  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement("link"));\n  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\n  var wrap = function(node) {\n    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;\n  };\n  var rootDocument = wrap(document);\n  var currentScriptDescriptor = {\n    get: function() {\n      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== "complete" ? document.scripts[document.scripts.length - 1] : null);\n      return wrap(script);\n    },\n    configurable: true\n  };\n  Object.defineProperty(document, "_currentScript", currentScriptDescriptor);\n  Object.defineProperty(rootDocument, "_currentScript", currentScriptDescriptor);\n  var isIE = /Trident/.test(navigator.userAgent);\n  function whenReady(callback, doc) {\n    doc = doc || rootDocument;\n    whenDocumentReady(function() {\n      watchImportsLoad(callback, doc);\n    }, doc);\n  }\n  var requiredReadyState = isIE ? "complete" : "interactive";\n  var READY_EVENT = "readystatechange";\n  function isDocumentReady(doc) {\n    return doc.readyState === "complete" || doc.readyState === requiredReadyState;\n  }\n  function whenDocumentReady(callback, doc) {\n    if (!isDocumentReady(doc)) {\n      var checkReady = function() {\n        if (doc.readyState === "complete" || doc.readyState === requiredReadyState) {\n          doc.removeEventListener(READY_EVENT, checkReady);\n          whenDocumentReady(callback, doc);\n        }\n      };\n      doc.addEventListener(READY_EVENT, checkReady);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function markTargetLoaded(event) {\n    event.target.__loaded = true;\n  }\n  function watchImportsLoad(callback, doc) {\n    var imports = doc.querySelectorAll("link[rel=import]");\n    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];\n    function checkDone() {\n      if (parsedCount == importCount && callback) {\n        callback({\n          allImports: imports,\n          loadedImports: newImports,\n          errorImports: errorImports\n        });\n      }\n    }\n    function loadedImport(e) {\n      markTargetLoaded(e);\n      newImports.push(this);\n      parsedCount++;\n      checkDone();\n    }\n    function errorLoadingImport(e) {\n      errorImports.push(this);\n      parsedCount++;\n      checkDone();\n    }\n    if (importCount) {\n      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {\n        if (isImportLoaded(imp)) {\n          newImports.push(this);\n          parsedCount++;\n          checkDone();\n        } else {\n          imp.addEventListener("load", loadedImport);\n          imp.addEventListener("error", errorLoadingImport);\n        }\n      }\n    } else {\n      checkDone();\n    }\n  }\n  function isImportLoaded(link) {\n    return useNative ? link.__loaded || link.import && link.import.readyState !== "loading" : link.__importParsed;\n  }\n  if (useNative) {\n    new MutationObserver(function(mxns) {\n      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {\n        if (m.addedNodes) {\n          handleImports(m.addedNodes);\n        }\n      }\n    }).observe(document.head, {\n      childList: true\n    });\n    function handleImports(nodes) {\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        if (isImport(n)) {\n          handleImport(n);\n        }\n      }\n    }\n    function isImport(element) {\n      return element.localName === "link" && element.rel === "import";\n    }\n    function handleImport(element) {\n      var loaded = element.import;\n      if (loaded) {\n        markTargetLoaded({\n          target: element\n        });\n      } else {\n        element.addEventListener("load", markTargetLoaded);\n        element.addEventListener("error", markTargetLoaded);\n      }\n    }\n    (function() {\n      if (document.readyState === "loading") {\n        var imports = document.querySelectorAll("link[rel=import]");\n        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {\n          handleImport(imp);\n        }\n      }\n    })();\n  }\n  whenReady(function(detail) {\n    window.HTMLImports.ready = true;\n    window.HTMLImports.readyTime = new Date().getTime();\n    var evt = rootDocument.createEvent("CustomEvent");\n    evt.initCustomEvent("HTMLImportsLoaded", true, true, detail);\n    rootDocument.dispatchEvent(evt);\n  });\n  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\n  scope.useNative = useNative;\n  scope.rootDocument = rootDocument;\n  scope.whenReady = whenReady;\n  scope.isIE = isIE;\n})(window.HTMLImports);\n\n(function(scope) {\n  var modules = [];\n  var addModule = function(module) {\n    modules.push(module);\n  };\n  var initializeModules = function() {\n    modules.forEach(function(module) {\n      module(scope);\n    });\n  };\n  scope.addModule = addModule;\n  scope.initializeModules = initializeModules;\n})(window.HTMLImports);\n\nwindow.HTMLImports.addModule(function(scope) {\n  var CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\n  var CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n  var path = {\n    resolveUrlsInStyle: function(style, linkUrl) {\n      var doc = style.ownerDocument;\n      var resolver = doc.createElement("a");\n      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);\n      return style;\n    },\n    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {\n      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);\n      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);\n      return r;\n    },\n    replaceUrls: function(text, urlObj, linkUrl, regexp) {\n      return text.replace(regexp, function(m, pre, url, post) {\n        var urlPath = url.replace(/["\']/g, "");\n        if (linkUrl) {\n          urlPath = new URL(urlPath, linkUrl).href;\n        }\n        urlObj.href = urlPath;\n        urlPath = urlObj.href;\n        return pre + "\'" + urlPath + "\'" + post;\n      });\n    }\n  };\n  scope.path = path;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var xhr = {\n    async: true,\n    ok: function(request) {\n      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;\n    },\n    load: function(url, next, nextContext) {\n      var request = new XMLHttpRequest();\n      if (scope.flags.debug || scope.flags.bust) {\n        url += "?" + Math.random();\n      }\n      request.open("GET", url, xhr.async);\n      request.addEventListener("readystatechange", function(e) {\n        if (request.readyState === 4) {\n          var redirectedUrl = null;\n          try {\n            var locationHeader = request.getResponseHeader("Location");\n            if (locationHeader) {\n              redirectedUrl = locationHeader.substr(0, 1) === "/" ? location.origin + locationHeader : locationHeader;\n            }\n          } catch (e) {\n            console.error(e.message);\n          }\n          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);\n        }\n      });\n      request.send();\n      return request;\n    },\n    loadDocument: function(url, next, nextContext) {\n      this.load(url, next, nextContext).responseType = "document";\n    }\n  };\n  scope.xhr = xhr;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var xhr = scope.xhr;\n  var flags = scope.flags;\n  var Loader = function(onLoad, onComplete) {\n    this.cache = {};\n    this.onload = onLoad;\n    this.oncomplete = onComplete;\n    this.inflight = 0;\n    this.pending = {};\n  };\n  Loader.prototype = {\n    addNodes: function(nodes) {\n      this.inflight += nodes.length;\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        this.require(n);\n      }\n      this.checkDone();\n    },\n    addNode: function(node) {\n      this.inflight++;\n      this.require(node);\n      this.checkDone();\n    },\n    require: function(elt) {\n      var url = elt.src || elt.href;\n      elt.__nodeUrl = url;\n      if (!this.dedupe(url, elt)) {\n        this.fetch(url, elt);\n      }\n    },\n    dedupe: function(url, elt) {\n      if (this.pending[url]) {\n        this.pending[url].push(elt);\n        return true;\n      }\n      var resource;\n      if (this.cache[url]) {\n        this.onload(url, elt, this.cache[url]);\n        this.tail();\n        return true;\n      }\n      this.pending[url] = [ elt ];\n      return false;\n    },\n    fetch: function(url, elt) {\n      flags.load && console.log("fetch", url, elt);\n      if (!url) {\n        setTimeout(function() {\n          this.receive(url, elt, {\n            error: "href must be specified"\n          }, null);\n        }.bind(this), 0);\n      } else if (url.match(/^data:/)) {\n        var pieces = url.split(",");\n        var header = pieces[0];\n        var body = pieces[1];\n        if (header.indexOf(";base64") > -1) {\n          body = atob(body);\n        } else {\n          body = decodeURIComponent(body);\n        }\n        setTimeout(function() {\n          this.receive(url, elt, null, body);\n        }.bind(this), 0);\n      } else {\n        var receiveXhr = function(err, resource, redirectedUrl) {\n          this.receive(url, elt, err, resource, redirectedUrl);\n        }.bind(this);\n        xhr.load(url, receiveXhr);\n      }\n    },\n    receive: function(url, elt, err, resource, redirectedUrl) {\n      this.cache[url] = resource;\n      var $p = this.pending[url];\n      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n        this.onload(url, p, resource, err, redirectedUrl);\n        this.tail();\n      }\n      this.pending[url] = null;\n    },\n    tail: function() {\n      --this.inflight;\n      this.checkDone();\n    },\n    checkDone: function() {\n      if (!this.inflight) {\n        this.oncomplete();\n      }\n    }\n  };\n  scope.Loader = Loader;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var Observer = function(addCallback) {\n    this.addCallback = addCallback;\n    this.mo = new MutationObserver(this.handler.bind(this));\n  };\n  Observer.prototype = {\n    handler: function(mutations) {\n      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {\n        if (m.type === "childList" && m.addedNodes.length) {\n          this.addedNodes(m.addedNodes);\n        }\n      }\n    },\n    addedNodes: function(nodes) {\n      if (this.addCallback) {\n        this.addCallback(nodes);\n      }\n      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {\n        if (n.children && n.children.length) {\n          this.addedNodes(n.children);\n        }\n      }\n    },\n    observe: function(root) {\n      this.mo.observe(root, {\n        childList: true,\n        subtree: true\n      });\n    }\n  };\n  scope.Observer = Observer;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var path = scope.path;\n  var rootDocument = scope.rootDocument;\n  var flags = scope.flags;\n  var isIE = scope.isIE;\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n  var IMPORT_SELECTOR = "link[rel=" + IMPORT_LINK_TYPE + "]";\n  var importParser = {\n    documentSelectors: IMPORT_SELECTOR,\n    importsSelectors: [ IMPORT_SELECTOR, "link[rel=stylesheet]:not([type])", "style:not([type])", "script:not([type])", \'script[type="application/javascript"]\', \'script[type="text/javascript"]\' ].join(","),\n    map: {\n      link: "parseLink",\n      script: "parseScript",\n      style: "parseStyle"\n    },\n    dynamicElements: [],\n    parseNext: function() {\n      var next = this.nextToParse();\n      if (next) {\n        this.parse(next);\n      }\n    },\n    parse: function(elt) {\n      if (this.isParsed(elt)) {\n        flags.parse && console.log("[%s] is already parsed", elt.localName);\n        return;\n      }\n      var fn = this[this.map[elt.localName]];\n      if (fn) {\n        this.markParsing(elt);\n        fn.call(this, elt);\n      }\n    },\n    parseDynamic: function(elt, quiet) {\n      this.dynamicElements.push(elt);\n      if (!quiet) {\n        this.parseNext();\n      }\n    },\n    markParsing: function(elt) {\n      flags.parse && console.log("parsing", elt);\n      this.parsingElement = elt;\n    },\n    markParsingComplete: function(elt) {\n      elt.__importParsed = true;\n      this.markDynamicParsingComplete(elt);\n      if (elt.__importElement) {\n        elt.__importElement.__importParsed = true;\n        this.markDynamicParsingComplete(elt.__importElement);\n      }\n      this.parsingElement = null;\n      flags.parse && console.log("completed", elt);\n    },\n    markDynamicParsingComplete: function(elt) {\n      var i = this.dynamicElements.indexOf(elt);\n      if (i >= 0) {\n        this.dynamicElements.splice(i, 1);\n      }\n    },\n    parseImport: function(elt) {\n      elt.import = elt.__doc;\n      if (window.HTMLImports.__importsParsingHook) {\n        window.HTMLImports.__importsParsingHook(elt);\n      }\n      if (elt.import) {\n        elt.import.__importParsed = true;\n      }\n      this.markParsingComplete(elt);\n      if (elt.__resource && !elt.__error) {\n        elt.dispatchEvent(new CustomEvent("load", {\n          bubbles: false\n        }));\n      } else {\n        elt.dispatchEvent(new CustomEvent("error", {\n          bubbles: false\n        }));\n      }\n      if (elt.__pending) {\n        var fn;\n        while (elt.__pending.length) {\n          fn = elt.__pending.shift();\n          if (fn) {\n            fn({\n              target: elt\n            });\n          }\n        }\n      }\n      this.parseNext();\n    },\n    parseLink: function(linkElt) {\n      if (nodeIsImport(linkElt)) {\n        this.parseImport(linkElt);\n      } else {\n        linkElt.href = linkElt.href;\n        this.parseGeneric(linkElt);\n      }\n    },\n    parseStyle: function(elt) {\n      var src = elt;\n      elt = cloneStyle(elt);\n      src.__appliedElement = elt;\n      elt.__importElement = src;\n      this.parseGeneric(elt);\n    },\n    parseGeneric: function(elt) {\n      this.trackElement(elt);\n      this.addElementToDocument(elt);\n    },\n    rootImportForElement: function(elt) {\n      var n = elt;\n      while (n.ownerDocument.__importLink) {\n        n = n.ownerDocument.__importLink;\n      }\n      return n;\n    },\n    addElementToDocument: function(elt) {\n      var port = this.rootImportForElement(elt.__importElement || elt);\n      port.parentNode.insertBefore(elt, port);\n    },\n    trackElement: function(elt, callback) {\n      var self = this;\n      var done = function(e) {\n        elt.removeEventListener("load", done);\n        elt.removeEventListener("error", done);\n        if (callback) {\n          callback(e);\n        }\n        self.markParsingComplete(elt);\n        self.parseNext();\n      };\n      elt.addEventListener("load", done);\n      elt.addEventListener("error", done);\n      if (isIE && elt.localName === "style") {\n        var fakeLoad = false;\n        if (elt.textContent.indexOf("@import") == -1) {\n          fakeLoad = true;\n        } else if (elt.sheet) {\n          fakeLoad = true;\n          var csr = elt.sheet.cssRules;\n          var len = csr ? csr.length : 0;\n          for (var i = 0, r; i < len && (r = csr[i]); i++) {\n            if (r.type === CSSRule.IMPORT_RULE) {\n              fakeLoad = fakeLoad && Boolean(r.styleSheet);\n            }\n          }\n        }\n        if (fakeLoad) {\n          setTimeout(function() {\n            elt.dispatchEvent(new CustomEvent("load", {\n              bubbles: false\n            }));\n          });\n        }\n      }\n    },\n    parseScript: function(scriptElt) {\n      var script = document.createElement("script");\n      script.__importElement = scriptElt;\n      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);\n      scope.currentScript = scriptElt;\n      this.trackElement(script, function(e) {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n        scope.currentScript = null;\n      });\n      this.addElementToDocument(script);\n    },\n    nextToParse: function() {\n      this._mayParse = [];\n      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());\n    },\n    nextToParseInDoc: function(doc, link) {\n      if (doc && this._mayParse.indexOf(doc) < 0) {\n        this._mayParse.push(doc);\n        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\n        for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n          if (!this.isParsed(n)) {\n            if (this.hasResource(n)) {\n              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;\n            } else {\n              return;\n            }\n          }\n        }\n      }\n      return link;\n    },\n    nextToParseDynamic: function() {\n      return this.dynamicElements[0];\n    },\n    parseSelectorsForNode: function(node) {\n      var doc = node.ownerDocument || node;\n      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;\n    },\n    isParsed: function(node) {\n      return node.__importParsed;\n    },\n    needsDynamicParsing: function(elt) {\n      return this.dynamicElements.indexOf(elt) >= 0;\n    },\n    hasResource: function(node) {\n      if (nodeIsImport(node) && node.__doc === undefined) {\n        return false;\n      }\n      return true;\n    }\n  };\n  function nodeIsImport(elt) {\n    return elt.localName === "link" && elt.rel === IMPORT_LINK_TYPE;\n  }\n  function generateScriptDataUrl(script) {\n    var scriptContent = generateScriptContent(script);\n    return "data:text/javascript;charset=utf-8," + encodeURIComponent(scriptContent);\n  }\n  function generateScriptContent(script) {\n    return script.textContent + generateSourceMapHint(script);\n  }\n  function generateSourceMapHint(script) {\n    var owner = script.ownerDocument;\n    owner.__importedScripts = owner.__importedScripts || 0;\n    var moniker = script.ownerDocument.baseURI;\n    var num = owner.__importedScripts ? "-" + owner.__importedScripts : "";\n    owner.__importedScripts++;\n    return "\\n//# sourceURL=" + moniker + num + ".js\\n";\n  }\n  function cloneStyle(style) {\n    var clone = style.ownerDocument.createElement("style");\n    clone.textContent = style.textContent;\n    path.resolveUrlsInStyle(clone);\n    return clone;\n  }\n  scope.parser = importParser;\n  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var flags = scope.flags;\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;\n  var rootDocument = scope.rootDocument;\n  var Loader = scope.Loader;\n  var Observer = scope.Observer;\n  var parser = scope.parser;\n  var importer = {\n    documents: {},\n    documentPreloadSelectors: IMPORT_SELECTOR,\n    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(","),\n    loadNode: function(node) {\n      importLoader.addNode(node);\n    },\n    loadSubtree: function(parent) {\n      var nodes = this.marshalNodes(parent);\n      importLoader.addNodes(nodes);\n    },\n    marshalNodes: function(parent) {\n      return parent.querySelectorAll(this.loadSelectorsForNode(parent));\n    },\n    loadSelectorsForNode: function(node) {\n      var doc = node.ownerDocument || node;\n      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;\n    },\n    loaded: function(url, elt, resource, err, redirectedUrl) {\n      flags.load && console.log("loaded", url, elt);\n      elt.__resource = resource;\n      elt.__error = err;\n      if (isImportLink(elt)) {\n        var doc = this.documents[url];\n        if (doc === undefined) {\n          doc = err ? null : makeDocument(resource, redirectedUrl || url);\n          if (doc) {\n            doc.__importLink = elt;\n            this.bootDocument(doc);\n          }\n          this.documents[url] = doc;\n        }\n        elt.__doc = doc;\n      }\n      parser.parseNext();\n    },\n    bootDocument: function(doc) {\n      this.loadSubtree(doc);\n      this.observer.observe(doc);\n      parser.parseNext();\n    },\n    loadedAll: function() {\n      parser.parseNext();\n    }\n  };\n  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));\n  importer.observer = new Observer();\n  function isImportLink(elt) {\n    return isLinkRel(elt, IMPORT_LINK_TYPE);\n  }\n  function isLinkRel(elt, rel) {\n    return elt.localName === "link" && elt.getAttribute("rel") === rel;\n  }\n  function hasBaseURIAccessor(doc) {\n    return !!Object.getOwnPropertyDescriptor(doc, "baseURI");\n  }\n  function makeDocument(resource, url) {\n    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\n    doc._URL = url;\n    var base = doc.createElement("base");\n    base.setAttribute("href", url);\n    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {\n      Object.defineProperty(doc, "baseURI", {\n        value: url\n      });\n    }\n    var meta = doc.createElement("meta");\n    meta.setAttribute("charset", "utf-8");\n    doc.head.appendChild(meta);\n    doc.head.appendChild(base);\n    doc.body.innerHTML = resource;\n    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\n      HTMLTemplateElement.bootstrap(doc);\n    }\n    return doc;\n  }\n  if (!document.baseURI) {\n    var baseURIDescriptor = {\n      get: function() {\n        var base = document.querySelector("base");\n        return base ? base.href : window.location.href;\n      },\n      configurable: true\n    };\n    Object.defineProperty(document, "baseURI", baseURIDescriptor);\n    Object.defineProperty(rootDocument, "baseURI", baseURIDescriptor);\n  }\n  scope.importer = importer;\n  scope.importLoader = importLoader;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var parser = scope.parser;\n  var importer = scope.importer;\n  var dynamic = {\n    added: function(nodes) {\n      var owner, parsed, loading;\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        if (!owner) {\n          owner = n.ownerDocument;\n          parsed = parser.isParsed(owner);\n        }\n        loading = this.shouldLoadNode(n);\n        if (loading) {\n          importer.loadNode(n);\n        }\n        if (this.shouldParseNode(n) && parsed) {\n          parser.parseDynamic(n, loading);\n        }\n      }\n    },\n    shouldLoadNode: function(node) {\n      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));\n    },\n    shouldParseNode: function(node) {\n      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));\n    }\n  };\n  importer.observer.addCallback = dynamic.added.bind(dynamic);\n  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;\n});\n\n(function(scope) {\n  var initializeModules = scope.initializeModules;\n  var isIE = scope.isIE;\n  if (scope.useNative) {\n    return;\n  }\n  initializeModules();\n  var rootDocument = scope.rootDocument;\n  function bootstrap() {\n    window.HTMLImports.importer.bootDocument(rootDocument);\n  }\n  if (document.readyState === "complete" || document.readyState === "interactive" && !window.attachEvent) {\n    bootstrap();\n  } else {\n    document.addEventListener("DOMContentLoaded", bootstrap);\n  }\n})(window.HTMLImports);\n\nwindow.CustomElements = window.CustomElements || {\n  flags: {}\n};\n\n(function(scope) {\n  var flags = scope.flags;\n  var modules = [];\n  var addModule = function(module) {\n    modules.push(module);\n  };\n  var initializeModules = function() {\n    modules.forEach(function(module) {\n      module(scope);\n    });\n  };\n  scope.addModule = addModule;\n  scope.initializeModules = initializeModules;\n  scope.hasNative = Boolean(document.registerElement);\n  scope.isIE = /Trident/.test(navigator.userAgent);\n  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);\n})(window.CustomElements);\n\nwindow.CustomElements.addModule(function(scope) {\n  var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : "none";\n  function forSubtree(node, cb) {\n    findAllElements(node, function(e) {\n      if (cb(e)) {\n        return true;\n      }\n      forRoots(e, cb);\n    });\n    forRoots(node, cb);\n  }\n  function findAllElements(node, find, data) {\n    var e = node.firstElementChild;\n    if (!e) {\n      e = node.firstChild;\n      while (e && e.nodeType !== Node.ELEMENT_NODE) {\n        e = e.nextSibling;\n      }\n    }\n    while (e) {\n      if (find(e, data) !== true) {\n        findAllElements(e, find, data);\n      }\n      e = e.nextElementSibling;\n    }\n    return null;\n  }\n  function forRoots(node, cb) {\n    var root = node.shadowRoot;\n    while (root) {\n      forSubtree(root, cb);\n      root = root.olderShadowRoot;\n    }\n  }\n  function forDocumentTree(doc, cb) {\n    _forDocumentTree(doc, cb, []);\n  }\n  function _forDocumentTree(doc, cb, processingDocuments) {\n    doc = window.wrap(doc);\n    if (processingDocuments.indexOf(doc) >= 0) {\n      return;\n    }\n    processingDocuments.push(doc);\n    var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");\n    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {\n      if (n.import) {\n        _forDocumentTree(n.import, cb, processingDocuments);\n      }\n    }\n    cb(doc);\n  }\n  scope.forDocumentTree = forDocumentTree;\n  scope.forSubtree = forSubtree;\n});\n\nwindow.CustomElements.addModule(function(scope) {\n  var flags = scope.flags;\n  var forSubtree = scope.forSubtree;\n  var forDocumentTree = scope.forDocumentTree;\n  function addedNode(node, isAttached) {\n    return added(node, isAttached) || addedSubtree(node, isAttached);\n  }\n  function added(node, isAttached) {\n    if (scope.upgrade(node, isAttached)) {\n      return true;\n    }\n    if (isAttached) {\n      attached(node);\n    }\n  }\n  function addedSubtree(node, isAttached) {\n    forSubtree(node, function(e) {\n      if (added(e, isAttached)) {\n        return true;\n      }\n    });\n  }\n  var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags["throttle-attached"];\n  scope.hasPolyfillMutations = hasThrottledAttached;\n  scope.hasThrottledAttached = hasThrottledAttached;\n  var isPendingMutations = false;\n  var pendingMutations = [];\n  function deferMutation(fn) {\n    pendingMutations.push(fn);\n    if (!isPendingMutations) {\n      isPendingMutations = true;\n      setTimeout(takeMutations);\n    }\n  }\n  function takeMutations() {\n    isPendingMutations = false;\n    var $p = pendingMutations;\n    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n      p();\n    }\n    pendingMutations = [];\n  }\n  function attached(element) {\n    if (hasThrottledAttached) {\n      deferMutation(function() {\n        _attached(element);\n      });\n    } else {\n      _attached(element);\n    }\n  }\n  function _attached(element) {\n    if (element.__upgraded__ && !element.__attached) {\n      element.__attached = true;\n      if (element.attachedCallback) {\n        element.attachedCallback();\n      }\n    }\n  }\n  function detachedNode(node) {\n    detached(node);\n    forSubtree(node, function(e) {\n      detached(e);\n    });\n  }\n  function detached(element) {\n    if (hasThrottledAttached) {\n      deferMutation(function() {\n        _detached(element);\n      });\n    } else {\n      _detached(element);\n    }\n  }\n  function _detached(element) {\n    if (element.__upgraded__ && element.__attached) {\n      element.__attached = false;\n      if (element.detachedCallback) {\n        element.detachedCallback();\n      }\n    }\n  }\n  function inDocument(element) {\n    var p = element;\n    var doc = window.wrap(document);\n    while (p) {\n      if (p == doc) {\n        return true;\n      }\n      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;\n    }\n  }\n  function watchShadow(node) {\n    if (node.shadowRoot && !node.shadowRoot.__watched) {\n      flags.dom && console.log("watching shadow-root for: ", node.localName);\n      var root = node.shadowRoot;\n      while (root) {\n        observe(root);\n        root = root.olderShadowRoot;\n      }\n    }\n  }\n  function handler(root, mutations) {\n    if (flags.dom) {\n      var mx = mutations[0];\n      if (mx && mx.type === "childList" && mx.addedNodes) {\n        if (mx.addedNodes) {\n          var d = mx.addedNodes[0];\n          while (d && d !== document && !d.host) {\n            d = d.parentNode;\n          }\n          var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";\n          u = u.split("/?").shift().split("/").pop();\n        }\n      }\n      console.group("mutations (%d) [%s]", mutations.length, u || "");\n    }\n    var isAttached = inDocument(root);\n    mutations.forEach(function(mx) {\n      if (mx.type === "childList") {\n        forEach(mx.addedNodes, function(n) {\n          if (!n.localName) {\n            return;\n          }\n          addedNode(n, isAttached);\n        });\n        forEach(mx.removedNodes, function(n) {\n          if (!n.localName) {\n            return;\n          }\n          detachedNode(n);\n        });\n      }\n    });\n    flags.dom && console.groupEnd();\n  }\n  function takeRecords(node) {\n    node = window.wrap(node);\n    if (!node) {\n      node = window.wrap(document);\n    }\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    var observer = node.__observer;\n    if (observer) {\n      handler(node, observer.takeRecords());\n      takeMutations();\n    }\n  }\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n  function observe(inRoot) {\n    if (inRoot.__observer) {\n      return;\n    }\n    var observer = new MutationObserver(handler.bind(this, inRoot));\n    observer.observe(inRoot, {\n      childList: true,\n      subtree: true\n    });\n    inRoot.__observer = observer;\n  }\n  function upgradeDocument(doc) {\n    doc = window.wrap(doc);\n    flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());\n    var isMainDocument = doc === window.wrap(document);\n    addedNode(doc, isMainDocument);\n    observe(doc);\n    flags.dom && console.groupEnd();\n  }\n  function upgradeDocumentTree(doc) {\n    forDocumentTree(doc, upgradeDocument);\n  }\n  var originalCreateShadowRoot = Element.prototype.createShadowRoot;\n  if (originalCreateShadowRoot) {\n    Element.prototype.createShadowRoot = function() {\n      var root = originalCreateShadowRoot.call(this);\n      window.CustomElements.watchShadow(this);\n      return root;\n    };\n  }\n  scope.watchShadow = watchShadow;\n  scope.upgradeDocumentTree = upgradeDocumentTree;\n  scope.upgradeDocument = upgradeDocument;\n  scope.upgradeSubtree = addedSubtree;\n  scope.upgradeAll = addedNode;\n  scope.attached = attached;\n  scope.takeRecords = takeRecords;\n});\n\nwindow.CustomElements.addModule(function(scope) {\n  var flags = scope.flags;\n  function upgrade(node, isAttached) {\n    if (node.localName === "template") {\n      if (window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(node);\n      }\n    }\n    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {\n      var is = node.getAttribute("is");\n      var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);\n      if (definition) {\n        if (is && definition.tag == node.localName || !is && !definition.extends) {\n          return upgradeWithDefinition(node, definition, isAttached);\n        }\n      }\n    }\n  }\n  function upgradeWithDefinition(element, definition, isAttached) {\n    flags.upgrade && console.group("upgrade:", element.localName);\n    if (definition.is) {\n      element.setAttribute("is", definition.is);\n    }\n    implementPrototype(element, definition);\n    element.__upgraded__ = true;\n    created(element);\n    if (isAttached) {\n      scope.attached(element);\n    }\n    scope.upgradeSubtree(element, isAttached);\n    flags.upgrade && console.groupEnd();\n    return element;\n  }\n  function implementPrototype(element, definition) {\n    if (Object.__proto__) {\n      element.__proto__ = definition.prototype;\n    } else {\n      customMixin(element, definition.prototype, definition.native);\n      element.__proto__ = definition.prototype;\n    }\n  }\n  function customMixin(inTarget, inSrc, inNative) {\n    var used = {};\n    var p = inSrc;\n    while (p !== inNative && p !== HTMLElement.prototype) {\n      var keys = Object.getOwnPropertyNames(p);\n      for (var i = 0, k; k = keys[i]; i++) {\n        if (!used[k]) {\n          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));\n          used[k] = 1;\n        }\n      }\n      p = Object.getPrototypeOf(p);\n    }\n  }\n  function created(element) {\n    if (element.createdCallback) {\n      element.createdCallback();\n    }\n  }\n  scope.upgrade = upgrade;\n  scope.upgradeWithDefinition = upgradeWithDefinition;\n  scope.implementPrototype = implementPrototype;\n});\n\nwindow.CustomElements.addModule(function(scope) {\n  var isIE = scope.isIE;\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\n  var upgradeAll = scope.upgradeAll;\n  var upgradeWithDefinition = scope.upgradeWithDefinition;\n  var implementPrototype = scope.implementPrototype;\n  var useNative = scope.useNative;\n  function register(name, options) {\n    var definition = options || {};\n    if (!name) {\n      throw new Error("document.registerElement: first argument `name` must not be empty");\n    }\n    if (name.indexOf("-") < 0) {\n      throw new Error("document.registerElement: first argument (\'name\') must contain a dash (\'-\'). Argument provided was \'" + String(name) + "\'.");\n    }\n    if (isReservedTag(name)) {\n      throw new Error("Failed to execute \'registerElement\' on \'Document\': Registration failed for type \'" + String(name) + "\'. The type name is invalid.");\n    }\n    if (getRegisteredDefinition(name)) {\n      throw new Error("DuplicateDefinitionError: a type with name \'" + String(name) + "\' is already registered");\n    }\n    if (!definition.prototype) {\n      definition.prototype = Object.create(HTMLElement.prototype);\n    }\n    definition.__name = name.toLowerCase();\n    if (definition.extends) {\n      definition.extends = definition.extends.toLowerCase();\n    }\n    definition.lifecycle = definition.lifecycle || {};\n    definition.ancestry = ancestry(definition.extends);\n    resolveTagName(definition);\n    resolvePrototypeChain(definition);\n    overrideAttributeApi(definition.prototype);\n    registerDefinition(definition.__name, definition);\n    definition.ctor = generateConstructor(definition);\n    definition.ctor.prototype = definition.prototype;\n    definition.prototype.constructor = definition.ctor;\n    if (scope.ready) {\n      upgradeDocumentTree(document);\n    }\n    return definition.ctor;\n  }\n  function overrideAttributeApi(prototype) {\n    if (prototype.setAttribute._polyfilled) {\n      return;\n    }\n    var setAttribute = prototype.setAttribute;\n    prototype.setAttribute = function(name, value) {\n      changeAttribute.call(this, name, value, setAttribute);\n    };\n    var removeAttribute = prototype.removeAttribute;\n    prototype.removeAttribute = function(name) {\n      changeAttribute.call(this, name, null, removeAttribute);\n    };\n    prototype.setAttribute._polyfilled = true;\n  }\n  function changeAttribute(name, value, operation) {\n    name = name.toLowerCase();\n    var oldValue = this.getAttribute(name);\n    operation.apply(this, arguments);\n    var newValue = this.getAttribute(name);\n    if (this.attributeChangedCallback && newValue !== oldValue) {\n      this.attributeChangedCallback(name, oldValue, newValue);\n    }\n  }\n  function isReservedTag(name) {\n    for (var i = 0; i < reservedTagList.length; i++) {\n      if (name === reservedTagList[i]) {\n        return true;\n      }\n    }\n  }\n  var reservedTagList = [ "annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph" ];\n  function ancestry(extnds) {\n    var extendee = getRegisteredDefinition(extnds);\n    if (extendee) {\n      return ancestry(extendee.extends).concat([ extendee ]);\n    }\n    return [];\n  }\n  function resolveTagName(definition) {\n    var baseTag = definition.extends;\n    for (var i = 0, a; a = definition.ancestry[i]; i++) {\n      baseTag = a.is && a.tag;\n    }\n    definition.tag = baseTag || definition.__name;\n    if (baseTag) {\n      definition.is = definition.__name;\n    }\n  }\n  function resolvePrototypeChain(definition) {\n    if (!Object.__proto__) {\n      var nativePrototype = HTMLElement.prototype;\n      if (definition.is) {\n        var inst = document.createElement(definition.tag);\n        nativePrototype = Object.getPrototypeOf(inst);\n      }\n      var proto = definition.prototype, ancestor;\n      var foundPrototype = false;\n      while (proto) {\n        if (proto == nativePrototype) {\n          foundPrototype = true;\n        }\n        ancestor = Object.getPrototypeOf(proto);\n        if (ancestor) {\n          proto.__proto__ = ancestor;\n        }\n        proto = ancestor;\n      }\n      if (!foundPrototype) {\n        console.warn(definition.tag + " prototype not found in prototype chain for " + definition.is);\n      }\n      definition.native = nativePrototype;\n    }\n  }\n  function instantiate(definition) {\n    return upgradeWithDefinition(domCreateElement(definition.tag), definition);\n  }\n  var registry = {};\n  function getRegisteredDefinition(name) {\n    if (name) {\n      return registry[name.toLowerCase()];\n    }\n  }\n  function registerDefinition(name, definition) {\n    registry[name] = definition;\n  }\n  function generateConstructor(definition) {\n    return function() {\n      return instantiate(definition);\n    };\n  }\n  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";\n  function createElementNS(namespace, tag, typeExtension) {\n    if (namespace === HTML_NAMESPACE) {\n      return createElement(tag, typeExtension);\n    } else {\n      return domCreateElementNS(namespace, tag);\n    }\n  }\n  function createElement(tag, typeExtension) {\n    if (tag) {\n      tag = tag.toLowerCase();\n    }\n    if (typeExtension) {\n      typeExtension = typeExtension.toLowerCase();\n    }\n    var definition = getRegisteredDefinition(typeExtension || tag);\n    if (definition) {\n      if (tag == definition.tag && typeExtension == definition.is) {\n        return new definition.ctor();\n      }\n      if (!typeExtension && !definition.is) {\n        return new definition.ctor();\n      }\n    }\n    var element;\n    if (typeExtension) {\n      element = createElement(tag);\n      element.setAttribute("is", typeExtension);\n      return element;\n    }\n    element = domCreateElement(tag);\n    if (tag.indexOf("-") >= 0) {\n      implementPrototype(element, HTMLElement);\n    }\n    return element;\n  }\n  var domCreateElement = document.createElement.bind(document);\n  var domCreateElementNS = document.createElementNS.bind(document);\n  var isInstance;\n  if (!Object.__proto__ && !useNative) {\n    isInstance = function(obj, ctor) {\n      if (obj instanceof ctor) {\n        return true;\n      }\n      var p = obj;\n      while (p) {\n        if (p === ctor.prototype) {\n          return true;\n        }\n        p = p.__proto__;\n      }\n      return false;\n    };\n  } else {\n    isInstance = function(obj, base) {\n      return obj instanceof base;\n    };\n  }\n  function wrapDomMethodToForceUpgrade(obj, methodName) {\n    var orig = obj[methodName];\n    obj[methodName] = function() {\n      var n = orig.apply(this, arguments);\n      upgradeAll(n);\n      return n;\n    };\n  }\n  wrapDomMethodToForceUpgrade(Node.prototype, "cloneNode");\n  wrapDomMethodToForceUpgrade(document, "importNode");\n  document.registerElement = register;\n  document.createElement = createElement;\n  document.createElementNS = createElementNS;\n  scope.registry = registry;\n  scope.instanceof = isInstance;\n  scope.reservedTagList = reservedTagList;\n  scope.getRegisteredDefinition = getRegisteredDefinition;\n  document.register = document.registerElement;\n});\n\n(function(scope) {\n  var useNative = scope.useNative;\n  var initializeModules = scope.initializeModules;\n  var isIE = scope.isIE;\n  if (useNative) {\n    var nop = function() {};\n    scope.watchShadow = nop;\n    scope.upgrade = nop;\n    scope.upgradeAll = nop;\n    scope.upgradeDocumentTree = nop;\n    scope.upgradeSubtree = nop;\n    scope.takeRecords = nop;\n    scope.instanceof = function(obj, base) {\n      return obj instanceof base;\n    };\n  } else {\n    initializeModules();\n  }\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\n  var upgradeDocument = scope.upgradeDocument;\n  if (!window.wrap) {\n    if (window.ShadowDOMPolyfill) {\n      window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;\n      window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;\n    } else {\n      window.wrap = window.unwrap = function(node) {\n        return node;\n      };\n    }\n  }\n  if (window.HTMLImports) {\n    window.HTMLImports.__importsParsingHook = function(elt) {\n      if (elt.import) {\n        upgradeDocument(wrap(elt.import));\n      }\n    };\n  }\n  function bootstrap() {\n    upgradeDocumentTree(window.wrap(document));\n    window.CustomElements.ready = true;\n    var requestAnimationFrame = window.requestAnimationFrame || function(f) {\n      setTimeout(f, 16);\n    };\n    requestAnimationFrame(function() {\n      setTimeout(function() {\n        window.CustomElements.readyTime = Date.now();\n        if (window.HTMLImports) {\n          window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;\n        }\n        document.dispatchEvent(new CustomEvent("WebComponentsReady", {\n          bubbles: true\n        }));\n      });\n    });\n  }\n  if (document.readyState === "complete" || scope.flags.eager) {\n    bootstrap();\n  } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {\n    bootstrap();\n  } else {\n    var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";\n    window.addEventListener(loadEvent, bootstrap);\n  }\n})(window.CustomElements);\n\n(function(scope) {\n  if (!Function.prototype.bind) {\n    Function.prototype.bind = function(scope) {\n      var self = this;\n      var args = Array.prototype.slice.call(arguments, 1);\n      return function() {\n        var args2 = args.slice();\n        args2.push.apply(args2, arguments);\n        return self.apply(scope, args2);\n      };\n    };\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  var style = document.createElement("style");\n  style.textContent = "" + "body {" + "transition: opacity ease-in 0.2s;" + " } \\n" + "body[unresolved] {" + "opacity: 0; display: block; overflow: hidden; position: relative;" + " } \\n";\n  var head = document.querySelector("head");\n  head.insertBefore(style, head.firstChild);\n})(window.WebComponents);\n\n(function(scope) {\n  window.Platform = scope;\n})(window.WebComponents);';
},function(e,n){var t=document.createElement("link");t.rel="import",t.href=".//imports.html",document.head.appendChild(t)},function(e,n){},,,,function(e,n){(function(){"use strict";function n(e){function n(n){return function(t){return e(n,t)}}return n.arity=2,n.func=e,n}function t(e){function n(n){return function(t){return function(r){return e(n,t,r)}}}return n.arity=3,n.func=e,n}function r(e){function n(n){return function(t){return function(r){return function(o){return e(n,t,r,o)}}}}return n.arity=4,n.func=e,n}function o(e){function n(n){return function(t){return function(r){return function(o){return function(a){return e(n,t,r,o,a)}}}}}return n.arity=5,n.func=e,n}function a(e){function n(n){return function(t){return function(r){return function(o){return function(a){return function(i){return e(n,t,r,o,a,i)}}}}}}return n.arity=6,n.func=e,n}function i(e){function n(n){return function(t){return function(r){return function(o){return function(a){return function(i){return function(s){return e(n,t,r,o,a,i,s)}}}}}}}return n.arity=7,n.func=e,n}function s(e){function n(n){return function(t){return function(r){return function(o){return function(a){return function(i){return function(s){return function(c){return e(n,t,r,o,a,i,s,c)}}}}}}}}return n.arity=8,n.func=e,n}function c(e){function n(n){return function(t){return function(r){return function(o){return function(a){return function(i){return function(s){return function(c){return function(l){return e(n,t,r,o,a,i,s,c,l)}}}}}}}}}return n.arity=9,n.func=e,n}function l(e,n,t){return 2===e.arity?e.func(n,t):e(n)(t)}function d(e,n,t,r){return 3===e.arity?e.func(n,t,r):e(n)(t)(r)}function u(e,n,t,r,o){return 4===e.arity?e.func(n,t,r,o):e(n)(t)(r)(o)}function p(e,n,t,r,o,a){return 5===e.arity?e.func(n,t,r,o,a):e(n)(t)(r)(o)(a)}var f=function(){function e(e,n){if(e<0||e>=W(n))throw new Error("Index "+e+" is out of range. Check the length of your array first or use getMaybe or getWithDefault.");return r(e,n)}function r(e,n){for(var t=n.height;t>0;t--){for(var r=e>>5*t;n.lengths[r]<=e;)r++;r>0&&(e-=n.lengths[r-1]),n=n.table[r]}return n.table[e]}function o(e,n,t){return e<0||W(t)<=e?t:a(e,n,t)}function a(e,n,t){if(t=P(t),0===t.height)t.table[e]=n;else{var r=A(e,t);r>0&&(e-=t.lengths[r-1]),t.table[r]=a(e,n,t.table[r])}return t}function i(e,n){if(e<=0)return K;var t=Math.floor(Math.log(e)/Math.log(z));return s(n,t,0,e)}function s(e,n,t,r){if(0===n){for(var o=new Array((r-t)%(z+1)),a=0;a<o.length;a++)o[a]=e(t+a);return{ctor:"_Array",height:0,table:o}}for(var i=Math.pow(z,n),o=new Array(Math.ceil((r-t)/i)),c=new Array(o.length),a=0;a<o.length;a++)o[a]=s(e,n-1,t+a*i,Math.min(t+(a+1)*i,r)),c[a]=W(o[a])+(a>0?c[a-1]:0);return{ctor:"_Array",height:n,table:o,lengths:c}}function c(e){if("[]"===e.ctor)return K;for(var n=new Array(z),t=[],r=0;"[]"!==e.ctor;)if(n[r]=e._0,e=e._1,r++,r===z){var o={ctor:"_Array",height:0,table:n};d(o,t),n=new Array(z),r=0}if(r>0){var o={ctor:"_Array",height:0,table:n.splice(0,r)};d(o,t)}for(var a=0;a<t.length-1;a++)t[a].table.length>0&&d(t[a],t);var i=t[t.length-1];return i.height>0&&1===i.table.length?i.table[0]:i}function d(e,n){var t=e.height;if(n.length===t){var r={ctor:"_Array",height:t+1,table:[],lengths:[]};n.push(r)}n[t].table.push(e);var o=W(e);n[t].lengths.length>0&&(o+=n[t].lengths[n[t].lengths.length-1]),n[t].lengths.push(o),n[t].table.length===z&&(d(n[t],n),n[t]={ctor:"_Array",height:t+1,table:[],lengths:[]})}function u(e,n){var t=p(e,n);if(null!==t)return t;var r=U(e,n.height);return j(n,r)}function p(e,n){if(0===n.height){if(n.table.length<z){var t={ctor:"_Array",height:0,table:n.table.slice()};return t.table.push(e),t}return null}var r=p(e,D(n));if(null!==r){var t=P(n);return t.table[t.table.length-1]=r,t.lengths[t.lengths.length-1]++,t}if(n.table.length<z){var o=U(e,n.height-1),t=P(n);return t.table.push(o),t.lengths.push(t.lengths[t.lengths.length-1]+W(o)),t}return null}function f(e){return h(y.Nil,e)}function h(e,n){for(var t=n.table.length-1;t>=0;t--)e=0===n.height?y.Cons(n.table[t],e):h(e,n.table[t]);return e}function m(e,n){var t={ctor:"_Array",height:n.height,table:new Array(n.table.length)};n.height>0&&(t.lengths=n.lengths);for(var r=0;r<n.table.length;r++)t.table[r]=0===n.height?e(n.table[r]):m(e,n.table[r]);return t}function v(e,n){return g(e,n,0)}function g(e,n,t){var r={ctor:"_Array",height:n.height,table:new Array(n.table.length)};n.height>0&&(r.lengths=n.lengths);for(var o=0;o<n.table.length;o++)r.table[o]=0===n.height?l(e,t+o,n.table[o]):g(e,n.table[o],0==o?t:t+n.lengths[o-1]);return r}function w(e,n,t){if(0===t.height)for(var r=0;r<t.table.length;r++)n=l(e,t.table[r],n);else for(var r=0;r<t.table.length;r++)n=w(e,n,t.table[r]);return n}function _(e,n,t){if(0===t.height)for(var r=t.table.length;r--;)n=l(e,t.table[r],n);else for(var r=t.table.length;r--;)n=_(e,n,t.table[r]);return n}function b(e,n,t){return e<0&&(e+=W(t)),n<0&&(n+=W(t)),E(e,T(n,t))}function T(e,n){if(e===W(n))return n;if(0===n.height){var t={ctor:"_Array",height:0};return t.table=n.table.slice(0,e),t}var r=A(e,n),o=T(e-(r>0?n.lengths[r-1]:0),n.table[r]);if(0===r)return o;var t={ctor:"_Array",height:n.height,table:n.table.slice(0,r),lengths:n.lengths.slice(0,r)};return o.table.length>0&&(t.table[r]=o,t.lengths[r]=W(o)+(r>0?t.lengths[r-1]:0)),t}function E(e,n){if(0===e)return n;if(0===n.height){var t={ctor:"_Array",height:0};return t.table=n.table.slice(e,n.table.length+1),t}var r=A(e,n),o=E(e-(r>0?n.lengths[r-1]:0),n.table[r]);if(r===n.table.length-1)return o;var t={ctor:"_Array",height:n.height,table:n.table.slice(r,n.table.length+1),lengths:new Array(n.table.length-r)};t.table[0]=o;for(var a=0,i=0;i<t.table.length;i++)a+=W(t.table[i]),t.lengths[i]=a;return t}function N(e,n){if(0===e.table.length)return n;if(0===n.table.length)return e;var t=S(e,n);if(t[0].table.length+t[1].table.length<=z){if(0===t[0].table.length)return t[1];if(0===t[1].table.length)return t[0];if(t[0].table=t[0].table.concat(t[1].table),t[0].height>0){for(var r=W(t[0]),o=0;o<t[1].lengths.length;o++)t[1].lengths[o]+=r;t[0].lengths=t[0].lengths.concat(t[1].lengths)}return t[0]}if(t[0].height>0){var a=L(e,n);a>J&&(t=k(t[0],t[1],a))}return j(t[0],t[1])}function S(e,n){if(0===e.height&&0===n.height)return[e,n];if(1!==e.height||1!==n.height)if(e.height===n.height){e=P(e),n=P(n);var t=S(D(e),H(n));M(e,t[1]),C(n,t[0])}else if(e.height>n.height){e=P(e);var t=S(D(e),n);M(e,t[0]),n=B(t[1],t[1].height+1)}else{n=P(n);var t=S(e,H(n)),r=0===t[0].table.length?0:1,o=0===r?1:0;C(n,t[r]),e=B(t[o],t[o].height+1)}if(0===e.table.length||0===n.table.length)return[e,n];var a=L(e,n);return a<=J?[e,n]:k(e,n,a)}function M(e,n){var t=e.table.length-1;e.table[t]=n,e.lengths[t]=W(n),e.lengths[t]+=t>0?e.lengths[t-1]:0}function C(e,n){if(n.table.length>0){e.table[0]=n,e.lengths[0]=W(n);for(var t=W(e.table[0]),r=1;r<e.lengths.length;r++)t+=W(e.table[r]),e.lengths[r]=t}else{e.table.shift();for(var r=1;r<e.lengths.length;r++)e.lengths[r]=e.lengths[r]-e.lengths[0];e.lengths.shift()}}function L(e,n){for(var t=0,r=0;r<e.table.length;r++)t+=e.table[r].table.length;for(var r=0;r<n.table.length;r++)t+=n.table[r].table.length;var o=e.table.length+n.table.length;return o-(Math.floor((t-1)/z)+1)}function x(e,n,t){return t<e.length?e[t]:n[t-e.length]}function R(e,n,t,r){t<e.length?e[t]=r:n[t-e.length]=r}function O(e,n,t,r){R(e.table,n.table,t,r);var o=0===t||t===e.lengths.length?0:x(e.lengths,e.lengths,t-1);R(e.lengths,n.lengths,t,o+W(r))}function I(e,n){n<0&&(n=0);var t={ctor:"_Array",height:e,table:new Array(n)};return e>0&&(t.lengths=new Array(n)),t}function k(e,n,t){for(var r=I(e.height,Math.min(z,e.table.length+n.table.length-t)),o=I(e.height,r.table.length-(e.table.length+n.table.length-t)),a=0;x(e.table,n.table,a).table.length%z===0;)R(r.table,o.table,a,x(e.table,n.table,a)),R(r.lengths,o.lengths,a,x(e.lengths,n.lengths,a)),a++;for(var i=a,s=new I(e.height-1,0),c=0;a-i-(s.table.length>0?1:0)<t;){var l=x(e.table,n.table,a),d=Math.min(z-s.table.length,l.table.length);if(s.table=s.table.concat(l.table.slice(c,d)),s.height>0)for(var u=s.lengths.length,p=u;p<u+d-c;p++)s.lengths[p]=W(s.table[p]),s.lengths[p]+=p>0?s.lengths[p-1]:0;c+=d,l.table.length<=d&&(a++,c=0),s.table.length===z&&(O(r,o,i,s),s=I(e.height-1,0),i++)}for(s.table.length>0&&(O(r,o,i,s),i++);a<e.table.length+n.table.length;)O(r,o,i,x(e.table,n.table,a)),a++,i++;return[r,o]}function D(e){return e.table[e.table.length-1]}function H(e){return e.table[0]}function P(e){var n={ctor:"_Array",height:e.height,table:e.table.slice()};return e.height>0&&(n.lengths=e.lengths.slice()),n}function W(e){return 0===e.height?e.table.length:e.lengths[e.lengths.length-1]}function A(e,n){for(var t=e>>5*n.height;n.lengths[t]<=e;)t++;return t}function U(e,n){return 0===n?{ctor:"_Array",height:0,table:[e]}:{ctor:"_Array",height:n,table:[U(e,n-1)],lengths:[1]}}function B(e,n){return n===e.height?e:{ctor:"_Array",height:n,table:[B(e,n-1)],lengths:[W(e)]}}function j(e,n){return{ctor:"_Array",height:e.height+1,table:[e,n],lengths:[W(e),W(e)+W(n)]}}function F(e){var n=new Array(W(e));return q(n,0,e),n}function q(e,n,t){for(var r=0;r<t.table.length;r++)if(0===t.height)e[n+r]=t.table[r];else{var o=0===r?0:t.lengths[r-1];q(e,n+o,t.table[r])}}function G(e){if(0===e.length)return K;var n=Math.floor(Math.log(e.length)/Math.log(z));return V(e,n,0,e.length)}function V(e,n,t,r){if(0===n)return{ctor:"_Array",height:0,table:e.slice(t,r)};for(var o=Math.pow(z,n),a=new Array(Math.ceil((r-t)/o)),i=new Array(a.length),s=0;s<a.length;s++)a[s]=V(e,n-1,t+s*o,Math.min(t+(s+1)*o,r)),i[s]=W(a[s])+(s>0?i[s-1]:0);return{ctor:"_Array",height:n,table:a,lengths:i}}var z=32,J=2,K={ctor:"_Array",height:0,table:[]};return{empty:K,fromList:c,toList:f,initialize:n(i),append:n(N),push:n(u),slice:t(b),get:n(e),set:t(o),map:n(m),indexedMap:n(v),foldl:t(w),foldr:t(_),length:W,toJSArray:F,fromJSArray:G}}(),h=function(){function e(e,n){return e/n|0}function r(e,n){return e%n}function o(e,n){if(0===n)throw new Error("Cannot perform mod 0. Division by zero error.");var t=e%n,r=0===e?0:n>0?e>=0?t:t+n:-o(-e,-n);return r===n?0:r}function a(e,n){return Math.log(n)/Math.log(e)}function i(e){return-e}function s(e){return e<0?-e:e}function c(e,n){return m.cmp(e,n)<0?e:n}function l(e,n){return m.cmp(e,n)>0?e:n}function d(e,n,t){return m.cmp(t,e)<0?e:m.cmp(t,n)>0?n:t}function u(e,n){return{ctor:T[m.cmp(e,n)+1]}}function p(e,n){return e!==n}function f(e){return!e}function h(e){return e===1/0||e===-(1/0)}function v(e){return 0|e}function g(e){return e*Math.PI/180}function w(e){return 2*Math.PI*e}function _(e){var n=e._0,t=e._1;return m.Tuple2(n*Math.cos(t),n*Math.sin(t))}function b(e){var n=e._0,t=e._1;return m.Tuple2(Math.sqrt(n*n+t*t),Math.atan2(t,n))}var T=["LT","EQ","GT"];return{div:n(e),rem:n(r),mod:n(o),pi:Math.PI,e:Math.E,cos:Math.cos,sin:Math.sin,tan:Math.tan,acos:Math.acos,asin:Math.asin,atan:Math.atan,atan2:n(Math.atan2),degrees:g,turns:w,fromPolar:_,toPolar:b,sqrt:Math.sqrt,logBase:n(a),negate:i,abs:s,min:n(c),max:n(l),clamp:t(d),compare:n(u),xor:n(p),not:f,truncate:v,ceiling:Math.ceil,floor:Math.floor,round:Math.round,toFloat:function(e){return e},isNaN:isNaN,isInfinite:h}}(),m=function(){function e(e,n){for(var r,o=[],a=t(e,n,0,o);a&&(r=o.pop());)a=t(r.x,r.y,0,o);return a}function t(e,n,r,o){if(r>100)return o.push({x:e,y:n}),!0;if(e===n)return!0;if("object"!=typeof e){if("function"==typeof e)throw new Error('Trying to use `(==)` on functions. There is no way to know if functions are "the same" in the Elm sense. Read more about this at http://package.elm-lang.org/packages/elm-lang/core/latest/Basics#== which describes why it is this way and what the better version will look like.');return!1}if(null===e||null===n)return!1;if(e instanceof Date)return e.getTime()===n.getTime();if(!("ctor"in e)){for(var a in e)if(!t(e[a],n[a],r+1,o))return!1;return!0}if("RBNode_elm_builtin"!==e.ctor&&"RBEmpty_elm_builtin"!==e.ctor||(e=Q(e),n=Q(n)),"Set_elm_builtin"===e.ctor&&(e=_elm_lang$core$Set$toList(e),n=_elm_lang$core$Set$toList(n)),"::"===e.ctor){for(var i=e,s=n;"::"===i.ctor&&"::"===s.ctor;){if(!t(i._0,s._0,r+1,o))return!1;i=i._1,s=s._1}return i.ctor===s.ctor}if("_Array"===e.ctor){var c=f.toJSArray(e),l=f.toJSArray(n);if(c.length!==l.length)return!1;for(var d=0;d<c.length;d++)if(!t(c[d],l[d],r+1,o))return!1;return!0}if(!t(e.ctor,n.ctor,r+1,o))return!1;for(var a in e)if(!t(e[a],n[a],r+1,o))return!1;return!0}function r(e,n){if("object"!=typeof e)return e===n?g:e<n?v:w;if(e instanceof String){var t=e.valueOf(),o=n.valueOf();return t===o?g:t<o?v:w}if("::"===e.ctor||"[]"===e.ctor){for(;"::"===e.ctor&&"::"===n.ctor;){var a=r(e._0,n._0);if(a!==g)return a;e=e._1,n=n._1}return e.ctor===n.ctor?g:"[]"===e.ctor?v:w}if("_Tuple"===e.ctor.slice(0,6)){var a,i=e.ctor.slice(6)-0,s="cannot compare tuples with more than 6 elements.";if(0===i)return g;if(i>=1){if(a=r(e._0,n._0),a!==g)return a;if(i>=2){if(a=r(e._1,n._1),a!==g)return a;if(i>=3){if(a=r(e._2,n._2),a!==g)return a;if(i>=4){if(a=r(e._3,n._3),a!==g)return a;if(i>=5){if(a=r(e._4,n._4),a!==g)return a;if(i>=6){if(a=r(e._5,n._5),a!==g)return a;if(i>=7)throw new Error("Comparison error: "+s)}}}}}}return g}throw new Error("Comparison error: comparison is only defined on ints, floats, times, chars, strings, lists of comparable values, and tuples of comparable values.")}function o(e,n){return{ctor:"_Tuple2",_0:e,_1:n}}function a(e){return new String(e)}function i(e){return b++}function s(e,n){var t={};for(var r in e)t[r]=e[r];for(var r in n)t[r]=n[r];return t}function c(e,n){return{ctor:"::",_0:e,_1:n}}function l(e,n){if("string"==typeof e)return e+n;if("[]"===e.ctor)return n;var t=c(e._0,T),r=t;for(e=e._1;"[]"!==e.ctor;)r._1=c(e._0,T),e=e._1,r=r._1;return r._1=n,t}function d(e,n){return function(t){throw new Error("Ran into a `Debug.crash` in module `"+e+"` "+p(n)+"\nThe message provided by the code author is:\n\n    "+t)}}function u(e,n,t){return function(r){throw new Error("Ran into a `Debug.crash` in module `"+e+"`\n\nThis was caused by the `case` expression "+p(n)+".\nOne of the branches ended with a crash and the following value got through:\n\n    "+h(t)+"\n\nThe message provided by the code author is:\n\n    "+r)}}function p(e){return e.start.line==e.end.line?"on line "+e.start.line:"between lines "+e.start.line+" and "+e.end.line}function h(e){var n=typeof e;if("function"===n){var t=e.func?e.func.name:e.name;return"<function"+(""===t?"":":")+t+">"}if("boolean"===n)return e?"True":"False";if("number"===n)return e+"";if(e instanceof String)return"'"+m(e,!0)+"'";if("string"===n)return'"'+m(e,!1)+'"';if(null===e)return"null";if("object"===n&&"ctor"in e){var r=e.ctor.substring(0,5);if("_Tupl"===r){var o=[];for(var a in e)"ctor"!==a&&o.push(h(e[a]));return"("+o.join(",")+")"}if("_Task"===r)return"<task>";if("_Array"===e.ctor){var i=j(e);return"Array.fromList "+h(i)}if("<decoder>"===e.ctor)return"<decoder>";if("_Process"===e.ctor)return"<process:"+e.id+">";if("::"===e.ctor){var o="["+h(e._0);for(e=e._1;"::"===e.ctor;)o+=","+h(e._0),e=e._1;return o+"]"}if("[]"===e.ctor)return"[]";if("Set_elm_builtin"===e.ctor)return"Set.fromList "+h(_elm_lang$core$Set$toList(e));if("RBNode_elm_builtin"===e.ctor||"RBEmpty_elm_builtin"===e.ctor)return"Dict.fromList "+h(Q(e));var o="";for(var s in e)if("ctor"!==s){var c=h(e[s]),l=c[0],d="{"===l||"("===l||"<"===l||'"'===l||c.indexOf(" ")<0;o+=" "+(d?c:"("+c+")")}return e.ctor+o}if("object"===n){if(e instanceof Date)return"<"+e.toString()+">";if(e.elm_web_socket)return"<websocket>";var o=[];for(var a in e)o.push(a+" = "+h(e[a]));return 0===o.length?"{}":"{ "+o.join(", ")+" }"}return"<internal structure>"}function m(e,n){var t=e.replace(/\\/g,"\\\\").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r").replace(/\v/g,"\\v").replace(/\0/g,"\\0");return n?t.replace(/\'/g,"\\'"):t.replace(/\"/g,'\\"')}var v=-1,g=0,w=1,_={ctor:"_Tuple0"},b=0,T={ctor:"[]"};return{eq:e,cmp:r,Tuple0:_,Tuple2:o,chr:a,update:s,guid:i,append:n(l),crash:d,crashCase:u,toString:h}}(),v=(n(function(e,n){var t=n;return l(e,t._0,t._1)}),t(function(e,n,t){return e({ctor:"_Tuple2",_0:n,_1:t})}),t(function(e,n,t){return l(e,t,n)}),n(function(e,n){return e})),g=g||{};g["<|"]=n(function(e,n){return e(n)});var g=g||{};g["|>"]=n(function(e,n){return n(e)});var g=g||{};g[">>"]=t(function(e,n,t){return n(e(t))});var g=g||{};g["<<"]=t(function(e,n,t){return e(n(t))});var g=g||{};g["++"]=m.append;var w=m.toString,g=(h.isInfinite,h.isNaN,h.toFloat,h.ceiling,h.floor,h.truncate,h.round,h.not,h.xor,g||{});g["||"]=h.or;var g=g||{};g["&&"]=h.and;var _=(h.max,h.min,h.compare),g=g||{};g[">="]=h.ge;var g=g||{};g["<="]=h.le;var g=g||{};g[">"]=h.gt;var g=g||{};g["<"]=h.lt;var g=g||{};g["/="]=h.neq;var g=g||{};g["=="]=h.eq;var g=(h.e,h.pi,h.clamp,h.logBase,h.abs,h.negate,h.sqrt,h.atan2,h.atan,h.asin,h.acos,h.tan,h.sin,h.cos,g||{});g["^"]=h.exp;var g=g||{};g["%"]=h.mod;var g=(h.rem,g||{});g["//"]=h.div;var g=g||{};g["/"]=h.floatDiv;var g=g||{};g["*"]=h.mul;var g=g||{};g["-"]=h.sub;var g=g||{};g["+"]=h.add;var b=(h.toPolar,h.fromPolar,h.turns,h.degrees,n(function(e,n){var t=n;return"Just"===t.ctor?t._0:e}),{ctor:"Nothing"}),T=(n(function(e,n){var t=n;return"Just"===t.ctor?e(t._0):b}),function(e){return{ctor:"Just",_0:e}}),y=(n(function(e,n){var t=n;return"Just"===t.ctor?T(e(t._0)):b}),t(function(e,n,t){var r={ctor:"_Tuple2",_0:n,_1:t};return"_Tuple2"===r.ctor&&"Just"===r._0.ctor&&"Just"===r._1.ctor?T(l(e,r._0._0,r._1._0)):b}),r(function(e,n,t,r){var o={ctor:"_Tuple3",_0:n,_1:t,_2:r};return"_Tuple3"===o.ctor&&"Just"===o._0.ctor&&"Just"===o._1.ctor&&"Just"===o._2.ctor?T(d(e,o._0._0,o._1._0,o._2._0)):b}),o(function(e,n,t,r,o){var a={ctor:"_Tuple4",_0:n,_1:t,_2:r,_3:o};return"_Tuple4"===a.ctor&&"Just"===a._0.ctor&&"Just"===a._1.ctor&&"Just"===a._2.ctor&&"Just"===a._3.ctor?T(u(e,a._0._0,a._1._0,a._2._0,a._3._0)):b}),a(function(e,n,t,r,o,a){var i={ctor:"_Tuple5",_0:n,_1:t,_2:r,_3:o,_4:a};return"_Tuple5"===i.ctor&&"Just"===i._0.ctor&&"Just"===i._1.ctor&&"Just"===i._2.ctor&&"Just"===i._3.ctor&&"Just"===i._4.ctor?T(p(e,i._0._0,i._1._0,i._2._0,i._3._0,i._4._0)):b}),function(){function e(e,n){return{ctor:"::",_0:e,_1:n}}function i(n){for(var t=b,r=n.length;r--;)t=e(n[r],t);return t}function s(e){for(var n=[];"[]"!==e.ctor;)n.push(e._0),e=e._1;return n}function c(e,n,t){for(var r=s(t),o=n,a=r.length;a--;)o=l(e,r[a],o);return o}function f(e,n,t){for(var r=[];"[]"!==n.ctor&&"[]"!==t.ctor;)r.push(l(e,n._0,t._0)),n=n._1,t=t._1;return i(r)}function h(e,n,t,r){for(var o=[];"[]"!==n.ctor&&"[]"!==t.ctor&&"[]"!==r.ctor;)o.push(d(e,n._0,t._0,r._0)),n=n._1,t=t._1,r=r._1;return i(o)}function v(e,n,t,r,o){for(var a=[];"[]"!==n.ctor&&"[]"!==t.ctor&&"[]"!==r.ctor&&"[]"!==o.ctor;)a.push(u(e,n._0,t._0,r._0,o._0)),n=n._1,t=t._1,r=r._1,o=o._1;return i(a)}function g(e,n,t,r,o,a){for(var s=[];"[]"!==n.ctor&&"[]"!==t.ctor&&"[]"!==r.ctor&&"[]"!==o.ctor&&"[]"!==a.ctor;)s.push(p(e,n._0,t._0,r._0,o._0,a._0)),n=n._1,t=t._1,r=r._1,o=o._1,a=a._1;return i(s)}function w(e,n){return i(s(n).sort(function(n,t){return m.cmp(e(n),e(t))}))}function _(e,n){return i(s(n).sort(function(n,t){var r=e(n)(t).ctor;return"EQ"===r?0:"LT"===r?-1:1}))}var b={ctor:"[]"};return{Nil:b,Cons:e,cons:n(e),toArray:s,fromArray:i,foldr:t(c),map2:t(f),map3:r(h),map4:o(v),map5:a(g),sortBy:n(w),sortWith:n(_)}}()),E=(y.sortWith,y.sortBy,n(function(e,n){for(;;){if(m.cmp(e,0)<1)return n;var t=n;if("[]"===t.ctor)return n;var r=e-1,o=t._1;e=r,n=o}}),y.map5,y.map4,y.map3,y.map2),N=n(function(e,n){for(;;){var t=n;if("[]"===t.ctor)return!1;if(e(t._0))return!0;var r=e,o=t._1;e=r,n=o}}),S=(n(function(e,n){return!l(N,function(n){return!e(n)},n)}),y.foldr),M=t(function(e,n,t){for(;;){var r=t;if("[]"===r.ctor)return n;var o=e,a=l(e,r._0,n),i=r._1;e=o,n=a,t=i}}),C=function(e){return d(M,n(function(e,n){return n+1}),0,e)},L=(n(function(e,n){return l(N,function(n){return m.eq(n,e)},n)}),L||{});L["::"]=y.cons;var x,R=n(function(e,t){return d(S,n(function(n,t){return{ctor:"::",_0:e(n),_1:t}}),{ctor:"[]"},t)}),O=(n(function(e,t){var r=n(function(n,t){return e(n)?{ctor:"::",_0:n,_1:t}:t});return d(S,r,{ctor:"[]"},t)}),t(function(e,n,t){var r=e(n);return"Just"===r.ctor?{ctor:"::",_0:r._0,_1:t}:t})),I=(n(function(e,n){return d(S,O(e),{ctor:"[]"},n)}),function(e){return d(M,n(function(e,n){return{ctor:"::",_0:e,_1:n}}),{ctor:"[]"},e)}),k=(t(function(e,t,r){var o=n(function(n,t){var r=t;return"::"===r.ctor?{ctor:"::",_0:l(e,n,r._0),_1:t}:{ctor:"[]"}});return I(d(M,o,{ctor:"::",_0:t,_1:{ctor:"[]"}},r))}),n(function(e,t){var r=t;return"[]"===r.ctor?e:d(S,n(function(e,n){return{ctor:"::",_0:e,_1:n}}),t,e)})),D=function(e){return d(S,k,{ctor:"[]"},e)},H=(n(function(e,n){return D(l(R,e,n))}),n(function(e,t){var r=n(function(n,t){var r=t,o=r._0,a=r._1;return e(n)?{ctor:"_Tuple2",_0:{ctor:"::",_0:n,_1:o},_1:a}:{ctor:"_Tuple2",_0:o,_1:{ctor:"::",_0:n,_1:a}}});return d(S,r,{ctor:"_Tuple2",_0:{ctor:"[]"},_1:{ctor:"[]"}},t)}),n(function(e,t){var r=t;if("[]"===r.ctor)return{ctor:"[]"};var o=n(function(n,t){return{ctor:"::",_0:e,_1:{ctor:"::",_0:n,_1:t}}}),a=d(S,o,{ctor:"[]"},r._1);return{ctor:"::",_0:r._0,_1:a}}),t(function(e,n,t){for(;;){if(m.cmp(e,0)<1)return t;var r=n;if("[]"===r.ctor)return t;var o=e-1,a=r._1,i={ctor:"::",_0:r._0,_1:t};e=o,n=a,t=i}})),P=n(function(e,n){return I(d(H,e,n,{ctor:"[]"}))}),W=t(function(e,n,t){if(m.cmp(n,0)<1)return{ctor:"[]"};var r={ctor:"_Tuple2",_0:n,_1:t};e:do{n:do{if("_Tuple2"!==r.ctor)break e;if("[]"===r._1.ctor)return t;if("::"!==r._1._1.ctor){if(1===r._0)break n;break e}switch(r._0){case 1:break n;case 2:return{ctor:"::",_0:r._1._0,_1:{ctor:"::",_0:r._1._1._0,_1:{ctor:"[]"}}};case 3:if("::"===r._1._1._1.ctor)return{ctor:"::",_0:r._1._0,_1:{ctor:"::",_0:r._1._1._0,_1:{ctor:"::",_0:r._1._1._1._0,_1:{ctor:"[]"}}}};break e;default:if("::"===r._1._1._1.ctor&&"::"===r._1._1._1._1.ctor){var o=r._1._1._1._0,a=r._1._1._0,i=r._1._0,s=r._1._1._1._1._0,c=r._1._1._1._1._1;return m.cmp(e,1e3)>0?{ctor:"::",_0:i,_1:{ctor:"::",_0:a,_1:{ctor:"::",_0:o,_1:{ctor:"::",_0:s,_1:l(P,n-4,c)}}}}:{ctor:"::",_0:i,_1:{ctor:"::",_0:a,_1:{ctor:"::",_0:o,_1:{ctor:"::",_0:s,_1:d(W,e+1,n-4,c)}}}}}break e}}while(!1);return{ctor:"::",_0:r._1._0,_1:{ctor:"[]"}}}while(!1);return t}),A=(n(function(e,n){return d(W,0,e,n)}),t(function(e,n,t){for(;;){if(m.cmp(n,0)<1)return e;var r={ctor:"::",_0:t,_1:e},o=n-1,a=t;e=r,n=o,t=a}})),U=(n(function(e,n){return d(A,{ctor:"[]"},e,n)}),t(function(e,n,t){for(;;){if(!(m.cmp(e,n)<1))return t;var r=e,o=n-1,a={ctor:"::",_0:n,_1:t};e=r,n=o,t=a}})),B=n(function(e,n){return d(U,e,n,{ctor:"[]"})}),j=(n(function(e,n){return d(E,e,l(B,0,C(n)-1),n)}),f.append,f.length,f.slice,f.set,n(function(e,n){return m.cmp(0,e)<1&&m.cmp(e,f.length(n))<0?T(l(f.get,e,n)):b}),f.push,f.empty,n(function(e,t){var r=n(function(n,t){return e(n)?l(f.push,n,t):t});return d(f.foldl,r,f.empty,t)}),f.foldr,f.foldl,f.indexedMap,f.map,f.toList),F=(f.fromList,f.initialize),q=(n(function(e,n){return l(F,e,v(n))}),function(){function e(e,n){var t=e+": "+m.toString(n),r=r||{};return r.stdout?r.stdout.write(t):console.log(t),n}function t(e){throw new Error(e)}return{crash:t,log:n(e)}}()),G=function(){function e(e){return 0===e.length}function r(e,n){return e+n}function o(e){var n=e[0];return n?T(m.Tuple2(m.chr(n),e.slice(1))):b}function a(e,n){return e+n}function i(e){return y.toArray(e).join("")}function s(e){return e.length}function c(e,n){for(var t=n.split(""),r=t.length;r--;)t[r]=e(m.chr(t[r]));return t.join("")}function d(e,n){return n.split("").map(m.chr).filter(e).join("")}function u(e){return e.split("").reverse().join("")}function p(e,n,t){for(var r=t.length,o=0;o<r;++o)n=l(e,m.chr(t[o]),n);return n}function f(e,n,t){for(var r=t.length;r--;)n=l(e,m.chr(t[r]),n);return n}function h(e,n){return y.fromArray(n.split(e))}function v(e,n){return y.toArray(n).join(e)}function g(e,n){for(var t="";e>0;)1&e&&(t+=n),e>>=1,n+=n;return t}function w(e,n,t){return t.slice(e,n)}function _(e,n){return e<1?"":n.slice(0,e)}function E(e,n){return e<1?"":n.slice(-e)}function N(e,n){return e<1?n:n.slice(e)}function S(e,n){return e<1?n:n.slice(0,-e)}function M(e,n,t){var r=(e-t.length)/2;return g(Math.ceil(r),n)+t+g(0|r,n)}function C(e,n,t){return t+g(e-t.length,n)}function L(e,n,t){return g(e-t.length,n)+t}function x(e){return e.trim()}function R(e){return e.replace(/^\s+/,"")}function O(e){return e.replace(/\s+$/,"")}function I(e){return y.fromArray(e.trim().split(/\s+/g))}function k(e){return y.fromArray(e.split(/\r\n|\r|\n/g))}function D(e){return e.toUpperCase()}function H(e){return e.toLowerCase()}function P(e,n){for(var t=n.length;t--;)if(e(m.chr(n[t])))return!0;return!1}function W(e,n){for(var t=n.length;t--;)if(!e(m.chr(n[t])))return!1;return!0}function A(e,n){return n.indexOf(e)>-1}function U(e,n){return 0===n.indexOf(e)}function B(e,n){return n.length>=e.length&&n.lastIndexOf(e)===n.length-e.length}function j(e,n){var t=e.length;if(t<1)return y.Nil;for(var r=0,o=[];(r=n.indexOf(e,r))>-1;)o.push(r),r+=t;return y.fromArray(o)}function F(e){var n=e.length;if(0===n)return K("could not convert string '"+e+"' to an Int");var t=0;if("-"===e[0]){if(1===n)return K("could not convert string '"+e+"' to an Int");t=1}for(var r=t;r<n;++r){var o=e[r];if(o<"0"||"9"<o)return K("could not convert string '"+e+"' to an Int")}return Y(parseInt(e,10))}function q(e){var n=e.length;if(0===n)return K("could not convert string '"+e+"' to a Float");var t=0;if("-"===e[0]){if(1===n)return K("could not convert string '"+e+"' to a Float");t=1}for(var r=0,o=t;o<n;++o){var a=e[o];if(!("0"<=a&&a<="9"||"."===a&&(r+=1,r<=1)))return K("could not convert string '"+e+"' to a Float")}return Y(parseFloat(e))}function G(e){return y.fromArray(e.split("").map(m.chr))}function V(e){return y.toArray(e).join("")}return{isEmpty:e,cons:n(r),uncons:o,append:n(a),concat:i,length:s,map:n(c),filter:n(d),reverse:u,foldl:t(p),foldr:t(f),split:n(h),join:n(v),repeat:n(g),slice:t(w),left:n(_),right:n(E),dropLeft:n(N),dropRight:n(S),pad:t(M),padLeft:t(L),padRight:t(C),trim:x,trimLeft:R,trimRight:O,words:I,lines:k,toUpper:D,toLower:H,any:n(P),all:n(W),contains:n(A),startsWith:n(U),endsWith:n(B),indexes:n(j),toInt:F,toFloat:q,toList:G,fromList:V}}(),V=function(){return{fromCode:function(e){return m.chr(String.fromCharCode(e))},toCode:function(e){return e.charCodeAt(0)},toUpper:function(e){return m.chr(e.toUpperCase())},toLower:function(e){return m.chr(e.toLowerCase())},toLocaleUpper:function(e){return m.chr(e.toLocaleUpperCase())},toLocaleLower:function(e){return m.chr(e.toLocaleLowerCase())}}}(),z=(V.fromCode,V.toCode),J=(V.toLocaleLower,V.toLocaleUpper,V.toLower,V.toUpper,t(function(e,n,t){var r=z(t);return m.cmp(r,z(e))>-1&&m.cmp(r,z(n))<1})),K=(l(J,m.chr("A"),m.chr("Z")),l(J,m.chr("a"),m.chr("z")),l(J,m.chr("0"),m.chr("9")),l(J,m.chr("0"),m.chr("7")),n(function(e,n){var t=n;return"Ok"===t.ctor?t._0:e}),function(e){return{ctor:"Err",_0:e}}),Y=(n(function(e,n){var t=n;return"Ok"===t.ctor?e(t._0):K(t._0)}),function(e){return{ctor:"Ok",_0:e}}),X=(n(function(e,n){var t=n;return"Ok"===t.ctor?Y(e(t._0)):K(t._0)}),t(function(e,n,t){var r={ctor:"_Tuple2",_0:n,_1:t};return"Ok"===r._0.ctor?"Ok"===r._1.ctor?Y(l(e,r._0._0,r._1._0)):K(r._1._0):K(r._0._0)}),r(function(e,n,t,r){var o={ctor:"_Tuple3",_0:n,_1:t,_2:r};return"Ok"===o._0.ctor?"Ok"===o._1.ctor?"Ok"===o._2.ctor?Y(d(e,o._0._0,o._1._0,o._2._0)):K(o._2._0):K(o._1._0):K(o._0._0)}),o(function(e,n,t,r,o){var a={ctor:"_Tuple4",_0:n,_1:t,_2:r,_3:o};return"Ok"===a._0.ctor?"Ok"===a._1.ctor?"Ok"===a._2.ctor?"Ok"===a._3.ctor?Y(u(e,a._0._0,a._1._0,a._2._0,a._3._0)):K(a._3._0):K(a._2._0):K(a._1._0):K(a._0._0)}),a(function(e,n,t,r,o,a){var i={ctor:"_Tuple5",_0:n,_1:t,_2:r,_3:o,_4:a};return"Ok"===i._0.ctor?"Ok"===i._1.ctor?"Ok"===i._2.ctor?"Ok"===i._3.ctor?"Ok"===i._4.ctor?Y(p(e,i._0._0,i._1._0,i._2._0,i._3._0,i._4._0)):K(i._4._0):K(i._3._0):K(i._2._0):K(i._1._0):K(i._0._0)}),n(function(e,n){var t=n;return"Ok"===t.ctor?Y(t._0):K(e(t._0))}),n(function(e,n){var t=n;return"Just"===t.ctor?Y(t._0):K(e)}),G.fromList,G.toList,G.toFloat,G.toInt,G.indexes,G.indexes,G.endsWith,G.startsWith,G.contains,G.all,G.any,G.toLower,G.toUpper,G.lines,G.words,G.trimRight,G.trimLeft,G.trim,G.padRight,G.padLeft,G.pad,G.dropRight,G.dropLeft,G.right,G.left,G.slice,G.repeat,G.join,G.split,G.foldr,G.foldl,G.reverse,G.filter,G.map,G.length,G.concat),$=(G.append,G.uncons,G.cons,G.isEmpty,t(function(e,n,t){for(;;){var r=t;if("RBEmpty_elm_builtin"===r.ctor)return n;var o=e,a=d(e,r._1,r._2,d($,e,n,r._4)),i=r._3;e=o,n=a,t=i}})),Q=function(e){return d($,t(function(e,n,t){return{ctor:"::",_0:{ctor:"_Tuple2",_0:e,_1:n},_1:t}}),{ctor:"[]"},e)},Z=t(function(e,n,t){for(;;){var r=t;if("RBEmpty_elm_builtin"===r.ctor)return n;var o=e,a=d(e,r._1,r._2,d(Z,e,n,r._3)),i=r._4;e=o,n=a,t=i}}),ee=(a(function(e,r,o,a,i,s){var c=t(function(n,t,a){for(;;){var i=a,s=i._1,c=i._0,l=c;if("[]"===l.ctor)return{ctor:"_Tuple2",_0:c,_1:d(o,n,t,s)};var p=l._1,f=l._0._1,h=l._0._0;if(!(m.cmp(h,n)<0))return m.cmp(h,n)>0?{ctor:"_Tuple2",_0:c,_1:d(o,n,t,s)}:{ctor:"_Tuple2",_0:p,_1:u(r,h,f,t,s)};var v=n,g=t,w={ctor:"_Tuple2",_0:p,_1:d(e,h,f,s)};n=v,t=g,a=w}}),l=d(Z,c,{ctor:"_Tuple2",_0:Q(a),_1:s},i),p=l._0,f=l._1;return d(M,n(function(n,t){var r=n;return d(e,r._0,r._1,t)}),f,p)}),r(function(e,n,t,r){return q.crash(X({ctor:"::",_0:"Internal red-black tree invariant violated, expected ",_1:{ctor:"::",_0:e,_1:{ctor:"::",_0:" and got ",_1:{ctor:"::",_0:w(n),_1:{ctor:"::",_0:"/",_1:{ctor:"::",_0:t,_1:{ctor:"::",_0:"/",_1:{ctor:"::",_0:r,_1:{ctor:"::",_0:"\nPlease report this bug to <https://github.com/elm-lang/core/issues>",_1:{ctor:"[]"}}}}}}}}}}))})),ne=function(e){var n=e;e:do{if("RBNode_elm_builtin"===n.ctor){if("BBlack"===n._0.ctor)return!0;break e}if("LBBlack"===n._0.ctor)return!0;break e}while(!1);return!1},te=n(function(e,n){for(;;){var t=n;if("RBEmpty_elm_builtin"===t.ctor)return e;var r=l(te,e+1,t._4),o=t._3;e=r,n=o}}),re=n(function(e,n){e:for(;;){var t=n;if("RBEmpty_elm_builtin"===t.ctor)return b;var r=l(_,e,t._1);switch(r.ctor){case"LT":var o=e,a=t._3;e=o,n=a;continue e;case"EQ":return T(t._2);default:var i=e,s=t._4;e=i,n=s;continue e}}}),oe=n(function(e,n){var t=l(re,e,n);return"Just"===t.ctor}),ae=t(function(e,n,t){for(;;){var r=t;if("RBEmpty_elm_builtin"===r.ctor)return{ctor:"_Tuple2",_0:e,_1:n};var o=r._1,a=r._2,i=r._4;e=o,n=a,t=i}}),ie={ctor:"NBlack"},se={ctor:"BBlack"},ce={ctor:"Black"},le=function(e){var n=e;if("RBNode_elm_builtin"===n.ctor){var t=n._0;return m.eq(t,ce)||m.eq(t,se)}return!0},de={ctor:"Red"},ue=function(e){var n=e;switch(n.ctor){case"Black":return se;case"Red":return ce;case"NBlack":return de;default:return q.crash("Can't make a double black node more black!")}},pe=function(e){var n=e;switch(n.ctor){case"BBlack":return ce;case"Black":return de;case"Red":return ie;default:return q.crash("Can't make a negative black node less black!")}},fe={ctor:"LBBlack"},he={ctor:"LBlack"},me=function(e){return{ctor:"RBEmpty_elm_builtin",_0:e}},ve=me(he),ge=o(function(e,n,t,r,o){return{ctor:"RBNode_elm_builtin",_0:e,_1:n,_2:t,_3:r,_4:o}}),we=function(e){var n=e;return"RBNode_elm_builtin"===n.ctor&&"Red"===n._0.ctor?p(ge,ce,n._1,n._2,n._3,n._4):e},_e=function(e){var n=e;return"RBNode_elm_builtin"===n.ctor?p(ge,pe(n._0),n._1,n._2,n._3,n._4):me(he)},be=function(e){return function(n){return function(t){return function(r){return function(o){return function(a){return function(i){return function(s){return function(c){return function(l){return function(d){return p(ge,pe(e),r,o,p(ge,ce,n,t,s,c),p(ge,ce,a,i,l,d))}}}}}}}}}}},Te=function(e){var n=e;return"RBEmpty_elm_builtin"===n.ctor?me(he):p(ge,ce,n._1,n._2,n._3,n._4)},ye=function(e){var n=e;return"RBEmpty_elm_builtin"===n.ctor?q.crash("can't make a Leaf red"):p(ge,de,n._1,n._2,n._3,n._4)},Ee=function(e){var n=e;e:do{n:do{t:do{r:do{o:do{a:do{i:do{if("RBNode_elm_builtin"!==n.ctor)break e;if("RBNode_elm_builtin"===n._3.ctor)if("RBNode_elm_builtin"===n._4.ctor)switch(n._3._0.ctor){case"Red":switch(n._4._0.ctor){case"Red":if("RBNode_elm_builtin"===n._3._3.ctor&&"Red"===n._3._3._0.ctor)break i;
if("RBNode_elm_builtin"===n._3._4.ctor&&"Red"===n._3._4._0.ctor)break a;if("RBNode_elm_builtin"===n._4._3.ctor&&"Red"===n._4._3._0.ctor)break o;if("RBNode_elm_builtin"===n._4._4.ctor&&"Red"===n._4._4._0.ctor)break r;break e;case"NBlack":if("RBNode_elm_builtin"===n._3._3.ctor&&"Red"===n._3._3._0.ctor)break i;if("RBNode_elm_builtin"===n._3._4.ctor&&"Red"===n._3._4._0.ctor)break a;if("BBlack"===n._0.ctor&&"RBNode_elm_builtin"===n._4._3.ctor&&"Black"===n._4._3._0.ctor&&"RBNode_elm_builtin"===n._4._4.ctor&&"Black"===n._4._4._0.ctor)break t;break e;default:if("RBNode_elm_builtin"===n._3._3.ctor&&"Red"===n._3._3._0.ctor)break i;if("RBNode_elm_builtin"===n._3._4.ctor&&"Red"===n._3._4._0.ctor)break a;break e}case"NBlack":switch(n._4._0.ctor){case"Red":if("RBNode_elm_builtin"===n._4._3.ctor&&"Red"===n._4._3._0.ctor)break o;if("RBNode_elm_builtin"===n._4._4.ctor&&"Red"===n._4._4._0.ctor)break r;if("BBlack"===n._0.ctor&&"RBNode_elm_builtin"===n._3._3.ctor&&"Black"===n._3._3._0.ctor&&"RBNode_elm_builtin"===n._3._4.ctor&&"Black"===n._3._4._0.ctor)break n;break e;case"NBlack":if("BBlack"===n._0.ctor){if("RBNode_elm_builtin"===n._4._3.ctor&&"Black"===n._4._3._0.ctor&&"RBNode_elm_builtin"===n._4._4.ctor&&"Black"===n._4._4._0.ctor)break t;if("RBNode_elm_builtin"===n._3._3.ctor&&"Black"===n._3._3._0.ctor&&"RBNode_elm_builtin"===n._3._4.ctor&&"Black"===n._3._4._0.ctor)break n;break e}break e;default:if("BBlack"===n._0.ctor&&"RBNode_elm_builtin"===n._3._3.ctor&&"Black"===n._3._3._0.ctor&&"RBNode_elm_builtin"===n._3._4.ctor&&"Black"===n._3._4._0.ctor)break n;break e}default:switch(n._4._0.ctor){case"Red":if("RBNode_elm_builtin"===n._4._3.ctor&&"Red"===n._4._3._0.ctor)break o;if("RBNode_elm_builtin"===n._4._4.ctor&&"Red"===n._4._4._0.ctor)break r;break e;case"NBlack":if("BBlack"===n._0.ctor&&"RBNode_elm_builtin"===n._4._3.ctor&&"Black"===n._4._3._0.ctor&&"RBNode_elm_builtin"===n._4._4.ctor&&"Black"===n._4._4._0.ctor)break t;break e;default:break e}}else switch(n._3._0.ctor){case"Red":if("RBNode_elm_builtin"===n._3._3.ctor&&"Red"===n._3._3._0.ctor)break i;if("RBNode_elm_builtin"===n._3._4.ctor&&"Red"===n._3._4._0.ctor)break a;break e;case"NBlack":if("BBlack"===n._0.ctor&&"RBNode_elm_builtin"===n._3._3.ctor&&"Black"===n._3._3._0.ctor&&"RBNode_elm_builtin"===n._3._4.ctor&&"Black"===n._3._4._0.ctor)break n;break e;default:break e}else{if("RBNode_elm_builtin"!==n._4.ctor)break e;switch(n._4._0.ctor){case"Red":if("RBNode_elm_builtin"===n._4._3.ctor&&"Red"===n._4._3._0.ctor)break o;if("RBNode_elm_builtin"===n._4._4.ctor&&"Red"===n._4._4._0.ctor)break r;break e;case"NBlack":if("BBlack"===n._0.ctor&&"RBNode_elm_builtin"===n._4._3.ctor&&"Black"===n._4._3._0.ctor&&"RBNode_elm_builtin"===n._4._4.ctor&&"Black"===n._4._4._0.ctor)break t;break e;default:break e}}}while(!1);return be(n._0)(n._3._3._1)(n._3._3._2)(n._3._1)(n._3._2)(n._1)(n._2)(n._3._3._3)(n._3._3._4)(n._3._4)(n._4)}while(!1);return be(n._0)(n._3._1)(n._3._2)(n._3._4._1)(n._3._4._2)(n._1)(n._2)(n._3._3)(n._3._4._3)(n._3._4._4)(n._4)}while(!1);return be(n._0)(n._1)(n._2)(n._4._3._1)(n._4._3._2)(n._4._1)(n._4._2)(n._3)(n._4._3._3)(n._4._3._4)(n._4._4)}while(!1);return be(n._0)(n._1)(n._2)(n._4._1)(n._4._2)(n._4._4._1)(n._4._4._2)(n._3)(n._4._3)(n._4._4._3)(n._4._4._4)}while(!1);return p(ge,ce,n._4._3._1,n._4._3._2,p(ge,ce,n._1,n._2,n._3,n._4._3._3),p(Ne,ce,n._4._1,n._4._2,n._4._3._4,ye(n._4._4)))}while(!1);return p(ge,ce,n._3._4._1,n._3._4._2,p(Ne,ce,n._3._1,n._3._2,ye(n._3._3),n._3._4._3),p(ge,ce,n._1,n._2,n._3._4._4,n._4))}while(!1);return e},Ne=o(function(e,n,t,r,o){var a=p(ge,e,n,t,r,o);return le(a)?Ee(a):a}),Se=o(function(e,n,t,r,o){return ne(r)||ne(o)?p(Ne,ue(e),n,t,_e(r),_e(o)):p(ge,e,n,t,r,o)}),Me=o(function(e,n,t,r,o){var a=o;return"RBEmpty_elm_builtin"===a.ctor?d(Ce,e,r,o):p(Se,e,n,t,r,p(Me,a._0,a._1,a._2,a._3,a._4))}),Ce=t(function(e,n,t){var r={ctor:"_Tuple2",_0:n,_1:t};if("RBEmpty_elm_builtin"!==r._0.ctor){if("RBEmpty_elm_builtin"===r._1.ctor){var o=r._1._0,a=r._0._0,i={ctor:"_Tuple3",_0:e,_1:a,_2:o};return"_Tuple3"===i.ctor&&"Black"===i._0.ctor&&"Red"===i._1.ctor&&"LBlack"===i._2.ctor?p(ge,ce,r._0._1,r._0._2,r._0._3,r._0._4):u(ee,"Black/Red/LBlack",e,w(a),w(o))}var s=r._0._2,c=r._0._4,l=r._0._1,f=p(Me,r._0._0,l,s,r._0._3,c),h=d(ae,l,s,c),m=h._0,v=h._1;return p(Se,e,m,v,f,t)}if("RBEmpty_elm_builtin"!==r._1.ctor){var g=r._1._0,_=r._0._0,b={ctor:"_Tuple3",_0:e,_1:_,_2:g};return"_Tuple3"===b.ctor&&"Black"===b._0.ctor&&"LBlack"===b._1.ctor&&"Red"===b._2.ctor?p(ge,ce,r._1._1,r._1._2,r._1._3,r._1._4):u(ee,"Black/LBlack/Red",e,w(_),w(g))}var T=e;switch(T.ctor){case"Red":return me(he);case"Black":return me(fe);default:return q.crash("cannot have bblack or nblack nodes at this point")}}),Le=n(function(e,n){var t=n;if("RBEmpty_elm_builtin"===t.ctor)return me(he);var r=t._1;return p(ge,t._0,r,l(e,r,t._2),l(Le,e,t._3),l(Le,e,t._4))}),xe={ctor:"Same"},Re={ctor:"Remove"},Oe={ctor:"Insert"},Ie=t(function(e,n,t){var r=function(t){var o=t;if("RBEmpty_elm_builtin"===o.ctor){var a=n(b);return"Nothing"===a.ctor?{ctor:"_Tuple2",_0:xe,_1:ve}:{ctor:"_Tuple2",_0:Oe,_1:p(ge,de,e,a._0,ve,ve)}}var i=o._2,s=o._4,c=o._3,u=o._1,f=o._0,h=l(_,e,u);switch(h.ctor){case"EQ":var m=n(T(i));return"Nothing"===m.ctor?{ctor:"_Tuple2",_0:Re,_1:d(Ce,f,c,s)}:{ctor:"_Tuple2",_0:xe,_1:p(ge,f,u,m._0,c,s)};case"LT":var v=r(c),g=v._0,w=v._1,y=g;switch(y.ctor){case"Same":return{ctor:"_Tuple2",_0:xe,_1:p(ge,f,u,i,w,s)};case"Insert":return{ctor:"_Tuple2",_0:Oe,_1:p(Ne,f,u,i,w,s)};default:return{ctor:"_Tuple2",_0:Re,_1:p(Se,f,u,i,w,s)}}default:var E=r(s),g=E._0,N=E._1,S=g;switch(S.ctor){case"Same":return{ctor:"_Tuple2",_0:xe,_1:p(ge,f,u,i,c,N)};case"Insert":return{ctor:"_Tuple2",_0:Oe,_1:p(Ne,f,u,i,c,N)};default:return{ctor:"_Tuple2",_0:Re,_1:p(Se,f,u,i,c,N)}}}},o=r(t),a=o._0,i=o._1,s=a;switch(s.ctor){case"Same":return i;case"Insert":return we(i);default:return Te(i)}}),ke=t(function(e,n,t){return d(Ie,e,v(T(n)),t)}),De=(n(function(e,n){return d(ke,e,n,ve)}),n(function(e,n){return d(Z,ke,n,e)}),n(function(e,n){var r=t(function(n,t,r){return l(e,n,t)?d(ke,n,t,r):r});return d(Z,r,ve,n)})),He=(n(function(e,t){return l(De,n(function(e,n){return l(oe,e,t)}),e)}),n(function(e,n){var r=t(function(n,t,r){var o=r,a=o._1,i=o._0;return l(e,n,t)?{ctor:"_Tuple2",_0:d(ke,n,t,i),_1:a}:{ctor:"_Tuple2",_0:i,_1:d(ke,n,t,a)}});return d(Z,r,{ctor:"_Tuple2",_0:ve,_1:ve},n)}),n(function(e,n){return d(Ie,e,v(b),n)})),Pe=(n(function(e,n){return d(Z,t(function(e,n,t){return l(He,e,t)}),e,n)}),function(){function e(e){return{ctor:"<decoder>",tag:"succeed",msg:e}}function l(e){return{ctor:"<decoder>",tag:"fail",msg:e}}function d(e){return{ctor:"<decoder>",tag:e}}function u(e,n){return{ctor:"<decoder>",tag:e,decoder:n}}function p(e){return{ctor:"<decoder>",tag:"null",value:e}}function h(e,n){return{ctor:"<decoder>",tag:"field",field:e,decoder:n}}function v(e,n){return{ctor:"<decoder>",tag:"index",index:e,decoder:n}}function g(e){return{ctor:"<decoder>",tag:"key-value",decoder:e}}function w(e,n){return{ctor:"<decoder>",tag:"map-many",func:e,decoders:n}}function _(e,n){return{ctor:"<decoder>",tag:"andThen",decoder:n,callback:e}}function E(e){return{ctor:"<decoder>",tag:"oneOf",decoders:e}}function N(e,n){return w(e,[n])}function S(e,n,t){return w(e,[n,t])}function M(e,n,t,r){return w(e,[n,t,r])}function C(e,n,t,r,o){return w(e,[n,t,r,o])}function L(e,n,t,r,o,a){return w(e,[n,t,r,o,a])}function x(e,n,t,r,o,a,i){return w(e,[n,t,r,o,a,i])}function R(e,n,t,r,o,a,i,s){return w(e,[n,t,r,o,a,i,s])}function O(e,n,t,r,o,a,i,s,c){return w(e,[n,t,r,o,a,i,s,c])}function I(e){return{tag:"ok",value:e}}function k(e,n){return{tag:"primitive",type:e,value:n}}function D(e,n){return{tag:"index",index:e,rest:n}}function H(e,n){return{tag:"field",field:e,rest:n}}function D(e,n){return{tag:"index",index:e,rest:n}}function P(e){return{tag:"oneOf",problems:e}}function W(e){return{tag:"fail",msg:e}}function A(e){for(var n="_";e;)switch(e.tag){case"primitive":return"Expecting "+e.type+("_"===n?"":" at "+n)+" but instead got: "+U(e.value);case"index":n+="["+e.index+"]",e=e.rest;break;case"field":n+="."+e.field,e=e.rest;break;case"index":n+="["+e.index+"]",e=e.rest;break;case"oneOf":for(var t=e.problems,r=0;r<t.length;r++)t[r]=A(t[r]);return"I ran into the following problems"+("_"===n?"":" at "+n)+":\n\n"+t.join("\n");case"fail":return"I ran into a `fail` decoder"+("_"===n?"":" at "+n)+": "+e.msg}}function U(e){return void 0===e?"undefined":JSON.stringify(e)}function B(e,n){var t;try{t=JSON.parse(n)}catch(e){return K("Given an invalid JSON: "+e.message)}return j(e,t)}function j(e,n){var t=F(e,n);return"ok"===t.tag?Y(t.value):K(A(t))}function F(e,n){switch(e.tag){case"bool":return"boolean"==typeof n?I(n):k("a Bool",n);case"int":return"number"!=typeof n?k("an Int",n):-2147483647<n&&n<2147483647&&(0|n)===n?I(n):!isFinite(n)||n%1?k("an Int",n):I(n);case"float":return"number"==typeof n?I(n):k("a Float",n);case"string":return"string"==typeof n?I(n):n instanceof String?I(n+""):k("a String",n);case"null":return null===n?I(e.value):k("null",n);case"value":return I(n);case"list":if(!(n instanceof Array))return k("a List",n);for(var t=y.Nil,r=n.length;r--;){var o=F(e.decoder,n[r]);if("ok"!==o.tag)return D(r,o);t=y.Cons(o.value,t)}return I(t);case"array":if(!(n instanceof Array))return k("an Array",n);for(var a=n.length,i=new Array(a),r=a;r--;){var o=F(e.decoder,n[r]);if("ok"!==o.tag)return D(r,o);i[r]=o.value}return I(f.fromJSArray(i));case"maybe":var o=F(e.decoder,n);return I("ok"===o.tag?T(o.value):b);case"field":var s=e.field;if("object"!=typeof n||null===n||!(s in n))return k("an object with a field named `"+s+"`",n);var o=F(e.decoder,n[s]);return"ok"===o.tag?o:H(s,o);case"index":var c=e.index;if(!(n instanceof Array))return k("an array",n);if(c>=n.length)return k("a longer array. Need index "+c+" but there are only "+n.length+" entries",n);var o=F(e.decoder,n[c]);return"ok"===o.tag?o:D(c,o);case"key-value":if("object"!=typeof n||null===n||n instanceof Array)return k("an object",n);var l=y.Nil;for(var d in n){var o=F(e.decoder,n[d]);if("ok"!==o.tag)return H(d,o);var u=m.Tuple2(d,o.value);l=y.Cons(u,l)}return I(l);case"map-many":for(var p=e.func,h=e.decoders,r=0;r<h.length;r++){var o=F(h[r],n);if("ok"!==o.tag)return o;p=p(o.value)}return I(p);case"andThen":var o=F(e.decoder,n);return"ok"!==o.tag?o:F(e.callback(o.value),n);case"oneOf":for(var v=[],g=e.decoders;"[]"!==g.ctor;){var o=F(g._0,n);if("ok"===o.tag)return o;v.push(o),g=g._1}return P(v);case"fail":return W(e.msg);case"succeed":return I(e.msg)}}function q(e,n){if(e===n)return!0;if(e.tag!==n.tag)return!1;switch(e.tag){case"succeed":case"fail":return e.msg===n.msg;case"bool":case"int":case"float":case"string":case"value":return!0;case"null":return e.value===n.value;case"list":case"array":case"maybe":case"key-value":return q(e.decoder,n.decoder);case"field":return e.field===n.field&&q(e.decoder,n.decoder);case"index":return e.index===n.index&&q(e.decoder,n.decoder);case"map-many":return e.func===n.func&&G(e.decoders,n.decoders);case"andThen":return e.callback===n.callback&&q(e.decoder,n.decoder);case"oneOf":return G(e.decoders,n.decoders)}}function G(e,n){var t=e.length;if(t!==n.length)return!1;for(var r=0;r<t;r++)if(!q(e[r],n[r]))return!1;return!0}function V(e,n){return JSON.stringify(n,null,e)}function z(e){return e}function J(e){for(var n={};"[]"!==e.ctor;){var t=e._0;n[t._0]=t._1,e=e._1}return n}return{encode:n(V),runOnString:n(B),run:n(j),decodeNull:p,decodePrimitive:d,decodeContainer:n(u),decodeField:n(h),decodeIndex:n(v),map1:n(N),map2:t(S),map3:r(M),map4:o(C),map5:a(L),map6:i(x),map7:s(R),map8:c(O),decodeKeyValuePairs:g,andThen:n(_),fail:l,succeed:e,oneOf:E,identity:z,encodeNull:null,encodeArray:f.toJSArray,encodeList:y.toArray,encodeObject:J,equality:q}}()),We=(Pe.encodeList,Pe.encodeArray,Pe.encodeObject,Pe.encodeNull,Pe.identity),Ae=(Pe.identity,Pe.identity,Pe.identity),Ue=(Pe.encode,Pe.decodeNull,Pe.decodePrimitive("value"),Pe.andThen,Pe.fail,Pe.succeed,Pe.run),Be=(Pe.runOnString,Pe.map8,Pe.map7,Pe.map6,Pe.map5,Pe.map4,Pe.map3,Pe.map2,Pe.map1),je=(Pe.oneOf,Pe.decodeIndex,Pe.decodeField),Fe=n(function(e,n){return d(S,je,n,e)}),qe=(Pe.decodeKeyValuePairs,Pe.decodePrimitive("float"),Pe.decodePrimitive("int")),Ge=Pe.decodePrimitive("bool"),Ve=Pe.decodePrimitive("string"),ze=function(){function e(e){return{type:"text",text:e}}function o(e){return n(function(n,t){return a(e,n,t)})}function a(e,n,t){for(var r=v(n),o=r.namespace,a=r.facts,i=[],s=0;"[]"!==t.ctor;){var c=t._0;s+=c.descendantsCount||0,i.push(c),t=t._1}return s+=i.length,{type:"node",tag:e,facts:a,children:i,namespace:o,descendantsCount:s}}function i(e,n,t){for(var r=v(n),o=r.namespace,a=r.facts,i=[],s=0;"[]"!==t.ctor;){var c=t._0;s+=c._1.descendantsCount||0,i.push(c),t=t._1}return s+=i.length,{type:"keyed-node",tag:e,facts:a,children:i,namespace:o,descendantsCount:s}}function s(e,n,t){var r=v(e).facts;return{type:"custom",facts:r,model:n,impl:t}}function c(e,n){return{type:"tagger",tagger:e,node:n,descendantsCount:1+(n.descendantsCount||0)}}function u(e,n,t){return{type:"thunk",func:e,args:n,thunk:t,node:void 0}}function p(e,n){return u(e,[n],function(){return e(n)})}function f(e,n,t){return u(e,[n,t],function(){return l(e,n,t)})}function h(e,n,t,r){return u(e,[n,t,r],function(){return d(e,n,t,r)})}function v(e){for(var n,t={};"[]"!==e.ctor;){var r=e._0,o=r.key;if(o===he||o===me||o===fe){var a=t[o]||{};a[r.realKey]=r.value,t[o]=a}else if(o===pe){for(var i=t[o]||{},s=r.value;"[]"!==s.ctor;){var c=s._0;i[c._0]=c._1,s=s._1}t[o]=i}else if("namespace"===o)n=r.value;else if("className"===o){var l=t[o];t[o]="undefined"==typeof l?r.value:l+" "+r.value}else t[o]=r.value;e=e._1}return{facts:t,namespace:n}}function g(e){return{key:pe,value:e}}function w(e,n){return{key:e,value:n}}function _(e,n){return{key:he,realKey:e,value:n}}function b(e,n,t){return{key:me,realKey:n,value:{value:t,namespace:e}}}function T(e,n,t){return{key:fe,realKey:e,value:{options:n,decoder:t}}}function y(e,n){return(!e.options!==n.options||e.stopPropagation===n.stopPropagation&&e.preventDefault===n.preventDefault)&&Pe.equality(e.decoder,n.decoder)}function E(e,n){return n.key!==fe?n:T(n.realKey,n.value.options,l(Be,e,n.value.decoder))}function N(e,n){switch(e.type){case"thunk":return e.node||(e.node=e.thunk()),N(e.node,n);case"tagger":for(var t=e.node,r=e.tagger;"tagger"===t.type;)"object"!=typeof r?r=[r,t.tagger]:r.push(t.tagger),t=t.node;var o={tagger:r,parent:n},a=N(t,o);return a.elm_event_node_ref=o,a;case"text":return ve.createTextNode(e.text);case"node":var a=e.namespace?ve.createElementNS(e.namespace,e.tag):ve.createElement(e.tag);S(a,n,e.facts);for(var i=e.children,s=0;s<i.length;s++)a.appendChild(N(i[s],n));return a;case"keyed-node":var a=e.namespace?ve.createElementNS(e.namespace,e.tag):ve.createElement(e.tag);S(a,n,e.facts);for(var i=e.children,s=0;s<i.length;s++)a.appendChild(N(i[s]._1,n));return a;case"custom":var a=e.impl.render(e.model);return S(a,n,e.facts),a}}function S(e,n,t){for(var r in t){var o=t[r];switch(r){case pe:M(e,o);break;case fe:C(e,n,o);break;case he:R(e,o);break;case me:O(e,o);break;case"value":e[r]!==o&&(e[r]=o);break;default:e[r]=o}}}function M(e,n){var t=e.style;for(var r in n)t[r]=n[r]}function C(e,n,t){var r=e.elm_handlers||{};for(var o in t){var a=r[o],i=t[o];if("undefined"==typeof i)e.removeEventListener(o,a),r[o]=void 0;else if("undefined"==typeof a){var a=L(n,i);e.addEventListener(o,a),r[o]=a}else a.info=i}e.elm_handlers=r}function L(e,n){function t(n){var r=t.info,o=l(Pe.run,r.decoder,n);if("Ok"===o.ctor){var a=r.options;a.stopPropagation&&n.stopPropagation(),a.preventDefault&&n.preventDefault();for(var i=o._0,s=e;s;){var c=s.tagger;if("function"==typeof c)i=c(i);else for(var d=c.length;d--;)i=c[d](i);s=s.parent}}}return t.info=n,t}function R(e,n){for(var t in n){var r=n[t];"undefined"==typeof r?e.removeAttribute(t):e.setAttribute(t,r)}}function O(e,n){for(var t in n){var r=n[t],o=r.namespace,a=r.value;"undefined"==typeof a?e.removeAttributeNS(o,t):e.setAttributeNS(o,t,a)}}function I(e,n){var t=[];return D(e,n,t,0),t}function k(e,n,t){return{index:n,type:e,data:t,domNode:void 0,eventNode:void 0}}function D(e,n,t,r){if(e!==n){var o=e.type,a=n.type;if(o!==a)return void t.push(k("p-redraw",r,n));switch(a){case"thunk":for(var i=e.args,s=n.args,c=i.length,l=e.func===n.func&&c===s.length;l&&c--;)l=i[c]===s[c];if(l)return void(n.node=e.node);n.node=n.thunk();var d=[];return D(e.node,n.node,d,0),void(d.length>0&&t.push(k("p-thunk",r,d)));case"tagger":for(var u=e.tagger,p=n.tagger,f=!1,h=e.node;"tagger"===h.type;)f=!0,"object"!=typeof u?u=[u,h.tagger]:u.push(h.tagger),h=h.node;for(var m=n.node;"tagger"===m.type;)f=!0,"object"!=typeof p?p=[p,m.tagger]:p.push(m.tagger),m=m.node;return f&&u.length!==p.length?void t.push(k("p-redraw",r,n)):((f?H(u,p):u===p)||t.push(k("p-tagger",r,p)),void D(h,m,t,r+1));case"text":if(e.text!==n.text)return void t.push(k("p-text",r,n.text));return;case"node":if(e.tag!==n.tag||e.namespace!==n.namespace)return void t.push(k("p-redraw",r,n));var v=P(e.facts,n.facts);return"undefined"!=typeof v&&t.push(k("p-facts",r,v)),void W(e,n,t,r);case"keyed-node":if(e.tag!==n.tag||e.namespace!==n.namespace)return void t.push(k("p-redraw",r,n));var v=P(e.facts,n.facts);return"undefined"!=typeof v&&t.push(k("p-facts",r,v)),void A(e,n,t,r);case"custom":if(e.impl!==n.impl)return void t.push(k("p-redraw",r,n));var v=P(e.facts,n.facts);"undefined"!=typeof v&&t.push(k("p-facts",r,v));var g=n.impl.diff(e,n);if(g)return void t.push(k("p-custom",r,g));return}}}function H(e,n){for(var t=0;t<e.length;t++)if(e[t]!==n[t])return!1;return!0}function P(e,n,t){var r;for(var o in e)if(o!==pe&&o!==fe&&o!==he&&o!==me)if(o in n){var a=e[o],i=n[o];a===i&&"value"!==o||t===fe&&y(a,i)||(r=r||{},r[o]=i)}else r=r||{},r[o]="undefined"==typeof t?"string"==typeof e[o]?"":null:t===pe?"":t===fe||t===he?void 0:{namespace:e[o].namespace,value:void 0};else{var s=P(e[o],n[o]||{},o);s&&(r=r||{},r[o]=s)}for(var c in n)c in e||(r=r||{},r[c]=n[c]);return r}function W(e,n,t,r){var o=e.children,a=n.children,i=o.length,s=a.length;i>s?t.push(k("p-remove-last",r,i-s)):i<s&&t.push(k("p-append",r,a.slice(i)));for(var c=r,l=i<s?i:s,d=0;d<l;d++){c++;var u=o[d];D(u,a[d],t,c),c+=u.descendantsCount||0}}function A(e,n,t,r){for(var o=[],a={},i=[],s=e.children,c=n.children,l=s.length,d=c.length,u=0,p=0,f=r;u<l&&p<d;){var h=s[u],m=c[p],v=h._0,g=m._0,w=h._1,_=m._1;if(v!==g){var b=u+1<l,T=p+1<d;if(b)var y=s[u+1],E=y._0,N=y._1,S=g===E;if(T)var M=c[p+1],C=M._0,L=M._1,x=v===C;if(b&&T&&x&&S)f++,D(w,L,o,f),U(a,o,v,_,p,i),f+=w.descendantsCount||0,f++,B(a,o,v,N,f),f+=N.descendantsCount||0,u+=2,p+=2;else if(T&&x)f++,U(a,o,g,_,p,i),D(w,L,o,f),f+=w.descendantsCount||0,u+=1,p+=2;else if(b&&S)f++,B(a,o,v,w,f),f+=w.descendantsCount||0,f++,D(N,_,o,f),f+=N.descendantsCount||0,u+=2,p+=1;else{if(!b||!T||E!==C)break;f++,B(a,o,v,w,f),U(a,o,g,_,p,i),f+=w.descendantsCount||0,f++,D(N,L,o,f),f+=N.descendantsCount||0,u+=2,p+=2}}else f++,D(w,_,o,f),f+=w.descendantsCount||0,u++,p++}for(;u<l;){f++;var h=s[u],w=h._1;B(a,o,h._0,w,f),f+=w.descendantsCount||0,u++}for(var R;p<d;){R=R||[];var m=c[p];U(a,o,m._0,m._1,void 0,R),p++}(o.length>0||i.length>0||"undefined"!=typeof R)&&t.push(k("p-reorder",r,{patches:o,inserts:i,endInserts:R}))}function U(e,n,t,r,o,a){var i=e[t];if("undefined"==typeof i)return i={tag:"insert",vnode:r,index:o,data:void 0},a.push({index:o,entry:i}),void(e[t]=i);if("remove"===i.tag){a.push({index:o,entry:i}),i.tag="move";var s=[];return D(i.vnode,r,s,i.index),i.index=o,void(i.data.data={patches:s,entry:i})}U(e,n,t+ge,r,o,a)}function B(e,n,t,r,o){var a=e[t];if("undefined"==typeof a){var i=k("p-remove",o,void 0);return n.push(i),void(e[t]={tag:"remove",vnode:r,index:o,data:i})}if("insert"===a.tag){a.tag="move";var s=[];D(r,a.vnode,s,o);var i=k("p-remove",o,{patches:s,entry:a});return void n.push(i)}B(e,n,t+ge,r,o)}function j(e,n,t,r){F(e,n,t,0,0,n.descendantsCount,r)}function F(e,n,t,r,o,a,i){for(var s=t[r],c=s.index;c===o;){var l=s.type;if("p-thunk"===l)j(e,n.node,s.data,i);else if("p-reorder"===l){s.domNode=e,s.eventNode=i;var d=s.data.patches;d.length>0&&F(e,n,d,0,o,a,i)}else if("p-remove"===l){s.domNode=e,s.eventNode=i;var u=s.data;if("undefined"!=typeof u){u.entry.data=e;var d=u.patches;d.length>0&&F(e,n,d,0,o,a,i)}}else s.domNode=e,s.eventNode=i;if(r++,!(s=t[r])||(c=s.index)>a)return r}switch(n.type){case"tagger":for(var p=n.node;"tagger"===p.type;)p=p.node;return F(e,p,t,r,o+1,a,e.elm_event_node_ref);case"node":for(var f=n.children,h=e.childNodes,m=0;m<f.length;m++){o++;var v=f[m],g=o+(v.descendantsCount||0);if(o<=c&&c<=g&&(r=F(h[m],v,t,r,o,g,i),!(s=t[r])||(c=s.index)>a))return r;o=g}return r;case"keyed-node":for(var f=n.children,h=e.childNodes,m=0;m<f.length;m++){o++;var v=f[m]._1,g=o+(v.descendantsCount||0);if(o<=c&&c<=g&&(r=F(h[m],v,t,r,o,g,i),!(s=t[r])||(c=s.index)>a))return r;o=g}return r;case"text":case"thunk":throw new Error("should never traverse `text` or `thunk` nodes like this")}}function q(e,n,t,r){return 0===t.length?e:(j(e,n,t,r),G(e,t))}function G(e,n){for(var t=0;t<n.length;t++){var r=n[t],o=r.domNode,a=V(o,r);o===e&&(e=a)}return e}function V(e,n){switch(n.type){case"p-redraw":return z(e,n.data,n.eventNode);case"p-facts":return S(e,n.eventNode,n.data),e;case"p-text":return e.replaceData(0,e.length,n.data),e;case"p-thunk":return G(e,n.data);case"p-tagger":return"undefined"!=typeof e.elm_event_node_ref?e.elm_event_node_ref.tagger=n.data:e.elm_event_node_ref={tagger:n.data,parent:n.eventNode},e;case"p-remove-last":for(var t=n.data;t--;)e.removeChild(e.lastChild);return e;case"p-append":for(var r=n.data,t=0;t<r.length;t++)e.appendChild(N(r[t],n.eventNode));return e;case"p-remove":var o=n.data;if("undefined"==typeof o)return e.parentNode.removeChild(e),e;var a=o.entry;return"undefined"!=typeof a.index&&e.parentNode.removeChild(e),a.data=G(e,o.patches),e;case"p-reorder":return J(e,n);case"p-custom":var i=n.data;return i.applyPatch(e,i.data);default:throw new Error("Ran into an unknown patch!")}}function z(e,n,t){var r=e.parentNode,o=N(n,t);return"undefined"==typeof o.elm_event_node_ref&&(o.elm_event_node_ref=e.elm_event_node_ref),r&&o!==e&&r.replaceChild(o,e),o}function J(e,n){var t=n.data,r=K(t.endInserts,n);e=G(e,t.patches);for(var o=t.inserts,a=0;a<o.length;a++){var i=o[a],s=i.entry,c="move"===s.tag?s.data:N(s.vnode,n.eventNode);e.insertBefore(c,e.childNodes[i.index])}return"undefined"!=typeof r&&e.appendChild(r),e}function K(e,n){if("undefined"!=typeof e){for(var t=ve.createDocumentFragment(),r=0;r<e.length;r++){var o=e[r],a=o.entry;t.appendChild("move"===a.tag?a.data:N(a.vnode,n.eventNode))}return t}}function Y(e){return n(function(n,t){return function(r){return function(o,a,i){var s=e(r,a);"undefined"==typeof i?ee(t,o,a,s):re(l(n,i,t),o,a,s)}}})}function X(e){var t=m.Tuple2(m.Tuple0,Xe);return l(we,x,{init:t,view:function(){return e},update:n(function(){return t}),subscriptions:function(){return Ze}})()}function $(e,n){return function(e,t,r){if("undefined"==typeof t)return e;var o="The `"+n+"` module does not need flags.\nInitialize it with no arguments and you should be all set!";Z(o,r)}}function Q(e,n){return function(t,r,o){if("undefined"==typeof e){var a="Are you trying to sneak a Never value into Elm? Trickster!\nIt looks like "+n+".main is defined with `programWithFlags` but has type `Program Never`.\nUse `program` instead if you do not want flags.";Z(a,o)}var i=l(Pe.run,e,r);if("Ok"===i.ctor)return t(i._0);var a="Trying to initialize the `"+n+"` module with an unexpected flag.\nI tried to convert it to an Elm value, but ran into this problem:\n\n"+i._0;Z(a,o)}}function Z(e,n){throw n&&(n.innerHTML='<div style="padding-left:1em;"><h2 style="font-weight:normal;"><b>Oops!</b> Something went wrong when starting your Elm program.</h2><pre style="padding-left:1em;">'+e+"</pre></div>"),new Error(e)}function ee(e,n,t,r){n.embed=function(n,t){for(;n.lastChild;)n.removeChild(n.lastChild);return Je.initialize(r(e.init,t,n),e.update,e.subscriptions,ne(n,e.view))},n.fullscreen=function(n){return Je.initialize(r(e.init,n,document.body),e.update,e.subscriptions,ne(document.body,e.view))}}function ne(e,n){return function(t,r){var o={tagger:t,parent:void 0},a=n(r),i=N(a,o);return e.appendChild(i),te(i,n,a,o)}}function te(e,n,t,r){function o(){switch(i){case"NO_REQUEST":throw new Error("Unexpected draw callback.\nPlease report this to <https://github.com/elm-lang/virtual-dom/issues>.");case"PENDING_REQUEST":be(o),i="EXTRA_REQUEST";var t=n(a),c=I(s,t);return e=q(e,s,c,r),void(s=t);case"EXTRA_REQUEST":return void(i="NO_REQUEST")}}var a,i="NO_REQUEST",s=t;return function(e){"NO_REQUEST"===i&&be(o),i="PENDING_REQUEST",a=e}}function re(e,n,t,r){n.fullscreen=function(n){var o={doc:void 0};return Je.initialize(r(e.init,n,document.body),e.update(oe(o)),e.subscriptions,ae(t,document.body,o,e.view,e.viewIn,e.viewOut))},n.embed=function(n,o){var a={doc:void 0};return Je.initialize(r(e.init,o,n),e.update(oe(a)),e.subscriptions,ae(t,n,a,e.view,e.viewIn,e.viewOut))}}function oe(e){return Ke.nativeBinding(function(n){var t=e.doc;if(t){var r=t.getElementsByClassName("debugger-sidebar-messages")[0];r&&(r.scrollTop=r.scrollHeight)}n(Ke.succeed(m.Tuple0))})}function ae(e,n,t,r,o,a){return function(i,s){var c={tagger:i,parent:void 0},l={tagger:i,parent:void 0},d=r(s),u=N(d,c);n.appendChild(u);var p=te(u,r,d,c),f=o(s)._1,h=N(f,l);n.appendChild(h);var m=ce(c,h,o),v=te(h,m,f,l),g=ie(s,a,l,n,e,t);return function(e){p(e),v(e),g(e)}}}function ie(e,n,t,r,o,a){var i,s;return function(e){if(e.isDebuggerOpen){if(!a.doc)return i=n(e),void(s=se(o,a,i,t));ve=a.doc;var r=n(e),c=I(i,r);s=q(s,i,c,t),i=r,ve=document}}}function se(e,n,t,r){function o(){n.doc=void 0,l.close()}var a=900,i=360,s=screen.width-a,c=screen.height-i,l=window.open("","","width="+a+",height="+i+",left="+s+",top="+c);ve=l.document,n.doc=ve,ve.title="Debugger - "+e,ve.body.style.margin="0",ve.body.style.padding="0";var d=N(t,r);return ve.body.appendChild(d),ve.addEventListener("keydown",function(e){e.metaKey&&82===e.which&&window.location.reload(),38===e.which&&(r.tagger({ctor:"Up"}),e.preventDefault()),40===e.which&&(r.tagger({ctor:"Down"}),e.preventDefault())}),window.addEventListener("unload",o),l.addEventListener("unload",function(){n.doc=void 0,window.removeEventListener("unload",o),r.tagger({ctor:"Close"})}),ve=document,d}function ce(e,n,t){var r,o=ue(n),a="Normal",i=e.tagger,s=function(){};return function(n){var c=t(n),l=c._0.ctor;return e.tagger="Normal"===l?i:s,a!==l&&(le("removeEventListener",o,a),le("addEventListener",o,l),"Normal"===a&&(r=document.body.style.overflow,document.body.style.overflow="hidden"),"Normal"===l&&(document.body.style.overflow=r),a=l),c._1}}function le(e,n,t){switch(t){case"Normal":return;case"Pause":return de(e,n,Te);case"Message":return de(e,n,ye)}}function de(e,n,t){for(var r=0;r<t.length;r++)document.body[e](t[r],n,!0)}function ue(e){return function(n){if("keydown"!==n.type||!n.metaKey||82!==n.which){for(var t="scroll"===n.type||"wheel"===n.type,r=n.target;null!==r;){if("elm-overlay-message-details"===r.className&&t)return;if(r===e&&!t)return;r=r.parentNode}n.stopPropagation(),n.preventDefault()}}}var pe="STYLE",fe="EVENT",he="ATTR",me="ATTR_NS",ve="undefined"!=typeof document?document:{},ge="_elmW6BL",we=Y($),_e=Y(Q),be="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:function(e){e()},Te=["click","dblclick","mousemove","mouseup","mousedown","mouseenter","mouseleave","touchstart","touchend","touchcancel","touchmove","pointerdown","pointerup","pointerover","pointerout","pointerenter","pointerleave","pointermove","pointercancel","dragstart","drag","dragend","dragenter","dragover","dragleave","drop","keyup","keydown","keypress","input","change","focus","blur"],ye=Te.concat("wheel","scroll");return{node:o,text:e,custom:s,map:n(c),on:t(T),style:g,property:n(w),attribute:n(_),attributeNS:t(b),mapProperty:n(E),lazy:n(p),lazy2:t(f),lazy3:r(h),keyedNode:t(i),program:we,programWithFlags:_e,staticProgram:X}}(),Je=(q.crash,q.log,n(function(e,n){var t=n;return{ctor:"_Tuple2",_0:t._0,_1:e(t._1)}}),n(function(e,n){var t=n;return{ctor:"_Tuple2",_0:e(t._0),_1:t._1}}),function(){function e(e){return function(n){return function(n,t){n.worker=function(n){if("undefined"!=typeof n)throw new Error("The `"+t+"` module does not need flags.\nCall "+t+".worker() with no arguments and you should be all set!");return i(e.init,e.update,e.subscriptions,o)}}}}function r(e){return function(n){return function(t,r){t.worker=function(t){if("undefined"==typeof n)throw new Error("Are you trying to sneak a Never value into Elm? Trickster!\nIt looks like "+r+".main is defined with `programWithFlags` but has type `Program Never`.\nUse `program` instead if you do not want flags.");var a=l(Pe.run,n,t);if("Err"===a.ctor)throw new Error(r+".worker(...) was called with an unexpected argument.\nI tried to convert it to an Elm value, but ran into this problem:\n\n"+a._0);return i(e.init(a._0),e.update,e.subscriptions,o)}}}}function o(e,n){return function(e){}}function a(e){var t=g(y.Nil),r=m.Tuple2(m.Tuple0,t);return en({init:r,view:function(e){return main},update:n(function(e,n){return r}),subscriptions:function(e){return t}})}function i(e,n,t,r){function o(e,r){return Ke.nativeBinding(function(o){var a=l(n,e,r);r=a._0,i(r);var s=a._1,d=t(r);_(c,s,d),o(Ke.succeed(r))})}function a(e){Ke.rawSend(u,e)}var i,c={},d=Ke.nativeBinding(function(n){var o=e._0;i=r(a,o);var s=e._1,l=t(o);_(c,s,l),n(Ke.succeed(o))}),u=h(d,o),p=s(c,a);return p?{ports:p}:{}}function s(e,n){var t;for(var r in x){var o=x[r];o.isForeign&&(t=t||{},t[r]="cmd"===o.tag?M(r):L(r,n)),e[r]=c(o,n)}return t}function c(e,n){function t(e,n){if("self"===e.ctor)return d(i,r,e._0,n);var t=e._0;switch(o){case"cmd":return d(a,r,t.cmds,n);case"sub":return d(a,r,t.subs,n);case"fx":return u(a,r,t.cmds,t.subs,n)}}var r={main:n,self:void 0},o=e.tag,a=e.onEffects,i=e.onSelfMsg,s=h(e.init,t);return r.self=s,s}function p(e,n){return Ke.nativeBinding(function(t){e.main(n),t(Ke.succeed(m.Tuple0))})}function f(e,n){return l(Ke.send,e.self,{ctor:"self",_0:n})}function h(e,n){function t(e){var o=Ke.receive(function(t){return n(t,e)});return l(r,t,o)}var r=Ke.andThen,o=l(r,t,e);return Ke.rawSpawn(o)}function v(e){return function(n){return{type:"leaf",home:e,value:n}}}function g(e){return{type:"node",branches:e}}function w(e,n){return{type:"map",tagger:e,tree:n}}function _(e,n,t){var r={};b(!0,n,r,null),b(!1,t,r,null);for(var o in e){var a=o in r?r[o]:{cmds:y.Nil,subs:y.Nil};Ke.rawSend(e[o],{ctor:"fx",_0:a})}}function b(e,n,t,r){switch(n.type){case"leaf":var o=n.home,a=T(e,o,r,n.value);return void(t[o]=E(e,a,t[o]));case"node":for(var i=n.branches;"[]"!==i.ctor;)b(e,i._0,t,r),i=i._1;return;case"map":return void b(e,n.tree,t,{tagger:n.tagger,rest:r})}}function T(e,n,t,r){function o(e){for(var n=t;n;)e=n.tagger(e),n=n.rest;return e}var a=e?x[n].cmdMap:x[n].subMap;return l(a,o,r)}function E(e,n,t){return t=t||{cmds:y.Nil,subs:y.Nil},e?(t.cmds=y.Cons(n,t.cmds),t):(t.subs=y.Cons(n,t.subs),t)}function N(e){if(e in x)throw new Error("There can only be one port named `"+e+"`, but your program has multiple.")}function S(e,n){return N(e),x[e]={tag:"cmd",cmdMap:R,converter:n,isForeign:!0},v(e)}function M(e){function n(e,n,t){for(;"[]"!==n.ctor;){for(var r=a,o=i(n._0),c=0;c<r.length;c++)r[c](o);n=n._1}return s}function r(e){a.push(e)}function o(e){a=a.slice();var n=a.indexOf(e);n>=0&&a.splice(n,1)}var a=[],i=x[e].converter,s=Ke.succeed(null);return x[e].init=s,x[e].onEffects=t(n),{subscribe:r,unsubscribe:o}}function C(e,n){return N(e),x[e]={tag:"sub",subMap:O,converter:n,isForeign:!0},v(e)}function L(e,n){function r(e,n,t){for(var r=o(e,n,t),a=0;a<d.length;a++)s(d[a]);return d=null,h=s,f=o,r}function o(e,n,t){return u=n,m}function a(e,n,t){return f(e,n,t)}function i(e){d.push(e)}function s(t){var r=l(Ue,p,t);if("Err"===r.ctor)throw new Error("Trying to send an unexpected type of value through port `"+e+"`:\n"+r._0);for(var o=r._0,a=u;"[]"!==a.ctor;)n(a._0(o)),
a=a._1}function c(e){h(e)}var d=[],u=y.Nil,p=x[e].converter,f=r,h=i,m=Ke.succeed(null);return x[e].init=m,x[e].onEffects=t(a),{send:c}}var x={},R=n(function(e,n){return n}),O=n(function(e,n){return function(t){return e(n(t))}});return{sendToApp:n(p),sendToSelf:n(f),effectManagers:x,outgoingPort:S,incomingPort:C,htmlToProgram:a,program:e,programWithFlags:r,initialize:i,leaf:v,batch:g,map:n(w)}}()),Ke=function(){function e(e){return{ctor:"_Task_succeed",value:e}}function t(e){return{ctor:"_Task_fail",value:e}}function r(e){return{ctor:"_Task_nativeBinding",callback:e,cancel:null}}function o(e,n){return{ctor:"_Task_andThen",callback:e,task:n}}function a(e,n){return{ctor:"_Task_onError",callback:e,task:n}}function i(e){return{ctor:"_Task_receive",callback:e}}function s(e){var n={ctor:"_Process",id:m.guid(),root:e,stack:null,mailbox:[]};return h(n),n}function c(n){return r(function(t){var r=s(n);t(e(r))})}function l(e,n){e.mailbox.push(n),h(e)}function d(n,t){return r(function(r){l(n,t),r(e(m.Tuple0))})}function u(n){return r(function(t){var r=n.root;"_Task_nativeBinding"===r.ctor&&r.cancel&&r.cancel(),n.root=null,t(e(m.Tuple0))})}function p(n){return r(function(t){var r=setTimeout(function(){t(e(m.Tuple0))},n);return function(){clearTimeout(r)}})}function f(e,n){for(;e<g;){var t=n.root.ctor;if("_Task_succeed"!==t)if("_Task_fail"!==t)if("_Task_andThen"!==t)if("_Task_onError"!==t){if("_Task_nativeBinding"===t){n.root.cancel=n.root.callback(function(e){n.root=e,h(n)});break}if("_Task_receive"!==t)throw new Error(t);var r=n.mailbox;if(0===r.length)break;n.root=n.root.callback(r.shift()),++e}else n.stack={ctor:"_Task_onError",callback:n.root.callback,rest:n.stack},n.root=n.root.task,++e;else n.stack={ctor:"_Task_andThen",callback:n.root.callback,rest:n.stack},n.root=n.root.task,++e;else{for(;n.stack&&"_Task_andThen"===n.stack.ctor;)n.stack=n.stack.rest;if(null===n.stack)break;n.root=n.stack.callback(n.root.value),n.stack=n.stack.rest,++e}else{for(;n.stack&&"_Task_onError"===n.stack.ctor;)n.stack=n.stack.rest;if(null===n.stack)break;n.root=n.stack.callback(n.root.value),n.stack=n.stack.rest,++e}}return e<g?e+1:(h(n),e)}function h(e){_.push(e),w||(setTimeout(v,0),w=!0)}function v(){for(var e,n=0;n<g&&(e=_.shift());)e.root&&(n=f(n,e));return e?void setTimeout(v,0):void(w=!1)}var g=1e4,w=!1,_=[];return{succeed:e,fail:t,nativeBinding:r,andThen:n(o),onError:n(a),receive:i,spawn:c,kill:u,sleep:p,send:n(d),rawSpawn:s,rawSend:l}}(),Ye=Je.batch,Xe=Ye({ctor:"[]"}),$e=$e||{};$e["!"]=n(function(e,n){return{ctor:"_Tuple2",_0:e,_1:Ye(n)}});var Qe=(Je.map,Je.batch),Ze=Qe({ctor:"[]"}),en=(Je.map,Ke.succeed,Je.sendToSelf,Je.sendToApp,Je.programWithFlags,Je.program,function(e){return l(ze.program,x,e)}),nn=(ze.keyedNode,ze.lazy3,ze.lazy2,ze.lazy,{stopPropagation:!1,preventDefault:!1}),tn=ze.on,rn=n(function(e,n){return d(tn,e,nn,n)}),on=(ze.style,ze.mapProperty,ze.attributeNS),an=ze.attribute,sn=ze.property,cn=(ze.map,ze.text),ln=ze.node,dn=(n(function(e,n){return{stopPropagation:e,preventDefault:n}}),en),un=cn,pn=ln,fn=(pn("body"),pn("section"),pn("nav"),pn("article"),pn("aside"),pn("h1"),pn("h2"),pn("h3"),pn("h4"),pn("h5"),pn("h6"),pn("header"),pn("footer"),pn("address"),pn("main"),pn("p"),pn("hr"),pn("pre"),pn("blockquote"),pn("ol"),pn("ul"),pn("li"),pn("dl"),pn("dt"),pn("dd"),pn("figure"),pn("figcaption"),pn("div")),hn=pn("a"),mn=(pn("em"),pn("strong"),pn("small"),pn("s"),pn("cite"),pn("q"),pn("dfn"),pn("abbr"),pn("time"),pn("code"),pn("var"),pn("samp"),pn("kbd"),pn("sub"),pn("sup"),pn("i"),pn("b"),pn("u"),pn("mark"),pn("ruby"),pn("rt"),pn("rp"),pn("bdi"),pn("bdo"),pn("span")),vn=pn("br"),gn=(pn("wbr"),pn("ins"),pn("del"),pn("img")),wn=(pn("iframe"),pn("embed"),pn("object"),pn("param"),pn("video"),pn("audio"),pn("source"),pn("track"),pn("canvas"),pn("math"),pn("table"),pn("caption"),pn("colgroup"),pn("col"),pn("tbody"),pn("thead"),pn("tfoot"),pn("tr"),pn("td"),pn("th"),pn("form"),pn("fieldset"),pn("legend"),pn("label"),pn("input"),pn("button"),pn("select"),pn("datalist"),pn("optgroup"),pn("option"),pn("textarea"),pn("keygen"),pn("output"),pn("progress"),pn("meter"),pn("details"),pn("summary"),pn("menuitem"),pn("menu"),function(e){return pn(l(g["++"],"app-",e))}),_n=(wn("drawer"),wn("drawer-layout"),wn("header")),bn=wn("header-layout"),Tn=(wn("route"),wn("toolbar")),yn=an,En=sn,Nn=n(function(e,n){return l(En,e,Ae(n))}),Sn=function(e){return l(Nn,"className",e)},Mn=function(e){return l(Nn,"src",e)},Cn=function(e){return l(Nn,"value",e)},Ln=function(e){return l(Nn,"href",e)},xn=(n(function(e,n){return l(En,e,We(n))}),l(je,"keyCode",qe),l(Fe,{ctor:"::",_0:"target",_1:{ctor:"::",_0:"checked",_1:{ctor:"[]"}}},Ge),l(Fe,{ctor:"::",_0:"target",_1:{ctor:"::",_0:"value",_1:{ctor:"[]"}}},Ve)),Rn=nn,On=rn,In=(m.update(Rn,{preventDefault:!0}),function(e){return l(On,"input",l(Be,e,xn))}),kn=(n(function(e,n){return{stopPropagation:e,preventDefault:n}}),function(e){return pn(l(g["++"],"paper-",e))}),Dn=(kn("badge"),kn("behaviors"),kn("button"),kn("card")),Hn=(kn("checkbox"),kn("dialog"),kn("dialog-behavior"),kn("dialog-scrollable"),kn("drawer-panel"),kn("dropdown-menu"),kn("fab"),kn("header-panel"),kn("icon-button"),kn("input")),Pn=(kn("item"),kn("icon-item"),kn("item-body"),kn("listbox"),kn("material"),kn("menu"),kn("menu-button"),kn("progress"),kn("radio-button"),kn("radio-group"),kn("ripple"),kn("scroll-header-panel"),kn("slider"),kn("spinner"),kn("styles"),kn("tabs"),kn("tab"),kn("toast"),kn("toggle-button"),kn("toolbar"),kn("tooltip"),l(sn,"namespace",Ae("http://www.w3.org/2000/svg"))),Wn=t(function(e,n,t){return d(ln,e,{ctor:"::",_0:Pn,_1:n},t)}),An=Wn("svg"),Un=(Wn("foreignObject"),Wn("animate"),Wn("animateColor"),Wn("animateMotion"),Wn("animateTransform"),Wn("mpath"),Wn("set"),Wn("a"),Wn("defs"),Wn("g"),Wn("marker"),Wn("mask"),Wn("pattern"),Wn("switch"),Wn("symbol"),Wn("desc"),Wn("metadata"),Wn("title"),Wn("feBlend"),Wn("feColorMatrix"),Wn("feComponentTransfer"),Wn("feComposite"),Wn("feConvolveMatrix"),Wn("feDiffuseLighting"),Wn("feDisplacementMap"),Wn("feFlood"),Wn("feFuncA"),Wn("feFuncB"),Wn("feFuncG"),Wn("feFuncR"),Wn("feGaussianBlur"),Wn("feImage"),Wn("feMerge"),Wn("feMergeNode"),Wn("feMorphology"),Wn("feOffset"),Wn("feSpecularLighting"),Wn("feTile"),Wn("feTurbulence"),Wn("font"),Wn("linearGradient"),Wn("radialGradient"),Wn("stop"),Wn("circle"),Wn("ellipse"),Wn("image"),Wn("line"),Wn("path")),Bn=(Wn("polygon"),Wn("polyline"),Wn("rect"),Wn("use"),Wn("feDistantLight"),Wn("fePointLight"),Wn("feSpotLight"),Wn("altGlyph"),Wn("altGlyphDef"),Wn("altGlyphItem"),Wn("glyph"),Wn("glyphRef"),Wn("textPath"),Wn("text"),Wn("tref"),Wn("tspan"),Wn("clipPath"),Wn("colorProfile"),Wn("cursor"),Wn("filter"),Wn("script"),Wn("style"),Wn("view"),an("writing-mode"),an("word-spacing"),an("visibility"),an("unicode-bidi"),an("text-rendering"),an("text-decoration"),an("text-anchor"),an("stroke"),an("stroke-width"),an("stroke-opacity"),an("stroke-miterlimit"),an("stroke-linejoin"),an("stroke-linecap"),an("stroke-dashoffset"),an("stroke-dasharray"),an("stop-opacity"),an("stop-color"),an("shape-rendering"),an("pointer-events"),an("overflow"),an("opacity"),an("mask"),an("marker-start"),an("marker-mid"),an("marker-end"),an("lighting-color"),an("letter-spacing"),an("kerning"),an("image-rendering"),an("glyph-orientation-vertical"),an("glyph-orientation-horizontal"),an("font-weight"),an("font-variant"),an("font-style"),an("font-stretch"),an("font-size"),an("font-size-adjust"),an("font-family"),an("flood-opacity"),an("flood-color"),an("filter"),an("fill")),jn=(an("fill-rule"),an("fill-opacity"),an("enable-background"),an("dominant-baseline"),an("display"),an("direction"),an("cursor"),an("color"),an("color-rendering"),an("color-profile"),an("color-interpolation"),an("color-interpolation-filters"),an("clip"),an("clip-rule"),an("clip-path"),an("baseline-shift"),an("alignment-baseline"),an("zoomAndPan"),an("z"),an("yChannelSelector"),an("y2"),an("y1"),an("y"),l(on,"http://www.w3.org/XML/1998/namespace","xml:space"),l(on,"http://www.w3.org/XML/1998/namespace","xml:lang"),l(on,"http://www.w3.org/XML/1998/namespace","xml:base"),l(on,"http://www.w3.org/1999/xlink","xlink:type"),l(on,"http://www.w3.org/1999/xlink","xlink:title"),l(on,"http://www.w3.org/1999/xlink","xlink:show"),l(on,"http://www.w3.org/1999/xlink","xlink:role"),l(on,"http://www.w3.org/1999/xlink","xlink:href"),l(on,"http://www.w3.org/1999/xlink","xlink:arcrole"),l(on,"http://www.w3.org/1999/xlink","xlink:actuate"),an("xChannelSelector"),an("x2"),an("x1"),an("x-height"),an("x"),an("widths"),an("width")),Fn=(an("viewTarget"),an("viewBox")),qn=(an("vert-origin-y"),an("vert-origin-x"),an("vert-adv-y"),an("version"),an("values"),an("v-mathematical"),an("v-ideographic"),an("v-hanging"),an("v-alphabetic"),an("units-per-em"),an("unicode-range"),an("unicode"),an("underline-thickness"),an("underline-position"),an("u2"),an("u1"),an("type"),an("transform"),an("to"),an("title"),an("textLength"),an("targetY"),an("targetX"),an("target"),an("tableValues"),an("systemLanguage"),an("surfaceScale"),an("style"),an("string"),an("strikethrough-thickness"),an("strikethrough-position"),an("stitchTiles"),an("stemv"),an("stemh"),an("stdDeviation"),an("startOffset"),an("spreadMethod"),an("speed"),an("specularExponent"),an("specularConstant"),an("spacing"),an("slope"),an("seed"),an("scale"),an("ry"),an("rx"),an("rotate"),an("result"),an("restart"),an("requiredFeatures"),an("requiredExtensions"),an("repeatDur"),an("repeatCount"),an("rendering-intent"),an("refY"),an("refX"),an("radius"),an("r"),an("primitiveUnits"),an("preserveAspectRatio"),an("preserveAlpha"),an("pointsAtZ"),an("pointsAtY"),an("pointsAtX"),an("points"),an("point-order"),an("patternUnits"),an("patternTransform"),an("patternContentUnits"),an("pathLength"),an("path"),an("panose-1"),an("overline-thickness"),an("overline-position"),an("origin"),an("orientation"),an("orient"),an("order"),an("operator"),an("offset"),an("numOctaves"),an("name"),an("mode"),an("min"),an("method"),an("media"),an("max"),an("mathematical"),an("maskUnits"),an("maskContentUnits"),an("markerWidth"),an("markerUnits"),an("markerHeight"),an("local"),an("limitingConeAngle"),an("lengthAdjust"),an("lang"),an("keyTimes"),an("keySplines"),an("keyPoints"),an("kernelUnitLength"),an("kernelMatrix"),an("k4"),an("k3"),an("k2"),an("k1"),an("k"),an("intercept"),an("in2"),an("in"),an("ideographic"),an("id"),an("horiz-origin-y"),an("horiz-origin-x"),an("horiz-adv-x"),an("height")),Gn=(an("hanging"),an("gradientUnits"),an("gradientTransform"),an("glyphRef"),an("glyph-name"),an("g2"),an("g1"),an("fy"),an("fx"),an("from"),an("format"),an("filterUnits"),an("filterRes"),an("externalResourcesRequired"),an("exponent"),an("end"),an("elevation"),an("edgeMode"),an("dy"),an("dx"),an("dur"),an("divisor"),an("diffuseConstant"),an("descent"),an("decelerate"),an("d")),Vn=(an("cy"),an("cx"),an("contentStyleType"),an("contentScriptType"),an("clipPathUnits"),an("class")),zn=(an("cap-height"),an("calcMode"),an("by"),an("bias"),an("begin"),an("bbox"),an("baseProfile"),an("baseFrequency"),an("azimuth"),an("autoReverse"),an("attributeType"),an("attributeName"),an("ascent"),an("arabic-form"),an("amplitude"),an("allowReorder"),an("alphabetic"),an("additive"),an("accumulate"),an("accelerate"),an("accent-height"),l(fn,{ctor:"[]"},{ctor:"::",_0:l(hn,{ctor:"::",_0:Ln("https://github.com/dailydrip/meme"),_1:{ctor:"::",_0:Sn("github-corner"),_1:{ctor:"::",_0:l(yn,"ariaLabel","View source on GitHub"),_1:{ctor:"[]"}}}},{ctor:"::",_0:l(An,{ctor:"::",_0:jn("80"),_1:{ctor:"::",_0:qn("80"),_1:{ctor:"::",_0:Fn("0 0 250 250"),_1:{ctor:"::",_0:l(yn,"ariaHidden","true"),_1:{ctor:"[]"}}}}},{ctor:"::",_0:l(Un,{ctor:"::",_0:Gn("M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"),_1:{ctor:"[]"}},{ctor:"[]"}),_1:{ctor:"::",_0:l(Un,{ctor:"::",_0:Gn("M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"),_1:{ctor:"::",_0:Bn("currentColor"),_1:{ctor:"::",_0:Vn("octo-arm"),_1:{ctor:"[]"}}}},{ctor:"[]"}),_1:{ctor:"::",_0:l(Un,{ctor:"::",_0:Gn("M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"),_1:{ctor:"::",_0:Bn("currentColor"),_1:{ctor:"::",_0:Vn("octo-body"),_1:{ctor:"[]"}}}},{ctor:"[]"}),_1:{ctor:"[]"}}}}),_1:{ctor:"[]"}}),_1:{ctor:"[]"}})),Jn=function(e){return Ze},Kn="https://immense-forest-64118.herokuapp.com",Yn=t(function(e,n,t){return l(g["++"],Kn,l(g["++"],"/fly/meme?url=",l(g["++"],e,l(g["++"],"&top=",l(g["++"],n,l(g["++"],"&bottom=",t))))))}),Xn=n(function(e,n){var t=e;switch(t.ctor){case"SetUrl":return l($e["!"],m.update(n,{url:t._0}),{ctor:"[]"});case"SetTop":return l($e["!"],m.update(n,{top:t._0}),{ctor:"[]"});default:return l($e["!"],m.update(n,{bottom:t._0}),{ctor:"[]"})}}),$n={ctor:"_Tuple2",_0:{url:"http://www.rd.com/wp-content/uploads/sites/2/2016/04/01-cat-wants-to-tell-you-laptop.jpg",top:"My friend",bottom:"the cat"},_1:Xe},Qn=(t(function(e,n,t){return{url:e,top:n,bottom:t}}),function(e){return{ctor:"SetBottom",_0:e}}),Zn=function(e){return{ctor:"SetTop",_0:e}},et=function(e){return{ctor:"SetUrl",_0:e}},nt=function(e){return l(fn,{ctor:"[]"},{ctor:"::",_0:l(bn,{ctor:"[]"},{ctor:"::",_0:l(_n,{ctor:"::",_0:l(yn,"effects","waterfall"),_1:{ctor:"::",_0:l(yn,"fixed",""),_1:{ctor:"[]"}}},{ctor:"::",_0:l(Tn,{ctor:"[]"},{ctor:"::",_0:l(fn,{ctor:"::",_0:Sn("title"),_1:{ctor:"[]"}},{ctor:"::",_0:l(mn,{ctor:"[]"},{ctor:"::",_0:un("Meme it up"),_1:{ctor:"[]"}}),_1:{ctor:"::",_0:l(mn,{ctor:"::",_0:Sn("marketing"),_1:{ctor:"[]"}},{ctor:"::",_0:un("A project from "),_1:{ctor:"::",_0:l(hn,{ctor:"::",_0:Ln("https://www.dailydrip.com"),_1:{ctor:"[]"}},{ctor:"::",_0:un("DailyDrip"),_1:{ctor:"[]"}}),_1:{ctor:"[]"}}}),_1:{ctor:"[]"}}}),_1:{ctor:"[]"}}),_1:{ctor:"[]"}}),_1:{ctor:"::",_0:l(fn,{ctor:"::",_0:Sn("section group"),_1:{ctor:"[]"}},{ctor:"::",_0:l(fn,{ctor:"::",_0:Sn("col span_1_of_2"),_1:{ctor:"[]"}},{ctor:"::",_0:l(Dn,{ctor:"::",_0:l(yn,"heading","Fiddle with this junk"),_1:{ctor:"[]"}},{ctor:"::",_0:l(fn,{ctor:"::",_0:Sn("card-content"),_1:{ctor:"[]"}},{ctor:"::",_0:l(Hn,{ctor:"::",_0:In(et),_1:{ctor:"::",_0:l(yn,"label","URL"),_1:{ctor:"::",_0:Cn(e.url),_1:{ctor:"[]"}}}},{ctor:"[]"}),_1:{ctor:"::",_0:l(vn,{ctor:"[]"},{ctor:"[]"}),_1:{ctor:"::",_0:l(Hn,{ctor:"::",_0:In(Zn),_1:{ctor:"::",_0:l(yn,"label","Top"),_1:{ctor:"::",_0:Cn(e.top),_1:{ctor:"[]"}}}},{ctor:"[]"}),_1:{ctor:"::",_0:l(vn,{ctor:"[]"},{ctor:"[]"}),_1:{ctor:"::",_0:l(Hn,{ctor:"::",_0:In(Qn),_1:{ctor:"::",_0:l(yn,"label","Bottom"),_1:{ctor:"::",_0:Cn(e.bottom),_1:{ctor:"[]"}}}},{ctor:"[]"}),_1:{ctor:"[]"}}}}}}),_1:{ctor:"[]"}}),_1:{ctor:"[]"}}),_1:{ctor:"::",_0:l(fn,{ctor:"::",_0:Sn("col span_1_of_2"),_1:{ctor:"[]"}},{ctor:"::",_0:l(Dn,{ctor:"::",_0:l(yn,"heading","Oooh look you made a thing"),_1:{ctor:"[]"}},{ctor:"::",_0:l(fn,{ctor:"::",_0:Sn("card-content"),_1:{ctor:"[]"}},{ctor:"::",_0:l(Hn,{ctor:"::",_0:l(yn,"disabled","true"),_1:{ctor:"::",_0:l(yn,"label","Meme URL (copy it, paste elsewhere, make memes dreams)"),_1:{ctor:"::",_0:Cn(d(Yn,e.url,e.top,e.bottom)),_1:{ctor:"[]"}}}},{ctor:"[]"}),_1:{ctor:"::",_0:l(gn,{ctor:"::",_0:Mn(d(Yn,e.url,e.top,e.bottom)),_1:{ctor:"[]"}},{ctor:"[]"}),_1:{ctor:"[]"}}}),_1:{ctor:"[]"}}),_1:{ctor:"[]"}}),_1:{ctor:"[]"}}}),_1:{ctor:"[]"}}}),_1:{ctor:"::",_0:zn,_1:{ctor:"[]"}}})},tt=dn({view:nt,init:$n,update:Xn,subscriptions:Jn})(),rt={};if(rt.Main=rt.Main||{},"undefined"!=typeof tt&&tt(rt.Main,"Main",void 0),"function"==typeof define&&define.amd)return void define([],function(){return rt});if("object"==typeof e)return void(e.exports=rt);var ot=this.Elm;if("undefined"==typeof ot)return void(this.Elm=rt);for(var at in rt){if(at in ot)throw new Error("There are two Elm modules called `"+at+"` on this page! Rename one of them.");ot[at]=rt[at]}}).call(this)}]);